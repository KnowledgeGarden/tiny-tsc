\ 061596 putting in structural relationship slots comparable to sub.ofC:	STATE	sub.of	propertyC:  PARTS     LEVEL           BASIC    SUB.OF          TAXONOMIC.SLOT    TO.PUT          %put&tax    INVERSE.SLOT    PART.OF    LEGAL.VALUES    SYMBOLC:  PART.OF     LEVEL           BASIC    SUB.OF          TAXONOMIC.SLOT    INVERSE.SLOT    PARTS    LEGAL.VALUES    STUFF THING IDEA RECIPE    TO.PUT          %put&taxC:  ATTACHMENTS    LEVEL           BASIC    SUB.OF          TAXONOMIC.SLOT    TO.PUT          %put&tax    INVERSE.SLOT    ATTACHED.TO    LEGAL.VALUES    SYMBOLC:  ATTACHED.TO     LEVEL           BASIC    SUB.OF          TAXONOMIC.SLOT    INVERSE.SLOT    ATTACHMENTS    LEGAL.VALUES    STUFF THING IDEA RECIPE    TO.PUT          %put&taxC:  CONTENTS    LEVEL           BASIC    SUB.OF          TAXONOMIC.SLOT    TO.PUT          %put&tax    INVERSE.SLOT    CONTAINED.IN    LEGAL.VALUES    SYMBOLC:  CONTAINED.IN     LEVEL           BASIC    SUB.OF          TAXONOMIC.SLOT    INVERSE.SLOT    CONTENTS    LEGAL.VALUES    STUFF THING IDEA RECIPE    TO.PUT          %put&tax\ token.for (abort-trace is abort-trace\ 950116  fla: added minus.list from rule.build.t{ a neat little word to take a symbol and a list and union the two. ( union 'x '( x y z ) ) --> ( x y z )  ( union 'x '( a b c ) ) --> ( x a b c )Used in consensus? in expectations.t }c: Union   							    instance.of flow.func    my.creator  fla    i.take      sx list    i.give      list    arguments	*thing *list    algorithm   ( do  ( if.true ( not? ( member? *thing *list ) )    							( bindq *list ( cons *thing *list ) ) )    				  ( return *list ) )c:	Log.Frame	instance.of	flow.func	i.take		symbol	i.give		none	forth		%LOG.NODE	c:	Conjectured.Rule	\ 950110	sub.of	rule	INHERIT>        ( RULE.FIRE ( FIRE.PROCESS.RULE ) )C:  Conjectured.EPISODE     LEGAL.VALUE.OF  PREV.EPISODE NEXT.EPISODE SUPER.EPISODES SUB.EPISODES    LEVEL           BASIC    SUB.OF          conjectured.rule    INHERIT>        ( RULE.FIRE ( FIRE.EPISODE ) ): SetupRule	( con -- )	dup to-anchor current-concept	'' if.actors to-anchor current-slot	comp.actor 	 '' conjectured.rule '' instances SLOT.PUT		( atom concept slot -- )	 ;				c:	SetupConjRule	instance.of	flow.func	my.creator	jp2	i.take		symbol	i.give		none	forth		%SetupRule	c:	InitConjRule	instance.of	flow.func	my.creator	jp2	i.take		symbol	i.give		symbol	arguments	*rule	my.vars		*temp	algorithm	( do		( if.true	( notnull? ( get *rule 'if.relates ) )			( insert.value *rule 'my.lhs 'if.relates ) )		( if.true	( notnull? ( get *rule 'if.not.relates ) )			( insert.value *rule 'my.lhs 'if.not.relates ) )		( if.true	( notnull? ( get *rule 'if.states ) )			( insert.value *rule 'my.lhs 'if.states ) )		( if.true	( notnull? ( get *rule 'if.not.states ) )			( insert.value *rule 'my.lhs 'if.not.states ) )		( if.true	( notnull? ( get *rule 'then.relates ) )			( insert.value *rule 'my.rhs 'then.relates ) )		( if.true	( notnull? ( get *rule 'then.states ) )			( insert.value *rule 'my.rhs 'then.states ) )		( if.true	( notnull? ( get *rule 'then.actors ) )			( insert.value *rule 'my.rhs 'then.actors ) )		( if.true	( notnull? ( get *rule 'then.create ) )			( insert.value *rule 'my.rhs 'then.create ) )		( setupconjrule *rule ) 		( return *rule ) ): SetupEpisode	( con -- )	dup to-anchor current-concept	'' if.actors to-anchor current-slot	 '' conjectured.episode '' instances SLOT.PUT		( atom concept slot -- )	 ;				c:	SetupConjEpisode	instance.of	flow.func	my.creator	jp2	i.take		symbol	i.give		none	forth		%SetupEpisode	c:	InitConjEpisode	instance.of	flow.func	my.creator	jp2	i.take		symbol	i.give		none	arguments	*rule	my.vars		*temp	algorithm	( do		( if.true	( notnull? ( get *rule 'if.relates ) )			( insert.value *rule 'my.lhs 'if.relates ) )		( if.true	( notnull? ( get *rule 'if.states ) )			( insert.value *rule 'my.lhs 'if.states ) )		( if.true	( notnull? ( get *rule 'then.relates ) )			( insert.value *rule 'my.rhs 'then.relates ) )		( if.true	( notnull? ( get *rule 'then.states ) )			( insert.value *rule 'my.rhs 'then.states ) )		( setupconjepisode *rule ) )	c:	INC.VALUE	instance.of	flow.func	my.creator	jp2	i.take		symbol symbol number	i.give		none	arguments	*con *slot *val	my.vars		*temp	algorithm	( set.value *con *slot					( plus *val ( value.of *con *slot ) ) )					\ a word added by FLA: used to delete all nils or whatever from a listc:  DELETE.ALL              instance.of         flow.func    my.creator          fla    i.take              sx list    i.give              list    arguments           *bit    *list    algorithm   ( do ( loop.until ( not? ( member? *bit *list ) )                        ( bindq *list ( delete *bit *list ) ) )                    ( return *list ) )  c:  delete.dups	instance.of 	flow.func	my.creator		fla	i.take			list	i.give			list	arguments		*list	my.vars			*temp *try *tried	algorithm		( do ( bindq *temp *list )						( bindq *tried nil )						( loop.until ( null? *temp ) 							( do ( bindq *try ( first *temp ) )								( bindq *temp ( rest *temp ) )								( bindq *tried ( eunion *try *tried ) ) ) )						( bindq  *tried ( reverse *tried ) )						( return *tried ) )  \ ##### MINUS.LIST #############################{ Subtracts one list from another.  Takes two lists, returns one.	( MINUS.LIST '( a b c d ) '( b c t r ) --> ( t r )  }c:	MINUS.LIST	instance.of		flow.func	my.creator		fla	i.take			list list	i.give			list	arguments		*list1 *list2	my.vars			*try *temp	algorithm		( do ( bindq  *temp  nil ) 						 ( loop.until ( null?  *list2 )							( do ( bindq *try ( first *list2 ) )								( bindq *list2 ( rest *list2 ) )								( if.true ( not? ( member? *try *list1 ) )									( bindq *temp ( cons  *try  *temp ) ) ) ) ) 						 ( return *temp ) )\ sub/super.sc:	SUB.LIST?	instance.of		flow.pred	i.take			list list	i.give			flag	arguments		*shorty *longy	my.vars			*truth	algorithm		( do	( bindq *truth T )		( loop.until	( null? *shorty )					( cond	( ( not? ( member? ( first *shorty ) *longy ) )							  ( do	( bindq *shorty nil ) 	\ kill list									( bindq *truth F ) ) )					\ =================					\ idea here is that if a member of short list is not					\ a member of long list, short is not a sublist of long					\ so kill short and end test					\ =================							( T ( bindq *shorty ( rest *shorty ) ) ) ) )		( return *truth ) )		\ ================\	we don't actually test for super, just sub, by comparing a short list\	to a longer list by checking membership of each element of short list\	in longer list.\ =================c:	COMPARE.LISTS?	instance.of		flow.pred	i.take			list list	i.give			flag	\ true if same, sub, or super	arguments		*list1 *list2	my.vars			*truth	algorithm	( do		( cond	( ( same? *list1 *list2 )				  ( bindq *truth T ) )		\ they are the same				( ( greater.than? ( length *list1 ) ( length *list2 ) )				  ( bindq *truth ( sub.list? *list2 *list1 ) ) )				( T ( bindq *truth ( sub.list? *list1 *list2 ) ) ) )		( return *truth ) )		{	here's how these are used:	( sub.list? '( aa bb ) '( aa cc ) ) ÑÑ> F ok 	( compare.lists? '( aa bb ) '( aa bb cc ) ) ÑÑ> T ok 	( compare.lists? '( aa bb cc ) '( aa bb ) ) ÑÑ> T ok 	( compare.lists? '( aa bb cc ) '( aa bb xx ) ) ÑÑ> F ok 	Use with if.actors, if.relates, if.states}