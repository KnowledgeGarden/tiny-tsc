{	QPDEFS.Tdescription:	xneed to do:		xto improve:		xPROBLEMS:	xnotes:			x=== PLEASE FORMAT this doc with NewCentury Font, tab stops 4, 12 pt, Margin 100, Reduced 73 %.=== ANNOTATION: #### = HACK, ???? = QUESTION, **** = UNTESTED, $$$$ = TO-DO, &&&& = NOTECHANGES:}{	mostly, this is a file of relations experienced in a qualitative physics kb	most of these relations will be slots in QP knowledge basesCOMP.LEGAL/TAX	checks if new concept is legal for a relation to another concept						checks to see if the slot value is legal						compiles this concept to inverse slot of slot value (by UNION)COMP.INSTANCE	compiles this concept to inverse slot of slot value (by UNION)		looks to see if this concept is instance of something which has		compile-time behaviors to executemGet		"method" get -- basically uses any "to.get" method compiled for a slot					if you want to take advantage of different slot getting methods, use this in 4th codepGet		the basic slot "get" method -- nothing fancyiGet		iGET is an instance of a getmethod callable by mGET. It either						gets the slot's value, or inherits up the SUBS/INSTANCES tree						NOTE: we can inherit up the SUB.OF route--recursively all the way to SUPER--					but we don't deal with VIEW.OF--Inheritance along VIEW.OF is at risk of looping						e.g. water view.of ice and ice view.of water.mPut		"method" put -- like mGet, it uses put methods defined in "to.put" slotspPut		the basic slot "put" method}\ ______________________________________________________________________ SUPPORT PREDICATES\	these predicates are given a list of numbers -- data\	they return truth based on their tests of the data\ =============================={	STEADY.CURVE?	description:		x	example input:		x	example output:	x	notes:				x}c:	STEADY.CURVE?	instance.of			flow.pred	i.take				none	i.give				none\ =============================={	CHANGING.CURVE?	description:		x	example input:		x	example output:	x	notes:				x}c:	CHANGING.CURVE?	instance.of			flow.pred	i.take				none	i.give				none\ =============================={	SLOPE.CHANGE?	description:		x	example input:		x	example output:	x	notes:				x}c:	SLOPE.CHANGE?	instance.of			flow.pred	i.take				none	i.give				none\ =============================={	STEP.CHANGE?	description:		x	example input:		x	example output:	x	notes:				x}c:	STEP.CHANGE?	instance.of			flow.pred	i.take				none	i.give				none\ =============================={	TRANS.CHANGE?	description:		x	example input:		x	example output:	x	notes:				x}c:	TRANS.CHANGE?	instance.of			flow.pred	i.take				none	i.give				none\ =============================={	OSCILLATING?	description:		x	example input:		x	example output:	x	notes:				x}c:	OSCILLATING?	instance.of			flow.pred	i.take				none	i.give				none\ =============================={	INCREASING?	description:		x	example input:		x	example output:	x	notes:				x}c:	INCREASING?	instance.of			flow.pred	i.take				none	i.give				none\ =============================={	CONTAINS?	description:		x	example input:		x	example output:	x	notes:				x}c:	CONTAINS?	instance.of			flow.pred	i.take				none	i.give				none\ ______________________________________________________________________ CHANGE / VALUES\ note similarity to HLL predicates on some of these\ ______________________________________________________________________ What's Happening\	each of these can get a "fillin examples" task, when given some data\ =============================={	STEADY	description:		x	example input:		x	example output:	x	notes:				x}c:	STEADY	level				basic	sub.of				relation	definition			steady.curve?\ =============================={	CHANGING	description:		x	example input:		x	example output:	x	notes:				x}c:	CHANGING	level				basic	sub.of				relation	definition			changing.curve?	disjoint.from		steady\ =============================={	SLOPE.CHANGE	description:		x	example input:		x	example output:	x	notes:				x}c:	SLOPE.CHANGE	level				basic	sub.of				changing	definition			slope.change?\ =============================={	STEP.CHANGE	description:		x	example input:		x	example output:	x	notes:				x}c:	STEP.CHANGE	level				basic	sub.of				changing	definition			step.change?\ =============================={	TRANSIENT.CHANGE	description:		x	example input:		x	example output:	x	notes:				x}c:	TRANSIENT.CHANGE	level				basic	sub.of				changing	definition			trans.change?\ =============================={	OSCILLATING.CHANGE	description:		x	example input:		x	example output:	x	notes:				x}c:	OSCILLATING.CHANGE	level				basic	sub.of				changing	definition			oscillating?\ =============================={	INCREASING	description:		x	example input:		x	example output:	x	notes:				x}c:	INCREASING	level				basic	sub.of				changing	definition			increasing?\ e.g. accel.increase would be a view.of increasing if we have a\	protohistory for something (increasing) accelerating\ =============================={	ACCEL.INCREASE	description:		x	example input:		x	example output:	x	notes:				x}c:	ACCEL.INCREASE	level				basic	sub.of				changing\ =============================={	DECEL.INCREASE	description:		x	example input:		x	example output:	x	notes:				x}c:	DECEL.INCREASE	level				basic	sub.of				changing\ =============================={	STEADY.INCREASE	description:		x	example input:		x	example output:	x	notes:				x}c:	STEADY.INCREASE	level				basic	sub.of				changing\ =============================={	DECREASING	description:		x	example input:		x	example output:	x	notes:				x}c:	DECREASING	level				basic	sub.of				changing\ =============================={	ACCEL.DECREASE	description:		x	example input:		x	example output:	x	notes:				x}c:	ACCEL.DECREASE	level				basic	sub.of				changing\ =============================={	STEADY.DECREASE	description:		x	example input:		x	example output:	x	notes:				x}c:	STEADY.DECREASE	level				basic	sub.of				changing\ =============================={	DECEL.DECREASE	description:		x	example input:		x	example output:	x	notes:				x}c:	DECEL.DECREASE	level				basic	sub.of				changing	inverse.value		steady.decrease accel.decrease\ =============================={	OSCILLATING	description:		x	example input:		x	example output:	x	notes:				x}c:	OSCILLATING	level				basic	sub.of				changing	inverse.value		steady\ may be same as chaotic\ =============================={	STUTTERING	description:		x	example input:		x	example output:	x	notes:				x}c:	STUTTERING	level				basic	sub.of				changing	inverse.value		steady\ =============================={	CHAOTIC	description:		x	example input:		x	example output:	x	notes:				x}c:	CHAOTIC	level				basic	sub.of				changing	inverse.value		steady\ ______________________________________________________________________ How Much\ =============================={	MORE.THAN	description:		x	example input:		x	example output:	x	notes:				x}c:	MORE.THAN	sub.of				relation\ =============================={	LESS.THAN	description:		x	example input:		x	example output:	x	notes:				x}c:	LESS.THAN	sub.of				relation	disjoint.from		more.than	inverse.value		more.than\ =============================={	EQUAL	description:		x	example input:		x	example output:	x	notes:				x}c:	EQUAL	sub.of				relation	disjoint.from		less.than more.than\ =============================={	ACTIVE	description:		x	example input:		x	example output:	x	notes:				x}c:	ACTIVE	sub.of				relation\ =============================={	REACTIVE	description:		x	example input:		x	example output:	x	notes:				x}c:	REACTIVE	sub.of				relation\ ______________________________________________________________________ How it's Happening\ =============================={	NOT.ACCELERATING	description:		x	example input:		x	example output:	x	notes:				x}c:	NOT.ACCELERATING	sub.of				relation\ =============================={	DECELERATING	description:		x	example input:		x	example output:	x	notes:				x}c:	DECELERATING	sub.of				relation\ =============================={	ACCELERATING	description:		x	example input:		x	example output:	x	notes:				x}c:	ACCELERATING	sub.of				relation	disjoint.from		decelerating\ this one is for sensors\ =============================={	MEASURES	description:		x	example input:		x	example output:	x	notes:				x}c:	MEASURES	sub.of				relation\ this one collects sensors\ =============================={	MEASURED.BY	description:		x	example input:		x	example output:	x	notes:				x}c:	MEASURED.BY	sub.of				relation	inverse.slot			measures\ this one is for databases\ =============================={	MEASURE.OF	description:		x	example input:		x	example output:	x	notes:				x}c:	MEASURE.OF	sub.of				relation\ this one collects database examples\ =============================={	MEASURED.IN	description:		x	example input:		x	example output:	x	notes:				x}c:	MEASURED.IN	sub.of				relation	inverse.slot			measure.of\ =============================={	CAUSES	description:		x	example input:		x	example output:	x	notes:				x}c:	CAUSES	sub.of				relation\ =============================={	CAUSED.BY	description:		x	example input:		x	example output:	x	notes:				x}c:	CAUSED.BY	sub.of				relation	inverse.slot			causes\ =============================={	QUAL.INCREASE	description:		x	example input:		x	example output:	x	notes:				x}c:	QUAL.INCREASE	sub.of				relation\ =============================={	QUAL.DECREASE	description:		x	example input:		x	example output:	x	notes:				x}c:	QUAL.DECREASE	sub.of				relation\ =============================={	QUAL.STEADY	description:		x	example input:		x	example output:	x	notes:				x}c:	QUAL.STEADY	sub.of				relation\ =============================={	QUAN.INCREASE	description:		x	example input:		x	example output:	x	notes:				x}c:	QUAN.INCREASE	sub.of				relation\ =============================={	QUAN.DECREASE	description:		x	example input:		x	example output:	x	notes:				x}c:	QUAN.DECREASE	sub.of				relation\ =============================={	QUAN.STEADY	description:		x	example input:		x	example output:	x	notes:				x}c:	QUAN.STEADY	sub.of				relation\ =============================={	QUAN.PERIODIC	description:		x	example input:		x	example output:	x	notes:				x}c:	QUAN.PERIODIC	sub.of				relation\ =============================={	QUAN.CHAOTIC	description:		x	example input:		x	example output:	x	notes:				x}c:	QUAN.CHAOTIC	sub.of				relation\ ____________________________________________________________ Verbs follow\ =============================={	INCREASE	description:		x	example input:		x	example output:	x	notes:				x}c:	INCREASE\ =============================={	DECREASE	description:		x	example input:		x	example output:	x	notes:				x}c:	DECREASE\ probably should be "hold" or "hold.same" or somesuch\ =============================={	SAME	description:		x	example input:		x	example output:	x	notes:				x}c:	SAME\ ______________________________________________________________________ STRUCTURAL\ collects the individual components of an entity\ =============================={	HAS.PARTS	description:		x	example input:		x	example output:	x	notes:				x}c:	HAS.PARTS	level				basic	sub.of				relation\ =============================={	PART.OF	description:		x	example input:		x	example output:	x	notes:				x}c:	PART.OF	level				basic	sub.of				relation	inverse.slot			has.parts\ =============================={	HAS.STRUCTURE	description:		x	example input:		x	example output:	x	notes:				x}c:	HAS.STRUCTURE	level				basic	sub.of				relation	to.get				%iget\ =============================={	STRUCTURE.OF	description:		x	example input:		x	example output:	x	notes:				x}c:	STRUCTURE.OF	level				basic	sub.of				relation	inverse.slot			has.structure	to.get				%iget\ =============================={	SUSPENDED.IN	description:		x	example input:		x	example output:	x	notes:				watch this **** chemical or mechanical suspension}c:	SUSPENDED.IN	sub.of				relation\ =============================={	SUSPENDS	description:		x	example input:		x	example output:	x	notes:				needs compiler}c:	SUSPENDS	sub.of				relation	inverse.slot			suspended.in\ =============================={	CONNECTED	description:		x	example input:		x	example output:	x	notes:				x}c:	CONNECTED	sub.of				relation\ =============================={	ATTACHED.TO	description:		x	example input:		x	example output:	x	notes:				x\ there are several possible kinds of attachment: intracellular, extracellular, nuclear, ribosomal, etc}c:	ATTACHED.TO	sub.of				relation	synonym			connected\ =============================={	NOT.ATTACHED.TO	description:		x	example input:		x	example output:	x	notes:				x}c:	NOT.ATTACHED.TO	sub.of				relation	inverse.value		attached.to connected\ =============================={	DISCONNECTED	description:		x	example input:		x	example output:	x	notes:				x\ disconnected is different from not.connected\	not.attached.to (not.connected) doesn't require a processes\	but disconnected implies something broke a connection}c:	DISCONNECTED	sub.of				relation	inverse.value		disconnected	synonym			not.attached.to\ ______________________________________________________________________ SPATIAL\ =============================={	SPATIAL.LOCATION	description:		x	example input:		x	example output:	x	notes:				x}c:	SPATIAL.LOCATION	level				basic	sub.of				relation	to.get				%iget\	legal.for			individual.object\ =============================={	ABUTS	description:		x	example input:		x	example output:	x	notes:				x}c:	ABUTS	level				basic	sub.of				relation	inverse.slot			abuts\ =============================={	CONTAINS	description:		containment, where you can imagine *X as a container	example input:		( contains ( *x *y ) true )	example output:	x	notes:				x}c:	CONTAINS	sub.of				relation	definition			contains?\ =============================={	CONTAINED.IN	description:		x	example input:		x	example output:	x	notes:				x}c:	CONTAINED.IN	sub.of				relation	inverse.slot			contains\ ____________________________________________________________ There will be lots of these...\ =============================={	LOCATED.ON	description:		x	example input:		x	example output:	x	notes:				x}c:	LOCATED.ON	level				basic	sub.of				relation\ =============================={	LOCATED.BESIDE	description:		x	example input:		x	example output:	x	notes:				x}c:	LOCATED.BESIDE	level				basic	sub.of				relation\ =============================={	LOCATED.UNDER	description:		x	example input:		x	example output:	x	notes:				x}c:	LOCATED.UNDER	level				basic	sub.of				relation\ =============================={	LOCATED.BEHIND	description:		x	example input:		x	example output:	x	notes:				x}c:	LOCATED.BEHIND	level				basic	sub.of				relation\ =============================={	LOCATED.IN.FRONT	description:		x	example input:		x	example output:	x	notes:				x}c:	LOCATED.IN.FRONT	level				basic	sub.of				relation\ ______________________________________________________________________ TEMPORAL\ ______________________________________________________________________ Time Scales\ =============================={	GEOLOGICAL.TIME	description:		x	example input:		x	example output:	x	notes:				x}c:	GEOLOGICAL.TIME	sub.of				relation	values				epoch	legal.value.of		time.scale\ =============================={	ATOMIC.TIME	description:		x	example input:		x	example output:	x	notes:				x}c:	ATOMIC.TIME	sub.of				relation	values				nano.second	legal.value.of		time.scale\ =============================={	MOLECULAR.TIME	description:		x	example input:		x	example output:	x	notes:				x}c:	MOLECULAR.TIME	sub.of				relation	legal.value.of		time.scale	values				microsecond millisecond second minute hour day\ =============================={	HUMAN.TIME	description:		x	example input:		x	example output:	x	notes:				x}c:	HUMAN.TIME	sub.of				relation	values			day week month year	legal.value.of	time.scale\ =============================={	TEMPORAL.LOCATION	description:		x	example input:		x	example output:	x	notes:				x}c:	TEMPORAL.LOCATION	level				basic	sub.of				relation	to.get				%iget\	legal.for			individual.object\ =============================={	TIMING	description:		x	example input:		x	example output:	x	notes:				x}c:	TIMING	level				basic	sub.of				relation\ =============================={	STARTS.BEFORE	description:		x	example input:		x	example output:	x	notes:				x}\ ____________________________________________________________ There will be lots of these...c:	STARTS.BEFORE	level				basic	sub.of				relation\ =============================={	STARTS.DURING	description:		x	example input:		x	example output:	x	notes:				x}c:	STARTS.DURING	level				basic	sub.of				relation\ c:	STARTS.AFTER.START\ =============================={	STARTS.AFTER.END	description:		x	example input:		x	example output:	x	notes:				x}c:	STARTS.AFTER.END	level				basic	sub.of				relation\ =============================={	ENDS.AFTER.END	description:		x	example input:		x	example output:	x	notes:				x}c:	ENDS.AFTER.END	level				basic	sub.of				relation\ =============================={	ENDS.BEFORE	description:		x	example input:		x	example output:	x	notes:				x}c:	ENDS.BEFORE	level				basic	sub.of				relation\ =============================={	ENDS.DURING	description:		x	example input:		x	example output:	x	notes:				x}c:	ENDS.DURING	level				basic	sub.of				relation\ ______________________________________________________________________ When it's Happening\ =============================={	BEFORE	description:		x	example input:		x	example output:	x	notes:				x}c:	BEFORE	sub.of				relation	legal.value.of		temporal.location\ =============================={	LONG.BEFORE	description:		x	example input:		x	example output:	x	notes:				x}c:	LONG.BEFORE	sub.of				relation	legal.value.of		temporal.location\ =============================={	AFTER	description:		x	example input:		x	example output:	x	notes:				x}c:	AFTER	sub.of				relation	inverse.value		before	legal.value.of		temporal.location\ =============================={	LONG.AFTER	description:		x	example input:		x	example output:	x	notes:				x}c:	LONG.AFTER	sub.of				relation	inverse.value		long.before	legal.value.of		temporal.location\ =============================={	DURING	description:		x	example input:		x	example output:	x	notes:				x}c:	WHILE	sub.of				relationc:	DURING	sub.of				relation	synonym			while	legal.value.of		temporal.location\ ______________________________________________________________________ MISCELLANEOUS\ =============================={	TO.DO	description:		x	example input:		x	example output:	x	notes:				xc:	TO.DO	level				basic	sub.of				relation	legal.for			episode}