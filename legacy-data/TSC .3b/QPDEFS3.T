{	QPDEFS3.Tdescription:	xneed to do:		xto improve:		xPROBLEMS:	is (polymer (x) true) a state or a relation of x to itself????notes:			x=== PLEASE FORMAT this doc with NewCentury Font, tab stops 4, 12 pt, Margin 100, Reduced 73 %.=== ANNOTATION: #### = HACK, ???? = QUESTION, **** = UNTESTED, $$$$ = TO-DO, &&&& = NOTECHANGES:}{ Intended to work with messages stored in slots in the episodes of an envisionment.	THESE RULES ARE A "HACK" used primarily to test the envisionment engine.	Mostly, they do nothing of significance, generally causing the episodes they build	to be "killed."	WHAT'S NEEDED is to use them as templates for rules of substance and generality.}\ ______________________________________________________________________ PHYS.PROCESSCOMMENT: this rule needs to explicity define amount.of and temperature rather than have nested	sentences\ =============================={	EVAPORATION	description:		x	example input:		x	example output:	x	notes:				x}c:	EVAPORATION	level				basic	sub.of				phys.process	instance.of			process.rule	my.creator			jp2	analogies			boiling	if.actors			( ( container ( *container ) true )							( liquid ( *fluid ) true )							( gas ( *environment ) true ) )	if.relates			( ( contains ( *container *fluid ) true )							( abuts ( *fluid *environment ) true ) )	if.states			( ( greater.than ( temperature ( *fluid ) temperature ( *environment ) ) true ) )	then.states			( ( decreasing ( amount.of ( *fluid ) ) true )						  ( decreasing ( temperature ( *fluid ) ) true ) )	then.expect			( ( empty ( *container ) true ) )COMMENT;\ =============================={	HEAT.TRANS.STARTUP	description:		x	example input:		x	example output:	x	notes:				x}c:	HEAT.TRANS.STARTUP	level				basic	sub.of				phys.process	instance.of			process.rule	my.creator			jp2	if.actors			( ( heat.source ( *heat.source ) true )							( heat.sink ( *heat.sink ) true )							( gas ( *convective.medium ) true )							( heat.source.sensor ( *t1 ) true )							( heat.sink.sensor ( *t2 ) true )							( i.heat.sink.sensor ( *t3 ) true ) )	if.to.do				( ( increase ( *t1 ) true ) )	if.relates			( ( abuts ( *heat.sink *convective.medium ) true )						  ( abuts ( *heat.source *convective.medium ) true ) )	if.states				( ( active ( *heat.source ) false ) )	then.states			( ( active ( *heat.source ) true )							( greater.than ( *t1 *t2 ) true )							( increasing ( *t1 ) true )							( decreasing ( *t1 ) false )							( decreasing ( *t2 ) false )							( same ( *t1 ) false )							( same ( *t2 ) false )							( equal ( *t1 room.temp ) false ) )\	then.forget			( ( active ( *heat.source ) false ) )\ without additional heat input\ =============================={	CONVECT.HEAT.TRANS.NOTDRIVEN	description:		x	example input:		x	example output:	x	notes:				x}c:	CONVECT.HEAT.TRANS.NOTDRIVEN	level				basic	sub.of				phys.process	instance.of			process.rule	my.creator			jp2	if.actors			( ( heat.source ( *heat.source ) true )							( heat.sink ( *heat.sink ) true )							( gas ( *convective.medium ) true )							( heat.source.sensor ( *t1 ) true )							( heat.sink.sensor ( *t2 ) true )							( i.heat.sink.sensor ( *t3 ) true ) )	if.relates			( ( abuts ( *heat.sink *convective.medium ) true )							( abuts ( *heat.source *convective.medium ) true ) )	if.states				( ( greater.than ( *t1 *t2 ) true )							( active ( *heat.source ) false )							( decreasing ( *t1 ) true ) )	if.not.states			( ( increasing ( *t2 ) true ) )	then.states			( ( increasing ( *t2 ) true ) )\ with additional heat input, not enough\ =============================={	CONVECT.HEAT.TRANS.UNDERDRIVEN	description:		x	example input:		x	example output:	x	notes:				x}c:	CONVECT.HEAT.TRANS.UNDERDRIVEN	level				basic	sub.of				phys.process	instance.of			process.rule	my.creator			jp2	if.actors			( ( heat.source ( *heat.source ) true )							( heat.sink ( *heat.sink ) true )							( gas ( *convective.medium ) true )							( heat.source.sensor ( *t1 ) true )							( heat.sink.sensor ( *t2 ) true )							( i.heat.sink.sensor ( *t3 ) true ) )	if.relates			( ( abuts ( *heat.sink *convective.medium ) true )							( abuts ( *heat.source *convective.medium ) true ) )	if.states				( ( greater.than ( *t1 *t2 ) true )							( decreasing ( *t1 ) true ) )	if.not.states			( ( increasing ( *t2 ) true ) )	then.states			( ( increasing ( *t2 ) true ) )\ with additional heat input, just enough\ =============================={	CONVECT.HEAT.TRANS.DRIVEN	description:		x	example input:		x	example output:	x	notes:				x}c:	CONVECT.HEAT.TRANS.DRIVEN	level				basic	sub.of				phys.process	instance.of			process.rule	my.creator			jp2	if.actors			( ( heat.source ( *heat.source ) true )							( heat.sink ( *heat.sink ) true )							( gas ( *convective.medium ) true )							( heat.source.sensor ( *t1 ) true )							( heat.sink.sensor ( *t2 ) true )							( i.heat.sink.sensor ( *t3 ) true ) )	if.relates			( ( abuts ( *heat.sink *convective.medium ) true )							( abuts ( *heat.source *convective.medium ) true ) )	if.states				( ( greater.than ( *t1 *t2 ) true )							( same ( *t1 ) true ) )	if.not.states			( ( increasing ( *t2 ) true ) )	then.states			( ( increasing ( *t1 ) false )							( same ( *t1 ) true )							( decreasing ( *t1 ) false )							( increasing ( *t2 ) true ) )\ with additional heat input, too much\	( equal ( *t1 room.temp ) false ) ---- is a HACK--bad, very bad!	####\	this rule will probably always fire, even when overdriven.2 should\ =============================={	CONVECT.HEAT.TRANS.OVERDRIVEN.1	description:		x	example input:		x	example output:	x	notes:				x}c:	CONVECT.HEAT.TRANS.OVERDRIVEN.1	level				basic	sub.of				phys.process	instance.of			process.rule	my.creator			jp2	if.actors			( ( heat.source ( *heat.source ) true )							( heat.sink ( *heat.sink ) true )							( gas ( *convective.medium ) true )							( heat.source.sensor ( *t1 ) true )							( heat.sink.sensor ( *t2 ) true )							( i.heat.sink.sensor ( *t3 ) true ) )	if.relates			( ( abuts ( *heat.sink *convective.medium ) true )							( abuts ( *heat.source *convective.medium ) true ) )	if.states				( ( greater.than ( *t1 *t2 ) true )							( increasing ( *t1 ) true ) )	if.not.states			( ( increasing ( *t2 ) true ) )	then.states			( ( increasing ( *t2 ) true ) )\ =============================={	CONVECT.HEAT.TRANS.OVERDRIVEN.2	description:		x	example input:		x	example output:	x	notes:				should not (greater.than (x y) true) be a relation ????}c:	CONVECT.HEAT.TRANS.OVERDRIVEN.2	level				basic	sub.of				phys.process	instance.of			process.rule	my.creator			jp2	if.actors			( ( heat.source ( *heat.source ) true )							( heat.sink ( *heat.sink ) true )							( gas ( *convective.medium ) true )							( heat.source.sensor ( *t1 ) true )							( heat.sink.sensor ( *t2 ) true )							( i.heat.sink.sensor ( *t3 ) true ) )	if.relates			( ( abuts ( *heat.sink *convective.medium ) true )							( abuts ( *heat.source *convective.medium ) true ) )	if.states			( ( active ( *heat.source ) true )							( greater.than ( *t1 *t2 ) true )							( increasing ( *t1 ) true ) )	if.not.states			( ( increasing ( *t2 ) true ) )	if.to.do				( ( increase ( *heat.source ) true ) )	then.states			( ( increasing ( *t2 ) true ) )\ without additional heat input\ =============================={	CONDUCT.HEAT.TRANS.NOTDRIVEN	description:		x	example input:		x	example output:	x	notes:				x}c:	CONDUCT.HEAT.TRANS.NOTDRIVEN	level				basic	sub.of				phys.process	instance.of			process.rule	my.creator			jp2	if.actors			( ( heat.source ( *heat.source ) true )							( heat.sink ( *heat.sink ) true )							( source.temp.sensor ( *t1 ) true )							( sink.temp.sensor ( *t2 ) true ) )	if.relates			( ( abuts ( *heat.sink *heat.source ) true ) )	if.states			( ( greater.than ( *t1 *t2 ) true ) )	then.states			( ( decreasing ( *t2 ) false )							( increasing ( *t2 ) true )							( decreasing ( *t1 ) true )							( increasing ( *t1 ) false )							( active ( *heat.source ) false ) )\ with additional heat input, not enough\ =============================={	CONDUCT.HEAT.TRANS.UNDERDRIVEN	description:		x	example input:		x	example output:	x	notes:				x}c:	CONDUCT.HEAT.TRANS.UNDERDRIVEN	level				basic	sub.of				phys.process	instance.of			process.rule	my.creator			jp2	if.actors			( ( heat.source ( *heat.source ) true )							( heat.sink ( *heat.sink ) true )							( source.temp.sensor ( *t1 ) true )							( sink.temp.sensor ( *t2 ) true ) )	if.relates			( ( abuts ( *heat.sink *heat.source ) true ) )	if.states			( ( greater.than ( *t1 *t2 ) true ) )	then.states			( ( decreasing ( *t2 ) false )							( increasing ( *t2 ) true )							( decreasing ( *t1 ) true )							( increasing ( *t1 ) false )							( active ( *heat.source ) true ) )\ with additional heat input, just enough\ =============================={	CONDUCT.HEAT.TRANS.DRIVEN	description:		x	example input:		x	example output:	x	notes:				x}c:	CONDUCT.HEAT.TRANS.DRIVEN	level				basic	sub.of				phys.process	instance.of			process.rule	my.creator			jp2	if.actors			( ( heat.source ( *heat.source ) true )							( heat.sink ( *heat.sink ) true )							( source.temp.sensor ( *t1 ) true )							( sink.temp.sensor ( *t2 ) true ) )	if.relates			( ( abuts ( *heat.sink *heat.source ) true ) )	if.states			( ( greater.than ( *t1 *t2 ) true ) )	then.states			( ( decreasing ( *t2 ) false )							( increasing ( *t2 ) true )							( decreasing ( *t1 ) false )							( increasing ( *t1 ) false )							( active ( *heat.source ) true ) )\ with additional heat input, over enough\ =============================={	CONDUCT.HEAT.TRANS.OVERDRIVEN	description:		x	example input:		x	example output:	x	notes:				x}c:	CONDUCT.HEAT.TRANS.OVERDRIVEN	level				basic	sub.of				phys.process	instance.of			process.rule	my.creator			jp2	if.actors			( ( heat.source ( *heat.source ) true )							( heat.sink ( *heat.sink ) true )							( source.temp.sensor ( *t1 ) true )							( sink.temp.sensor ( *t2 ) true ) )	if.relates			( ( abuts ( *heat.sink *heat.source ) true ) )	if.states			( ( greater.than ( *t1 *t2 ) true ) )	then.states			( ( decreasing ( *t2 ) false )							( increasing ( *t2 ) true )							( decreasing ( *t1 ) false )							( increasing ( *t1 ) true )							( active ( *heat.source ) true ) )\ =============================={	EXOTHERM.REACTION.1	description:		x	example input:		x	example output:	x	notes:				x}c:	EXOTHERM.REACTION.1	level				basic	sub.of				phys.process chem.process	instance.of			process.rule	spec.of				exotherm.reaction	my.creator			jp2	if.actors			( ( heat.source ( *heat.source ) true )							( heat.sink ( *heat.sink ) true )							( gas ( *convective.medium ) true )							( heat.sink.sensor ( *t2 ) true )							( heat.source.sensor ( *t1 ) true ) )	if.relates			( ( abuts ( *heat.sink *convective.medium ) true )							( abuts ( *heat.source *convective.medium ) true ) )	if.states			( ( reactive ( *heat.sink ) true )							( polymer ( *heat.sink ) true )							( increasing ( *t2 ) true ) )	IF.NOT.STATES	( ( ACCELERATING ( *T2 ) TRUE ) )			\ DJW ADDED	if.to.do				( ( increase ( *t1 ) true ) )	then.states			( ( accelerating ( *t2 ) true ) )\ =============================={	EXOTHERM.REACTION.2	description:		x	example input:		x	example output:	x	notes:				x}c:	EXOTHERM.REACTION.2	level				basic	sub.of				phys.process chem.process	instance.of			process.rule	spec.of				exotherm.reaction	my.creator			jp2	if.actors			( ( heat.source ( *heat.source ) true )							( heat.sink ( *heat.sink ) true )							( gas ( *convective.medium ) true )							( heat.sink.sensor ( *t2 ) true )							( heat.source.sensor ( *t1 ) true ) )	if.relates			( ( abuts ( *heat.sink *convective.medium ) true )							( abuts ( *heat.source *convective.medium ) true ) )	if.states			( ( reactive ( *heat.sink ) true )							( polymer ( *heat.sink ) true )							( accelerating ( *t2 ) true )							( increasing ( *t2 ) true ) )	if.to.do				( ( decrease ( *t1 ) true ) )	then.states			( ( accelerating ( *t2 ) false )							( reactive ( *heat.sink ) false ) )\ reference to "burnt" should be built and used in "common sense" rules for domain\	a mere exotherm with continued external energy input does not imply "burnt" for\	all materials\ =============================={	EXOTHERM.REACTION.3	description:		x	example input:		x	example output:	x	notes:				x}c:	EXOTHERM.REACTION.3	level				basic	sub.of				phys.process chem.process	instance.of			process.rule	spec.of				exotherm.reaction	my.creator			jp2	if.actors			( ( heat.source ( *heat.source ) true )							( heat.sink ( *heat.sink ) true )							( gas ( *convective.medium ) true )							( heat.sink.sensor ( *t2 ) true )							( heat.source.sensor ( *t1 ) true ) )	if.relates			( ( abuts ( *heat.sink *convective.medium ) true )							( abuts ( *heat.source *convective.medium ) true ) )	if.states			( ( reactive ( *heat.sink ) true )							( polymer ( *heat.sink ) true )							( accelerating ( *t2 ) true )							( increasing ( *t2 ) true ) )	if.to.do				( ( increase ( *t1 ) true ) )	then.states			( ( reactive ( *heat.sink ) false )							( burnt ( *heat.sink ) true ) )\ =============================={	EXOTHERM.REACTION.4	description:		x	example input:		x	example output:	x	notes:				x}c:	EXOTHERM.REACTION.4	level				basic	sub.of				phys.process chem.process	instance.of			process.rule	spec.of				exotherm.reaction	my.creator			jp2	if.actors			( ( heat.source ( *heat.source ) true )							( heat.sink ( *heat.sink ) true )							( gas ( *convective.medium ) true )							( heat.sink.sensor ( *t2 ) true )							( heat.source.sensor ( *t1 ) true ) )	if.relates			( ( abuts ( *heat.sink *convective.medium ) true )							( abuts ( *heat.source *convective.medium ) true ) )	if.states			( ( reactive ( *heat.sink ) true )							( polymer ( *heat.sink ) true )							( accelerating ( *t2 ) true )							( increasing ( *t2 ) true ) )	if.to.do				( ( same ( *t1 ) true ) )	then.states			( ( accelerating ( *t2 ) true )							( reactive ( *heat.sink ) false )							( burnt ( *heat.sink ) true ) )