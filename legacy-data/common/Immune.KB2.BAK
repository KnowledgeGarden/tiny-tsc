{	IMMUNE.RBTdescription:		Xneed to do:		Xto improve:		X	PROBLEMS:		Xnotes:			Straighten out cytokine-cell interactions;  make sure cell activation				rules approrpiate; check runtime rule firing to insure that system is				operating properly/realistically!CHANGES:1/13/92			first draft1/16/92			additions2/22/92			began cleanup. NewCentury 12point, TabStops=4, LineWrap=100.				jp2: began trimming rules using new multi-fire QPT3/12/92			jp2: organize rules3/15/92			jp2: edit rules -- there's some bugs in here4/07/92			jp2: edit rules to new syntax5/29/92			jp2: edit rules -- one.group rule per major actor activity10/15/92			rbt: add rules for antibody, pathogens, stop on antibody production 				experiments with binding trimming10/18/92			rbt: various experiments, edit rules10/25/92			rbt: various experiments, edit rules through11/5/92			rbt: various experiments, edit rules12/18			rbt: thenSay and then.log added;  rules made verbose 1/11-13/93		rbt:  Looked for gremlins--made a lot of T- and b-cell rules					"one.group-shot":  Set initial conditions relations to false, and					only allowed rule to fire on relations false... e.g., b-cell					digests antigens.  Makes some biological sense, and should					cut down on branching!2/12/93			rbt:  eliminated useless proliferation rules; some minor changes2/22/93			jp2: patches to fix it2/24/93			jp2: patches to update to new TSC syntax3/02/93			jp2: no more false actors -- runs on TSC 0.2b123/18/93			dhf: added "instanceOf  ", other PopSim fixes				dhf: added comments about use with PopSim} \ _________________________________________________________ SUPPORT OBJECTSc:	thenSay	subOf		information.slot	instanceOf	rhs.func	i.take		sx	i.give		none.bond	arguments	*something	algorithm	( display> *something say )\ ______________________________________________________________________  RULEScomment:all rules below have been setup to work with "no false actors".  This routine in QPTwill take any actor which is "false" and delete it from the episode, then it goes and findsany relation or state referencing that actor, and deletes that too.Thus, we spend more time using thenCreate to bind up "new" variables so we canintroduce new actors and their relations/states at runtime, plus we make heavy useof the "if.not..." constructs to keep rules from multiple firings.comment;\ ____________________________________________________________ BINDING PROCESSEScomment:	the "no false actors" issue propagates to the rule below:	unless we have a sense.rule which creates abuttments, we need to just ignore	abuttments (read: assume they exist).  this because we cannot have the relation	in initial conditions because we cannot have the actors	we did one.group experiment in the metabolic pathways project with sense rules which	notice the presence of a pair of actors, and notice they don't abut, then make them abut	I'm.group not sure what that all means, or how it is different from the idea of just ignoring	abuttments altogether, as the example below does.comment;\ replacement antigen.binding, prevents multiple branches from arising as\ t- b-cell and macrophage rules fire separatelyc:	antigen.BINDING	level		basic	subOf		phys.process	instanceOf	process.rule  	myCreator	jp2	context		immunology	ifActors		( ( antigen ( *antigen ) true )				  ( b-cell ( *b-cell ) true )			 	  ( helper.t-cell ( *helper.t-cell ) true )			  	  ( macrophage ( *macrophage ) true ) )	ifNotRelates		( \ ( abuts ( *macrophage *antigen  ) true )	-- ignore				   \ ( abuts ( *b-cell *antigen ) true )					-- ignore				   ( binds ( *helper.t-cell *antigen ) true )				   ( binds ( *b-cell *antigen ) true )				   ( binds ( *macrophage *antigen ) true ) )	thenRelates	( ( binds ( *macrophage *antigen ) true )				  ( binds ( *helper.t-cell *antigen ) true ) 				  ( binds ( *b-cell *antigen ) true ) )	thenSay		" antigen bound to macrophage, b-cell, and helper t-cell. " comment:	this rule does a good job of making an abuttment, but there may be a problem...	we cannot do an ifRelates on something which does not exist	so we choose the ifNotRelates relationcomment;c:	activated.helper.t-cell.b-cell.ABUT.1	level		basic	subOf		phys.process	instanceOf	process.rule  	myCreator	jp2 rbt	context		immunology	ifActors		( ( b-cell ( *b-cell ) true )				 ( act.h.t-cell ( *act.h.t-cell ) true ) )	\ ifRelates	( ( abuts ( *b-cell *act.h.t-cell ) false ) )   \ jp2	ifNotRelates ( ( abuts ( *b-cell *act.h.t-cell ) true ) )	thenRelates 	( ( abuts ( *b-cell *act.h.t-cell ) true ) ) 	thenSay		" b-cell abuts activated helper t-cell. "\ I suspect this is wrong--I recall reading that the ht-cell gets activated when it antigen-binds\ to a macrophage or b-cell presenting hla and antigen partsc:	activated.helper.t-cell.antigen.b-cell.BINDING.1	level		basic	subOf		phys.process 	instanceOf	sense.rule  		\ jp2	myCreator	jp2 rbt	context		immunology	ifActors		( ( b-cell ( *b-cell ) true )				  ( antigen ( *antigen ) true )	\ jp2 missing actor				 ( act.h.t-cell ( *act.h.t-cell ) true ) )	ifRelates		(  ( presents ( *b-cell *antigen ) true )				  ( abuts ( *b-cell *act.h.t-cell ) true ) )\	ifNotRelates  ( ( antigen.BINDS ( *act.h.t-cell *b-cell ) false ) ) 	ifNotRelates  ( ( antigen.BINDS ( *act.h.t-cell *b-cell ) true ) )	\ dhf	thenRelates 	( ( antigen.BINDS ( *act.h.t-cell *b-cell ) true ) )\	thenActors	( ( B.AB.t-cell ( *b-cell ) true ) )			\ jp2	thenSay		" Activated helper t-cell binds b-cell bound antigen."	\ ____________________________________________________________ TRANSPORT PROCESSES\ made these rules one.group-shot by testing for false relation on primary output relation\ rbt 1/11/93\ modified to use the ifNotRelates method--jp2 3/02/93c:	antigen.INTErnaLIZATION.B	level		basic	subOf		phys.process	instanceOf	process.rule  	myCreator	rbt 	context		immunology	ifActors		( ( antigen ( *antigen ) true )			 	 ( b-cell ( *b-cell ) true ) )	ifRelates		( ( binds ( *b-cell *antigen ) true ) )	ifNotRelates	( ( contains ( *b-cell *antigen ) true ) ) 	thenRelates	( ( contains ( *b-cell *antigen ) true ) )	thenSay		" b-cell ingests bound antigen. "c:	antigen.INTErnaLIZATION.m.group	level		basic	subOf		phys.process	instanceOf	process.rule  	myCreator	rbt 	context		immunology	ifActors		( ( antigen ( *antigen ) true )			 	 ( macrophage ( *macrophage ) true ) )	ifRelates		( ( binds ( *macrophage *antigen ) true ) )	ifNotRelates	( ( contains ( *macrophage *antigen ) true ) )	thenRelates 	( ( contains ( *macrophage *antigen ) true ) )	thenSay		" Macrophage ingests bound antigen. "	c:	antigen.PRESENTATION.B	level		basic	subOf		phys.process	instanceOf	process.rule  	myCreator	rbt	context		immunology	ifActors		( ( b-cell ( *b-cell ) true )				   ( antigen ( *antigen ) true ) )	ifRelates		( ( digests ( *b-cell *antigen ) true ) )	ifNotRelates	( ( presents ( *b-cell *antigen ) true ) )	thenRelates 	( ( presents ( *b-cell *antigen ) true ) ) 	thenSay		" b-cell presents processed antigen. "c:	antigen.PRESENTATION.m.group	level		basic	subOf		phys.process	instanceOf	process.rule  	myCreator	rbt	context		immunology	ifActors		( ( Macrophage ( *macrophage ) true )				   ( antigen ( *antigen ) true ) )	ifRelates		( ( digests ( *macrophage *antigen ) true ) )	ifNotRelates	( ( presents ( *macrophage *antigen ) true ) )	thenRelates 	( ( presents ( *macrophage *antigen ) true ) ) 	thenSay		" Macrophage presents processed antigen. "\ ____________________________________________________________ METABOLIC PROCESSEScomment:	There are two.group semantics associated with "secretes"  for PopSim translation.    The 	translation for the relation "secretes (*macrophage *csf)" creates a feature named	"secretes.csf".  A "thenRelates" message will assign this feature to the macrophage actor.	An "ifRelates" message will test for previous assignment of the feature.  In addition the	"thenRelates" message will create a PopSim instruction to increase the level of csf as a 	background chemical.comment;c:	antigen.PROCESSING.m.group	level		basic	subOf		phys.process	instanceOf	process.rule  	myCreator	rbt	context		immunology	ifActors		( ( antigen ( *antigen ) true )				\  ( IL-1 ( *IL-1 ) false )			-- no more "false" actors				\  ( gm-csf ( *csf ) false )				  ( Macrophage ( *macrophage ) true ) )	ifRelates		( ( contains ( *macrophage *antigen ) true ) )	ifNotRelates	( ( digests ( *macrophage *antigen ) true ) )	thenCreate	( *il-1 *csf )			\ get ready to make new actors	thenActors	( ( IL-1 ( *IL-1 ) true )				 ( gm-csf ( *csf ) true ) )				 	thenRelates 	(  ( digests ( *macrophage *antigen ) true )				  ( secretes ( *macrophage *IL-1 ) true ) 			 	  ( secretes ( *macrophage *csf ) true ) )	thenSay		" Macrophage secretes IL-1 and CSF. "c:	antigen.PROCESSING.B	level		basic	subOf		phys.process	instanceOf	process.rule  	myCreator	rbt	context		immunology	ifActors		( ( b-cell ( *b-cell ) true )				   ( antigen ( *antigen ) true ) )	ifRelates		( ( contains ( *b-cell *antigen ) true ) )	ifNotRelates	( ( digests ( *b-cell *antigen ) true ) )	\ make this rule one.group-shot	thenRelates 	( ( digests ( *b-cell *antigen ) true ) ) 	thenSay		" b-cell digests antigen. "	\ what about proliferation???  what does PROLIFERATES mean?c:	helper.t-cell.ACTIVATION.1	level		basic	subOf		phys.process	instanceOf	sense.rule   	myCreator	jp2 rbt	context		immunology	ifActors		( ( antigen ( *antigen ) true )			  	 ( helper.t-cell ( *helper.t-cell ) true )				\ ( act.h.t-cell ( *act.h.t-cell ) false )	-- no "false" actors				 ( IL-1 ( *IL-1 ) true ) )	ifRelates		( ( binds ( *helper.t-cell *antigen ) true ) )	ifNotActors	( ( act.h.t-cell ( *act.h.t-cell ) true ) )	thenCreate	( *act.h.t-cell )	thenRelates 	( ( proliferates ( *helper.t-cell ) true ) )		thenActors	( ( act.h.t-cell ( *act.h.t-cell ) true ) )	thenSay		" *Helper t-cell activated. "		   	c:	b-cell.ACTIVATION.1	level		basic	subOf		phys.process	instanceOf	sense.rule  			\ NOTE new syntax here	myCreator	jp2 rbt	context		immunology	ifActors		( ( b-cell ( *b-cell ) true )				  ( act.h.t-cell ( *act.h.t-cell ) true ) )	ifRelates		( ( antigen.BINDS ( *act.h.t-cell *b-cell ) true ) )	ifNotActors	( ( activated.b-cell ( *b-cell ) true ) )	thenActors	( ( activated.b-cell ( *b-cell ) true ) )			thenSay		" b-cell activated. "	   c:	b-cell.CYTOKINE.RECEPTOR.PRODUCTION.1	level		basic	subOf		phys.process	instanceOf	process.rule  	myCreator	jp2 rbt	context		immunology	ifActors		( ( activated.b-cell ( *b-cell ) true )				 \ ( cytokine.receptor  ( *cytokine.receptor ) false )  -- no "false" actors				  ( IL-1 ( *IL-1 ) true ) )	ifNotActors	( ( cytokine.receptor  ( *cytokine.receptor ) true ) )	\ prevent refiring	thenCreate	( *cytokine.receptor )	thenActors	( ( cytokine.receptor  ( *cytokine.receptor ) true ) )			thenRelates	( ( synthesizes ( *b-cell *cytokine.receptor ) true ) 			 	  ( attaches.to (  *IL-1 *cytokine.receptor ) true ) )	thenSay		" b-cell synthesizes cytokine receptor, and IL-1 attaches to receptor. "	   \ ATTACHES.TO  & BINDS seem to be very similar usage here--compare to SRL's LINKS\	ATTACHES.TO should probably be ATTACHED.TO\ ____________________________________________________________ PROLIFERATION PROCESSESc:	blast.cell.PRODUCTION.1	level		basic	subOf		phys.process	instanceOf	sense.rule  	myCreator	jp2 rbt	context		immunology	ifActors		( ( activated.b-cell ( *b-cell ) true )				   ( IL-1 ( *IL-1) true )				   ( cytokine.receptor ( *cytokine.receptor ) true ) 				   \  ( blast.cell ( *blast.cell ) false ) 				    )	ifRelates		( ( synthesizes ( *b-cell *cytokine.receptor ) true ) 			  	 ( attaches.to ( *IL-1 *cytokine.receptor ) true ) )	ifNotActors	( ( blast.cell ( *blast.cell ) true ) )	thenCreate	( *blast.cell )	thenActors	( ( blast.cell ( *blast.cell ) true ) )	thenSay		" Blast cell produced. "	c:	PLASMA.MEMORY.cell.PRODUCTION.1	level		basic	subOf		phys.process	instanceOf	process.rule  	myCreator	jp2 rbt	context		immunology	ifActors		( (  blast.cell ( *blast.cell ) true ) 				   ( IL-1 ( *IL-1 ) true )				  \ ( plasma.cell ( *plasma.cell ) false )			   	   \ ( memory.cell ( *memory.cell ) false )			   	   )	ifNotActors	( ( plasma.cell ( *plasma.cell ) true )			   		  ( memory.cell ( *memory.cell ) true ) )	thenCreate	( *plasma.cell *memory.cell )	thenActors	( ( plasma.cell ( *plasma.cell ) true )				  ( memory.cell ( *memory.cell ) true ) )	thenSay		" Plasma cell produced.  Memory cell produced. "			   	  		\ __________________________________________________ANTIBODY PRODUCTIONc:	antibody.PRODUCTION.1	level		basic	subOf		phys.process	instanceOf	sense.rule  	myCreator	rbt	context		immunology	ifActors		( ( IL-1 ( *IL-1 ) true )			   	( cytokine.receptor ( *cytokine.receptor ) true )			   	( plasma.cell ( *plasma.cell ) true ) )	ifRelates		( ( attaches.to ( *IL-1 *cytokine.receptor ) true ) )	ifNotActors	( ( antibody ( *antibody ) true ) )	thenCreate	( *antibody )	thenActors	( ( antibody ( *antibody ) true ) )	thenSay		" Plasma cell produces antibody. "			    \ ___________________________________________________INFECTIOUS AGENT PROCESSEScomment:	this rule has a problem with the "no false actors" syntax rule:		without antigen as actor, you cannot use the "excretes" relation here to limit firing	that is: we need some sort of unary relation for virus which will get changed on firing	I choose--for purposes of trials--"excited"	note that this has been added to initial conditions as well	second cut: i choose ifNotActors, and deleted "excited" from IC	No special semantics are associated with "excretes" for PopSim translation.  The default	translation for the relation "excretes (*virus *antigen)" is to create a feature named	"excretes.antigen".  A "thenRelates" message will assign this feature to the virus actor.	An "ifRelates" message will test for previous assignment of the feature. 	The actual production of a new antigen actor is accomplished by the combination of 	"thenCreate ( *antigen )" and "thenActors ( ( antigen ( *antigen ) true ) )".comment;c:	bacterium.capsule.antigen.PRODUCTION	level			basic	subOf		phys.process	instanceOf	process.rule  	myCreator	rbt	context		immunology	ifActors		(  (  bacterium.capsule ( *bacterium.capsule  )  true  ) ) 				  \  ( antigen ( *antigen ) false )  	ifNotActors	( ( antigen ( *antigen ) true ) )	thenCreate	( *antigen )	thenActors	( ( antigen ( *antigen ) true ) )	thenRelates	( ( excretes ( *bacterium.capsule *antigen ) true ) )						thenSay		" bacterium.capsule excretes antigen "		\ _________________________________________ANTIBODY-PATHOGEN BINDING PROCESSES	\ next rule does not adress the fact that antigen is related--bound--to virusc:	antibody.bacterium.capsule.antigen.BINDING.1	level		basic	subOf		phys.process	instanceOf	sense.rule  	myCreator	jp2 rbt	context		immunology	ifActors		( ( antibody ( *antibody ) true )				 (  bacterium.capsule ( *bacterium.capsule ) true ) )	ifNotRelates ( ( binds ( *antibody *bacterium.capsule ) true ) )		thenRelates	( ( binds ( *antibody *bacterium.capsule ) true ) )	thenSay		" antibody binds to bacterium.capsule. "	\ ____________________________________________________________ STOPPING RULEScomment:you can write stopping rules to halt construction of the envisionmentthis is a model of such a type of rulesome stopping rules are used when a branch of the tree is known to be unproductiveothers simply stop when some goal state is reachedcomment;\ stop when antibody binds antigen rbt--1015{c:	VIRAL.INGESTION.STOP.1	level		basic	subOf		phys.process	instanceOf	sense.rule  	\ dropped sense.rule until QPT code patched	myCreator	rbt	context		immunology	ifActors		( ( antibody ( *antibody ) true )				 ( virus ( *virus ) true )				 ( macrophage ( *macrophage ) true ) )	ifRelates		( ( binds ( *antibody *virus )  true ) )	ifNotRelates	( ( ingests ( *macrophage *virus ) true ) )	thenActors	( ( virus ( *virus ) false ) )	\ jp2--will be killed by QPT **	thenRelates	( ( ingests ( *macrophage *virus ) true)				  )			 	then.terminate	expansion	thenSay		" ***Macrophage ingests antibody-bound virus. "	}\ ** actually, it won't be killed by QPT because the branch is terminated