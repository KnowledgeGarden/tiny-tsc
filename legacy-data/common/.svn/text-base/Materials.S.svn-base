(	Materials.S	support functions, etc		950419	jp2:	first cut, removed from Materials.T	}\ ==============================================INFERENCE SUPPORT{ ======================	BOND.TYPE		inputs	pair of elements	outputs	bond.type or UNKNOWN	========================= }{  commented out for now until we better understand this conceptc:	IS .EITHER?			\ this will need testing	instanceOf	flow.pred	i.take		sx sx symbol	i.give		flag	arguments	*elem1 *elem2 *it	my.vars		*truth *defn	algorithm	( do	( bindq *defn ( value.of *it 'definition ) )						\ note: only one.group definition allowed						\ no error checking if definition is missing						( cond	( ( eval *defn *elem1 )								  ( bindq *truth T ) )								( ( eval *defn *elem2 )								  ( bindq *truth T ) )								( T ( bindq *truth F ) ) ) 						( return *truth ) )c:	IS.IT?	instanceOf	flow.pred	i.take		symbol sx sx	i.give		flag	arguments	*bond *elem1 *elem2	my.vars		*truth *req	algorithm	( do			( bindq *truth F )		( bindq *req ( value.of *bond 'requires.pair ) )		( loop.until	( null? *req ) 			( do	( if.true ( is.either? 									*elem1 *elem2 ( first ( first *req ) ) )							( if.true ( is.either? 									*elem1 *elem2 ( second ( first *req ) ) )									( do	( bindq *truth T ) 											( bindq *req null )  \ kill list											) ) )					( bindq *req ( rest *req ) ) ) )  \ next requires		( return *truth ) )	c:	IS.IONIC?	instanceOf	flow.pred	i.take		sx sx	i.give		flag	arguments	*elem1 *elem2	my.vars		*truth	algorithm	( is.it? 'ionic.bond *elem1 *elem2 )c:	IS.COVALENT?	instanceOf	flow.pred	i.take		sx sx	i.give		flag	arguments	*elem1 *elem2	my.vars		*truth	algorithm	( is.it? 'covalent.bond *elem1 *elem2 )	c:	IS.METALLIC?	instanceOf	flow.pred	i.take		sx sx	i.give		flag	arguments	*elem1 *elem2	my.vars		*truth	algorithm	( is.it? 'metallic.bond *elem1 *elem2 )	c:	BOND.TYPE	instanceOf	flow.func	i.take		sx sx	i.give		symbol	arguments	*elem1 *elem2	my.vars		*val	Algorithm	( do	( cond	( ( is.ionic? *elem1 *elem2 )								  ( bindq *val 'ionic.bond ) )								( ( is.metallic? *elem1 *elem2 )								  ( bindq *val 'metallic.bond ) )								( ( is.covalent? *elem1 *elem2 )								  ( bindq *val 'covalent.bond ) )								\ more can be inserted here								( T ( bindq *val 'unknown ) ) )						( return *val ) )						This test will fail with unknown if the inputs are not elements.We need a way to ask the same type of question given compounds, crystals, etc.}