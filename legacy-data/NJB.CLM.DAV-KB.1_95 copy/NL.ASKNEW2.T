 c:		IS.REL.TO		instance.of             flow.func		i.take                  symbol symbol  sx	\ symbol symbol		i.give                  none		arguments                *art *noun  *memb		\ *cop *reln		algorithm   ( do   ( display> "is rel to" debug )							( cond  	( ( notnull? *art )									  ( do 	( edisplay *art ) 									  		( edisplay *noun ) ) )									( T ( edisplay *noun ) ) )							( display " is related to " )							( loop.until	( null? *memb )								( do	 ( edisplay *memb )										( bindq *memb ( rest *memb ) ) ) ) ) c:		WHAT.REL.TO		instance.of             flow.func		i.take                  symbol symbol		i.give                  none		arguments               *art *noun		my.vars        			*memb		algorithm               ( do    ( display> "what rel to" debug )								( bindq *memb ( get *noun 'sub.of ) )								( bindq *memb ( list.difference ( list *noun ) *memb ) )	\ delete me								( cond  ( ( notnull? *memb )										  ( is.rel.to *art *noun  *memb ) ) \ *cop *reln										( T ( dont.know ) ) ) )COMMENT:										c:		SYNONYM.SLOT?		instance.of	                flow.pred		i.take		                symbol symbol		i.give		                 flag		arguments	                *val *con		my.vars						*v.syns *c.syns *truth *trial *concopy *slot		algorithm	                ( do			( display> "synonym slot" debug )			( *val = ( eval *val ) )			( display *val debug ) ( display *con debug ) ( display *slot debug )			( if.true ( variable? *val )						return F )			( bindq *v.syns ( grab.syns *val ) )			( bindq *v.syns ( cons *val *v.syns ) )			( bindq *c.syns ( grab.syns *con ) )			( bindq *c.syns ( cons *con *c.syns ) )			( bindq *truth F )			( loop.until    ( or? ( null? *v.syns ) *truth )				( do		( bindq *slot ( first *v.syns ) )					( bindq *concopy *c.syns )					( bindq *v.syns ( rest *v.syns ) )					( loop.until    ( or? ( null? *slot )										( or? *truth												( null? *concopy) )	) \ for all concepts						( do    ( bindq*trial ( get  ( first *concopy ) *slot ) )				    			( bindq *concopy ( rest *concopy ) )								( if.true      	 ( notnull? *trial )									( do		( bindq *truth T )												( bindq *v.syns null) ) ) ) ) ) )			( return *truth ) )COMMENt;\ c:		DOESA?.3x\		instance.of	parse.rule\		sub.of	parse.process\		lhs	    ( and?  ( match.phrase? '( DOES ( article? *art1 ) ( ? *xx ) ( ? *yy ) ) )\						( synonym.slot? *yy *xx ) )\		rhs	    ( yup )\		attach.to	questionsc:		DOESA?.4x		instance.of	parse.rule		sub.of	parse.process		lhs	     ( and?  ( match.phrase? '( DOES ( article? *art1 ) ( ? *xx )											( ? *yy ) ( article? *art2 ) ( ? *zz ) ) )						( synonym.member? *zz *xx *yy ) )		rhs		( yup )		attach.to	questionsc:		WHAT.14Ax		instance.of	parse.rule		sub.of	parse.process		lhs     ( match.phrase? '( WHAT IS ( article? *art1 ) ( ? *noun ) RELATED TO ) )		rhs		( what.rel.to *art1 *noun )		attach.to	questions