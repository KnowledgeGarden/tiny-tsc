{	RX-INDEXdescription:	Index Buildingneed to do:	xto improve:	XPROBLEMS:	Xnotes:		xCHANGES:2/11/93		first cut. NewCentury 12point, TabStops=4, LineWrap=100.2/26/93		jp2: updates to RX.BIG format}\ --------------------------------------------------------------------------------------------------------------INDEX BUILDING\ will need data checking: here we assume everything is reals and sanitary\ =============================={	BUILD.INDEX.TIMES	description:			given two datafiles build a new index	example input:		tides.01 sunspots.01	example output:		a new frame	notes:				will need lags			assumes "starting" values for both data are for the same time (e.g. year, etc)			might want to add some weighting for *a and for *b}c:	BUILD.INDEX.TIMES	instance.of	flow.func	i.take		symbol symbol	i.give		none	arguments	*a *b 	my.vars		*con *adat *bdat *xdat *newdat	algorithm	( do	( bindq *con ( new.atom ) )						( set.value  *experiment 'DATA.SOURCE								( cons *con ( value.of  *experiment 'DATA.SOURCE ) ) )	\ add to data.source list						( set.value *con 'INSTANCE.OF 'INDEX )						( set.value *con 'MY.VALS ( list *a *b ) )						( set.value *con 'MY.ALG 'TIMES )						( bindq *adat ( value.of *a 'MY.DATA ) )						( bindq *bdat ( value.of *b 'MY.DATA ) )						( bindq *newdat nil )						( bindq *xdat *adat )						( if.true	( less.than? ( length *bdat ) ( length *adat ) )								( bindq *xdat *bdat ) )	\ use shortest list						( loop.until	( null? *xdat )							( do	\ consider adding weighting here									( bindq *newdat 										( cons ( times ( first *adat ) ( first *bdat ) ) *newdat ) )									( bindq *xdat ( rest *xdat ) )									( bindq *adat ( rest *adat ) )									( bindq *bdat ( rest *bdat ) ) ) )						( set.value *con 'MY.DATA ( reverse *newdat ) ) )\ =============================={	BUILD.INDEX.QUOTIENT	description:			given two datafiles build a new index	example input:		tides.01 sunspots.01	example output:		a new frame	notes:				will need lags			assumes "starting" values for both data are for the same time (e.g. year, etc)			might want to add some weighting for *a and for *b}c:	BUILD.INDEX.QUOTIENT	instance.of	flow.func	i.take		symbol symbol	i.give		none	arguments	*a *b	my.vars		*con *adat *bdat *xdat *newdat	algorithm	( do	( bindq *con ( new.atom ) )						( set.value *experiment 'DATA.SOURCE 								( cons *con 									( value.of *experiment 'DATA.SOURCE ) ) )	\ add to data.source list						( set.value *con 'INSTANCE.OF 'INDEX )						( set.value *con 'MY.VALS ( list *a *b ) )						( set.value *con 'MY.ALG 'QUOTIENT )						( bindq *adat ( value.of *a 'MY.DATA ) )						( bindq *bdat ( value.of *b 'MY.DATA ) )						( bindq *newdat nil )						( bindq *xdat *adat )						( if.true	( less.than? ( length *bdat ) ( length *adat ) )								( bindq *xdat *bdat ) )	\ use shortest list						( loop.until	( null? *xdat )							( do	\ consider adding weighting here									( bindq *newdat 										( cons ( quotient ( first *adat ) ( first *bdat ) ) *newdat ) )									( bindq *xdat ( rest *xdat ) )									( bindq *adat ( rest *adat ) )									( bindq *bdat ( rest *bdat ) ) ) )						( set.value *con 'MY.DATA ( reverse *newdat ) ) )c:	BUILD.INDICES	instance.of	flow.func	i.take		none	i.give		none	my.vars		*a *b 	algorithm	( do	( display> "  BUILDING INDICES" print )					( bindq *a ( get *experiment 'INDEX.DATA ) )					( loop.until	( null? *a )			\ for every A						( do		( bindq *b ( rest *a ) )								( loop.until	( null? *b )	\ for every B which is not A									( do	( if.true	( not? ( dependent? ( first *a ) ( first *b ) ) )												( do  ( build.index.times ( first *a ) ( first *b ) )													( build.index.quotient ( first *a ) ( first *b ) ) ) )											( bindq *b ( rest *b ) ) ) )								( bindq *a ( rest *a ) ) ) ) )