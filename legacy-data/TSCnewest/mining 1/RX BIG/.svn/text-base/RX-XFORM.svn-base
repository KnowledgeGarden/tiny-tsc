{	RX-XFORMdescription:	basic Rough Sets Data Transformationneed to do:	ðstore transform values e.g. ( inc dec same ) in each frame			ðbin sort to categorical data raw numeric data			need to be able to lag index values wrt each other				e.g. tides lagged by 1 year / sunspots at no lagto improve:	XPROBLEMS:	Xnotes:		xCHANGES:2/11/93		first cut. NewCentury 12point, TabStops=4, LineWrap=100.2/26/93		jp2: updating to RX.BIG3/0193		jp2: minor patches to add transform values to each frame3/03/93		jp2: begin adding binsorts for numeric data}\ ------------------------------------------------------------------------------------------------------ BIN SORTINGcomment:	here we take a list of numeric data and divide it up into "n" bins	where "n" is a knob -- one knob for all numeric datacomment;\ =============================={	RANGE.DATA	description:			find max and min in a list	example input:			( 1 2 3 44.0 )	example output:		( 44.0 1.0 )	notes:				x}c:	RANGE.DATA	instance.of		math.func	i.take			list	i.give			list	arguments		*list	algorithm		( list ( list.max *list ) ( list.min *list ) )\ =============================={	BIN.DATA	description:			build a new concept from an old one with bins as data	example input:			econ.01	example output:		con_99	notes:				makes one more bin than "num.bins"}c:	BIN.DATA	instance.of		flow.func	i.take			symbol	i.give			symbol	arguments		*file	my.vars		*range	*dat *xform *con *eng *binsize *xlist *xct *min	algorithm		( do	( bindq *con ( new.atom ) )							( bindq *binsize ( value.of *experiment 'NUM.BINS ) )							( bindq *eng ( list bins *binsize ) )							( bindq *eng ( cons *file *eng ) )							( set.value *con 'ENGLISH *eng )							( bindq *xlist nil )							( bindq *xct *binsize )							( loop.until	( less.than? *xct 0 )								( do	( bindq *xlist ( cons *xct *xlist ) )										( bindq *xct ( sub1 *xct ) ) ) )							( set.value *con 'XFORM.VALS *xlist )							( bindq *dat ( value.of *file 'MY.DATA ) )							( bindq *range ( range.data *dat ) )							( set.value *con 'DATA.RANGE *range )							( bindq *min ( second *range ) )							( bindq *binsize ( quotient											( minus ( first *range ) *min )											*binsize ) )							( set.value *con 'BIN.SIZE *binsize )							( bindq *xform nil )	\ start list of xforms							( loop.until	( null? *dat )								( do	( bindq *xform											( cons ( int ( quotient ( minus ( first *dat ) *min ) 															*binsize ) )													*xform ) )										( yield )										( bindq *dat ( rest *dat ) ) ) )							\ we take first two off list here since 2nd derivative takes two off							\ as does first derivative							( set.value *con 'MY.DATA  ( rest ( rest ( reverse *xform ) ) ) )							( return *con )							)\\ ------------------------------------------------------------------------------------------------------ 1ST DERIV\ =============================={	QUAL.XFORM.FILE.1	description:			transform the data to INC, DEC, SAME -- first derivative	example input:			TIDES.01	example output:		CON_23	notes:				zip along MY.DATA slot building MY.DATA slot in new concept						build an ENGLISH slot e.g. TIDES.01 1ST DERIV}c:	QUAL.XFORM.FILE.1	instance.of		flow.func	i.take			symbol	i.give			symbol	arguments		*file	my.vars			*dat *firstdat *xform *con *eng	algorithm		( do	( bindq *con ( new.atom ) )						( bindq *eng ( list 1st deriv ) )						( bindq *eng ( cons *file *eng ) )						( set.value *con 'ENGLISH *eng )						( set.value *con 'XFORM.VALS '( INC DEC SAME ) )						( bindq *dat ( value.of *file 'MY.DATA ) )						( bindq *firstdat ( first *dat ) )						( bindq *dat ( rest *dat ) )						( bindq *xform nil )	\ start list of xforms						( loop.until	( null? *dat )							( do		( cond	( ( equal? *firstdat ( first *dat ) )											  ( bindq *xform ( cons 'SAME *xform ) ) )											( ( greater.than? *firstdat ( first *dat ) )											  ( bindq *xform ( cons 'DEC *xform ) ) )											( T ( bindq *xform ( cons 'INC *xform ) ) ) )									( yield )									( bindq *firstdat ( first *dat ) )									( bindq *dat ( rest *dat ) ) ) )						( set.value *con 'MY.DATA ( rest ( reverse *xform ) ) )						\ we did REST since we know that the 2nd deriv will take 2 off front of list						\ so we take one more than the 1 1st deriv takes to align lists						( return *con )						)\ ------------------------------------------------------------------------------------------------------ 2ND DERIV\ =============================={	QUAL.XFORM.FILE.2	description:			transform the data to INC, DEC, SAME, MIX-- second derivative	example input:			TIDES.01	example output:		CON_13	notes:				zip along MY.DATA slot building MY.DATA slot of new concept						build an ENGLISH slot e.g. TIDES.01 2ND DERIV}c:	QUAL.XFORM.FILE.2	instance.of		flow.func	i.take			symbol	i.give			symbol	arguments		*file	my.vars			*dat *firstdat *seconddat *xform *con *eng	algorithm		( do	( bindq *con ( new.atom ) )						( bindq *eng ( list 2nd deriv ) )						( bindq *eng ( cons *file *eng ) )						( set.value *con 'ENGLISH *eng )						( set.value *con 'XFORM.VALS '( ACCEL DECEL SAME MIX ) )						( bindq *dat ( value.of *file 'MY.DATA ) )						( bindq *firstdat ( first *dat ) )						( bindq *dat ( rest *dat ) )						( bindq *seconddat ( first *dat ) )						( bindq *dat ( rest *dat ) )						( bindq *xform nil )	\ start list of xforms						( loop.until	( null? *dat )							( do	( cond	( ( and?	( equal? *firstdat *seconddat )													( equal? *seconddat ( first *dat ) ) )											  ( bindq *xform ( cons 'SAME *xform ) ) )											( ( and?	( less.than? *seconddat *firstdat )													( greater.than? *seconddat ( first *dat ) ) )											  ( bindq *xform ( cons 'DECEL *xform ) ) )											( ( and?	( greater.than? *seconddat *firstdat )													( less.than? *seconddat ( first *dat ) ) )											  ( bindq *xform ( cons 'ACCEL *xform ) ) )											( T ( bindq *xform ( cons 'MIX *xform ) ) ) )									( yield )									( bindq *firstdat *seconddat )									( bindq *seconddat ( first *dat ) )									( bindq *dat ( rest *dat ) ) ) )						( set.value *con 'MY.DATA ( reverse *xform ) )						( return *con ) )\ ------------------------------------------------------------------------------------------------------ LAG DATA\ =============================={	LAG.DATA	description:			zip along list of data files, making new lagged concepts	example input:			x	example output:		 ( con_23 con_22 ... )	notes:				x}c:	LAG.DATA	instance.of		flow.func	i.take			symbol number	i.give			symbol	arguments		*in *lagsize	my.vars			*con *eng *xrdy	algorithm		( do	( bindq *con ( new.atom ) )							( copy.p.list *in *con )							( bindq *eng ( value.of *con 'ENGLISH ) )							( bindq *eng ( cons *lagsize *eng ) )							( bindq *eng ( cons 'LAG *eng ) )							( set.value *con 'ENGLISH *eng )							( bindq *eng ( value.of *con 'MY.DATA ) )							( bindq *eng ( clip.list *eng *lagsize ) )							( set.value *con 'MY.DATA *eng )							( return *con ) )\ ------------------------------------------------------------------------------------------------------ QP XFORM\ =============================={	QUAL.XFORM.DATA	description:			for each data item (e.g. tides) transform the data to INC, DEC, SAME	example input:		list of databases	example output:		results left in DB frames in XFORM slots						returns a list of concepts	notes:				Stores new "concepts" in P.DATA}c:	QUAL.XFORM.DATA	instance.of		flow.func	i.take			list symbol symbol	i.give			list	arguments		*data.source *nn *exp	\ *nn is data item to be N set--1 value for now	my.vars			*file *ready *col *pset *nset *temp	algorithm		( do	( display> "TRANSFORMING " print ) ( display *data.source print )						( bindq *ready nil )	\ start list of new data sources						( bindq *col 0 )						( bindq *pset nil )						( bindq *nset nil )						( loop.until	( null? *data.source )	\ for every data file								( do	( yield )									( bindq *file ( first *data.source ) )									( display> "  Transforming " print ) ( display *file print )									( bindq *data.source ( rest *data.source ) )									( cond	( ( same? *file *nn )											  ( do	( bindq *temp														 ( qual.xform.file.1 *file ) )													( display " N " print ) ( display *col print )													( bindq *temp 														( lag.data *temp																( value.of *exp 'LAG.SIZE ) ) )													( bindq *nset ( cons *col *nset ) )													( set.value *temp 'MY.COL *col )													( bindq *ready ( cons *temp *ready ) )													( bindq *col ( add1 *col ) ) ) )											( T ( do	( display " P " print ) 													( if.true	( not? ( or? ( null? ( value.of *experiment 'NUM.BINS ) )																		( equal? 0 ( value.of *experiment 'NUM.BINS ) ) ) )														( do	( bindq *ready																	( cons ( bin.data *file ) *ready ) )																( bindq *pset ( cons *col *pset ) )																( display *col print )																( bindq *col ( add1 *col ) )																( set.value ( first *ready ) 'MY.COL *col ) ) )													( bindq *ready														( cons ( qual.xform.file.1 *file ) *ready ) )													( bindq *pset ( cons *col *pset ) )													( set.value ( first *ready ) 'MY.COL *col )													( display *col print )													( bindq *col ( add1 *col ) ) 													( bindq *ready														( cons ( qual.xform.file.2 *file ) *ready ) )													( display *col print )													( bindq *pset ( cons *col *pset ) )													( set.value ( first *ready ) 'MY.COL *col )													( bindq *col ( add1 *col ) ) ) ) )									) )						( set.value *exp 'NEXT.COL *col )						( set.value *exp 'P.SET *pset )						( set.value *exp 'N.SET *nset )						( return  *ready ) )\ =============================={	SHORTEST.DATA	description:			zip along list of data files, getting length of shortest file	example input:			x	example output:		x	notes:				x}c:	SHORTEST.DATA	instance.of		flow.func	i.take			list	i.give			number	arguments		*ready	my.vars			*len *x	algorithm		( do	( bindq *len ( length ( value.of ( first *ready ) 'MY.DATA ) ) )						( bindq *ready ( rest *ready ) )						( loop.until	( null? *ready )							( do		( bindq *x ( length ( value.of ( first *ready ) 'MY.DATA ) ) )									( if.true	( less.than? *x *len )											( bindq *len *x ) )									( bindq *ready ( rest *ready ) ) ) )						( return *len ) )									\ ------------------------------------------------------------------------------------------------------ SETUP DATA\ =============================={	PRE.PROCESS.DATA	description:			root around doing what's necessary on raw data to build working dataset	example input:			experiment frame	example output:		x	notes:				Stores new "concepts" in P.DATA}c:	PRE.PROCESS.DATA	instance.of		flow.func	i.take			symbol	i.give			none	arguments		*exp	my.vars			*data *ready *lag *len *nn *temp *pset *nextcol *nset *ncol	algorithm		( do	( bindq *data ( value.of *exp 'DATA.SOURCE ) )						( display> "  PRE.PROCESSING " print ) ( display *exp print )						( bindq *nn ( value.of *exp 'N.DATA ) )	\ one value for now						( bindq *ready ( qual.xform.data *data  *nn *exp ) )						\ now set universe size to shortest list						( bindq *len ( shortest.data *ready ) )						( set.value *exp 'U.SET *len )						( display> "SHORTEST UNIVERSE= " print ) ( display *len print )						( display> "SHORTEST UNIVERSE= " log ) ( display *len log )						( set.value *exp 'P.DATA ( reverse *ready ) )						( ^log ( show.node *exp ) ) )