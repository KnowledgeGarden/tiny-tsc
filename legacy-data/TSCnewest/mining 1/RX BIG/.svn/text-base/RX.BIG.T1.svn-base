{	RX.BIG.T1description:	integrated RX system--the Piatetsky-Shapiro Stuffneed to do:	xto improve:	XPROBLEMS:	Xnotes:		xCHANGES:2/26/93		first cut. NewCentury 12point, TabStops=4, LineWrap=100.3/03/93		jp2: update to 0.2b123/04/93		jp2: fixes}COMMENT:	For now, this will just take each column and correlate it against the "nset" column	Later by changing the "nset" column, it can compare all columns and build the treeCOMMENT;\ --------------------------------------------------------------------------------------------------------------DEPENDENCY TREE SUPPORTcomment:	for each pair X,Y of data fields (e.g. tides,econ)--must consider lags here		for each x.i			let x.a=x.i	(e.g. tides increasing)			collect all x.a tuples into a set			freq.i = card {x.a}					save for later			calculate probability that two Y values randomly selected are equal				for each y.i in x.a					count frequencies freq.i,j	save for later					calculate p(y.i) = freq.i,j/freq.i				for all y.i in x.a					calculate fdep(X=x.i,Y)					sum pe2(Y)=sum(i)(p(y.i)**2)			calculate fdep(X,Y)comment;\ =============================={	COUNT.Y	description:			collect all y.i which have same x.i same value	example input:		inc ( inc dec dec same ... )	example output:		13	notes:				gets the set of all yvals for given xval						return count of given yval}c:	COUNT.Y	instance.of		flow.func	i.take			sx list	i.give			number	arguments		*yval *ydat	my.vars			*count	algorithm	( do	( bindq *count 0 )					( loop.until	( null? *ydat )						( do		( if.true	( same? ( first *ydat ) *yval )										( bindq *count ( add1 *count ) ) )								( bindq *ydat ( rest *ydat ) ) ) )					\ ( display> "COUNT OF " print ) ( display *yval print ) ( display *count print )					( return *count ) )\ =============================={	COUNT.Y.ARRAY	description:			collect all y.i which have same x.i same value	example input:		inc econ.01 47	example output:		13	notes:				gets the set of all yvals for given xval						return count of given yval}c:	COUNT.Y.ARRAY	instance.of		flow.func	i.take			sx sx number	i.give			number	arguments		*yval *ydat *universe	my.vars			*count *col	algorithm	( do	( bindq *count 0 )					( bindq *col ( value.of *ydat 'MY.COL ) )					( loop.until	( equal? 0 *universe )						( do	( if.true	( same? ( array2@ *array *universe *col ) *yval )										( bindq *count ( add1 *count ) ) )								( bindq *universe ( minus *universe 1 ) ) ) )					\ ( display> "COUNT OF " print ) ( display *yval print ) ( display *count print )					( return *count ) )\ =============================={	COLLECT.X.I	description:			collect all y.i which have same x.i same value	example input:		inc 3 tides.01 econ.01	example output:		( dec dec inc same ... )	notes:				run along xdat looking for hits of xval						grab yval at that same location in ydat			THIS PRESUMES LISTS OF DATA ARE SAME LENGTH			must now deal with lags: clip lag count of items off head of xdat since xdat lags ydat			*universe is length of column}c:	COLLECT.X.I					\ works with arrays	instance.of		flow.func	i.take			sx sx sx number	i.give			list	arguments		*xval  *xdat *ydat *universe	my.vars			*rslt *ycol *xcol	algorithm	( do	( display> "COLLECTING ON " print ) ( display *xval print )					( bindq *rslt nil )	\ start list					( bindq *xcol ( value.of *xdat 'MY.COL ) )					( bindq *ycol ( value.of *ydat 'MY.COL ) )					\ ripple down xdat column--if it = xval, then grab value from ydat column					( loop.until	( equal? 0 *universe )						( do	( if.true	( same? ( array2@ *array *universe *xcol ) *xval )										( bindq *rslt ( cons ( array2@ *array *universe *ycol ) *rslt ) ) )								( bindq *universe ( sub1 *universe ) ) ) )					( bindq *rslt ( reverse *rslt ) )					\ ( display> "GOT " print ) ( display *rslt print )					( return *rslt ) )\ =============================={	CALC.PE2	description:			for each y.i, sum up probability that any 2 randomly selected values will be same	example input:		( inc dec same ) = list of values y.i can take						econ.01  = actual database list	example output:		0.05	notes:				ref: piatetsky-shapiro}c:	CALC.PE2	instance.of		flow.func	i.take			list symbol number	i.give			number	arguments		*vals *dat *universe	my.vars			*y.i *ct.y *pe2	algorithm	( do	( display> "    PE2 " print ) ( display *dat print ) 					( bindq *pe2 0.0 )					( if.true	( greater.than? *universe 0 )							( loop.until	( null? *vals )	\ for each y.i								( do	( bindq *y.i ( first *vals ) )									\ e.g. *y.i = inc									( bindq *vals ( rest *vals ) )									\ calc freq.i,j									( bindq *ct.y ( count.y.array *y.i *dat *universe ) )									\ update probability pe2									\ ( display> "UPDATING PE2 " print ) ( display *pe2 print )									( if.true	( greater.than? *ct.y  0 )											( bindq *pe2 												( plus *pe2													( sqr ( quotient ( float *ct.y ) 																( float *universe ) ) ) ) ) )									) )								)					( display *pe2 print )					( return *pe2 ) )\ =============================={	CALC.TAU	description:		calc goodman&kruskal tau	example input:		x	example output:	.1	notes:				ref: piatetsky-shapiro ml92}c:	CALC.TAU	instance.of		math.func	i.take			number number	i.give			number	arguments		*pdep *pdep1	algorithm		( quotient ( minus *pdep *pdep1 )							( minus 1.0 *pdep1 ) )\ =============================={	CALC.EXPECTED.PDEP	description:		x	example input:		x	example output:	.1	notes:				ref: piatetsky-shapiro ml92}c:	CALC.EXPECTED.PDEP	instance.of		math.func	i.take			number number number	i.give			number	arguments		*pdep1 *k *n	algorithm		( plus *pdep1							( times ( quotient ( minus *k 1.0 )											( minus *n 1.0 ) )									( minus 1.0 *pdep1 ) ) )\ =============================={	CALC.EXPECTED.TAU	description:		x	example input:		x	example output:	.1	notes:				ref: piatetsky-shapiro ml92}c:	CALC.EXPECTED.TAU	instance.of		math.func	i.take			number number	i.give			number	arguments		*k *n	algorithm		( quotient ( float ( minus *k 1 ) )							( float ( minus *n 1 ) ) )\ =============================={	CHECK.DEPENDENCY	description:			the inner routine: builds a dependency tree from a pair	example input:		econ.01 tides.02 46 0.4698	notes:				bigsum is the double sum for fdep(X,Y)					semantics: *y depends on *x						that is: *x values determine *y values by a certain dependency amount}c:	CHECK.DEPENDENCY	instance.of	flow.func	i.take		symbol symbol number number	i.give		sx	arguments	*y  *x  *universe *pe2	my.vars		*x.i  *xx *x.set *y.i *yy *ct.y  *bigsum *len.x *ratio *pdep 	algorithm	( do	( display> "    CHECKING " print ) ( display *y print ) ( display *x print )				( display> "PAIRS= " log ) ( display  *y  log ) ( display  *x log ) ( display "  " log )				( bindq *xx ( value.of *x 'XFORM.VALS ) )				( bindq *yy ( value.of *y 'XFORM.VALS ) )				( bindq *bigsum 0.0 )				( loop.until	( null? *xx )						\ for each x.i					( do	( yield )							( bindq *x.i ( first *xx ) )			\ e.g. *x.i = inc							( bindq *xx ( rest *xx ) )							( bindq *x.set 								( collect.x.i *x.i *x  *y  *universe ) )							\ freq.i = *len.x							( bindq *len.x ( length *x.set ) )							( display *len.x log )							( if.true ( greater.than? *len.x 0 )								( do ( loop.until	( null? *yy )			\ for each y.i										( do  ( bindq *y.i  ( first *yy ) )	\ e.g. *y.i = inc											( bindq *yy ( rest *yy ) )											\ calc freq.i,j											( bindq *ct.y ( count.y *y.i ( copy.list *x.set ) ) )											\ update fdep(X,Y)											( if.true	( greater.than? *ct.y 0 )													( bindq *bigsum														( plus *bigsum															( quotient ( sqr ( float *ct.y ) )																	( float *len.x ) ) ) ) )											) )									) )							) )				( bindq *pdep ( quotient *bigsum ( float *universe ) ) )				( bindq *ratio  ( quotient *pdep *pe2 ) )				( bindq *len.x nil )		\ reuse variable for output				\ now, deal with seeing if a linkage is justified between A and B				( if.true  (  greater.than? *ratio									( value.of  *experiment 'GO.THRESHOLD ) )					( do	\ this is a hot pair--log the results						( bindq *len.x *x )						( display> "PAIRS= " log ) ( display  *y  log ) ( display  *x log )						( display> " Y dep on X by FDEP(X,Y)= " log )						( display *pdep log )						( display> "  PE2= " log ) ( display *pe2 log )						( display> "  RATIO= " log )						( display  *ratio log )						) )				( display> " X dep Y by FDEP(X,Y)= " log )				( display *pdep log )				( display> " Expected PDEP= " log )				( display 					( calc.expected.pdep 						*pe2 ( length ( value.of *x 'XFORM.VALS ) ) *universe ) log )				( display> "  PE2= " log ) ( display *pe2 log )				( display> "  RATIO= " log ) ( display  *ratio log )				( display> "  TAU= " log ) ( display ( calc.tau *pdep *pe2 ) log )				( display> "   Expected TAU= " log )				( display 					( calc.expected.tau 						( length ( value.of *x 'XFORM.VALS ) ) *universe ) log )				( set.value *x 'FDEP *pdep )				( set.value *x 'PE2 *pe2 )				( set.value *x 'TAU ( calc.tau *pdep *pe2 ) )				( set.value *x 'DEP.RATIO *ratio )				( return *len.x )		\ return concept or nil				)\ =============================={	CALC.DEP.TREE	description:			the main routine: checks dependency both ways on a pairs of columns	example input:		list of columns, list of goal cols (one only for now), number of rows in array	example output:		results left in DB frames in LINKS.TO slots						returns list of cols on which the goal col depends	notes:				bigsum is the double sum for fdep(X,Y)		semantics:	A depends on B					or					B depends on A }c:	CALC.DEP.TREE	instance.of	flow.func	i.take		list list number	i.give		list	arguments	*pset *nset *universe	my.vars	*data *x *y *rslt *temp *yy *pe2y *xx *pe2x	algorithm	( 		do	( display> "CHECKING DEPENDENCIES" print )			( display> "######## CHECKING DEPENDENCIES" log )			( bindq *data ( value.of *experiment 'P.DATA ) )			( bindq *rslt nil )			\ VALUES must be stored in the frame for the column &&&&			\ now loop along the columns			( loop.until	( null? *nset )				\ for every array column in "nset"				( do	( bindq *y ( nth *data ( first *nset ) ) )						( bindq *nset ( rest *nset ) )						( bindq *yy ( value.of *y 'XFORM.VALS ) )						( bindq *pe2y ( calc.pe2 *yy  *y *universe ) )						( loop.until	( null? *pset )	\ for every array column in "pset"							( do	( yield )									( bindq *x ( nth *data ( first *pset ) ) )									\	( bindq *xx ( value.of *x 'XFORM.VALS ) )									\	( bindq *pe2x ( calc.pe2 *xx  *x *universe ) )									( bindq *temp 										( check.dependency *y *x  *universe *pe2y ) )	\ ncol dep pcol									\ ( bindq *temp 									\	( check.dependency *x *y  *universe *pe2x ) )	\ pcol dep ncol									( if.true	( notnull? *temp )											( bindq *rslt ( cons *temp *rslt ) ) )									( bindq *pset ( rest *pset ) ) ) )						) )			( return *rslt ) )