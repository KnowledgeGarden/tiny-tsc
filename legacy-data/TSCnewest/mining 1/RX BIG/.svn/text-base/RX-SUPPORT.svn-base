{	RX-SUPPORTdescription:	basic RX support toolsneed to do:	xto improve:	XPROBLEMS:	Xnotes:		xCHANGES:2/11/93		first cut. NewCentury 12point, TabStops=4, LineWrap=100.}c:	CONVERT.TO.COLS	instance.of		flow.func	i.take			list			\ list of concepts e.g. ( con_2 con_7 ... )	i.give			list			\ list of col numbers e.g. ( 2 5 9 ... )	arguments		*in	my.vars		*out	algorithm		( do	( bindq *out nil )							( loop.until	( null? *in )								( do	( bindq *out											( cons ( value.of ( first *in ) 'MY.COL ) *out ) )										( bindq *in ( rest *in ) ) ) )							( return *out ) )c:	CONVERT.TO.CONS	instance.of		flow.func	i.take			list			\ list of col numbers e.g. ( 2 5 9 ... )	i.give			list			\ list of concepts e.g. ( con_2 con_7 ... )	arguments		*in	my.vars		*out	algorithm		( do	( bindq *out nil )							( loop.until	( null? *in )								( do	( bindq *out											( cons ( array2@ *array 0 ( first *in ) ) *out ) )										( bindq *in ( rest *in ) ) ) )							( return *out ) ){	ALMOST.EQUAL?	description:		checks to see if two numbers are within some distance of each other	example input:		2.5 2.6 .15	example output:	T	notes:				}c:	ALMOST.EQUAL?	sub.of			predicate	i.take			number number number	i.give			flag	arguments		*num1 *num2 *error	algorithm		( between? *num2 ( minus *num1 *error ) ( plus *num1 *error ) )\ =============================={	SORT.COLS.ON.WORTH	description:		sort to decending worth-- "bubble sort"	example input:		list of concepts	example output:	sorted list of concepts	notes:				made from SORT.ON.WORTH}c:	GET.COL.WORTH	instance.of	flow.func	i.take		number symbol	i.give		number	arguments	*col *array	algorithm	( value.of ( array2@ *array 0 *col  ) 'WORTH )c:	SORT.COLS.ON.WORTH					\ seems to work	instance.of	flow.func	i.take		list		\ list is a list of column numbers	i.give		list	arguments	*list 	my.vars		*templist  *moved	algorithm	(		do	( bindq *templist nil )			( bindq *moved T )			( loop.until	( not? *moved )				( do	( bindq *moved F )						( loop.until	( null? *list )							  ( do	\ ( display> *list debug ) ( display> "##" debug ) ( display *templist debug )									( cond	( ( equal? ( length *list ) 1 )											  ( do	( bindq *templist ( cons ( first *list ) *templist ) )													( bindq *list ( rest *list ) ) ) )											( ( greater.than?													( get.col.worth ( second *list ) *array )													( get.col.worth ( first *list ) *array ) )											   ( do	( bindq *templist ( cons ( second *list ) *templist ) )													( bindq *list ( cons ( first *list ) ( rest ( rest *list ) ) ) )													( bindq *moved T ) ) )											( T ( do	( bindq *templist ( cons ( first *list ) *templist ) )														( bindq *list ( rest *list ) ) ) ) ) ) )						( bindq *list ( reverse *templist ) )						\ ( display> *list debug )						( bindq *templist nil ) ) )				( return *list )				\ ( display> "sort.on.worth >>" debug ) ( display *list debug )				)