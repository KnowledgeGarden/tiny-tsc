{	RX.COMMON.Tdescription:		common code for all versions of RXneed to do:		xto improve:		XPROBLEMS:		Xnotes:			xCHANGES:2/03/93				first cut. NewCentury 12point, TabStops=4, LineWrap=100.2/05/93			jp2: added data summary routines (from grits)2/09/93		jp2: update to dependent?}\ --------------------------------------------------------------------------------------------------------------TSC EXTENSIONS\ =============================={	MEASURE.OF>	description:			fetch measure.of slot	example input:		econ.01	example output:		wpi		(wholesale price index)	notes:				x}c:	MEASURE.OF>	level		basic	instance.of	flow.func	i.take		symbol	i.give		symbol	arguments	*a	my.vars		*m	algorithm	( do	( bindq *m ( value.of *a 'MEASURE.OF ) )						( if.true	( null? *m )							( do	( display> *a debug )									( display "missing measure.of" debug ) ) )						( return *m ) )\ =============================={	DEPENDENT?	description:		see if two data sources are 	example input:	econ.01 econ.02	example output:	T	notes:			if measure.of slot is missing from both, it tells you, but considers them DEPENDENT}c:	DEPENDENT?	level		basic	instance.of	flow.pred	i.take		symbol symbol	i.give		flag	arguments	*a *b 	my.vars		*truth	algorithm	( do	( cond	( ( same? *a *b )		\ same files?								  ( bindq *truth T ) )								( ( same?	( isa> ( measure.of> *a ) ) 											( isa> ( measure.of> *b ) ) )								  ( bindq *truth T ) )								( ( member? *a ( value.of  *b 'MY.VALS ) )								  ( bindq *truth T ) )								( ( member? *b ( value.of *a 'MY.VALS ) )								  ( bindq *truth T ) )								( T ( bindq *truth F ) ) )					( display> "Dependency " print ) ( display *a print ) ( display *b print ) ( display *truth print )					( return *truth ) )\ --------------------------------------------------------------------------------------------------------------DATA SUMMARYc:	LIST.VAR	level		basic	instance.of	math.func	i.take		list number	i.give		number	arguments	*data *mean	my.vars		*sum *count	algorithm	( do	( bindq *count ( length *data ) )						( bindq *sum 0.0 )						( loop.until	( null? *data )							( do	( bindq *sum										( plus *sum ( sqr ( minus  *mean ( first *data ) ) ) ) )									( bindq *data ( rest *data ) ) ) )						( return ( quotient *sum ( float *count ) ) ) )c:	LIST.STD.DEV	instance.of	math.func	i.take		list number	i.give		number	arguments	*data *mean	algorithm	( sqrt ( list.var *data *mean ) )c:	LIST.MEAN	level		basic	instance.of	math.func	i.take		list	i.give		number	arguments	*data	my.vars		*sum *count	algorithm	( do	( bindq *count ( length *data ) )						( bindq *sum 0.0 )						( loop.until	( null? *data )							( do	( bindq *sum										( plus *sum ( first *data ) ) )									( bindq *data ( rest *data ) ) ) )						( return ( quotient *sum ( float *count ) ) ) )