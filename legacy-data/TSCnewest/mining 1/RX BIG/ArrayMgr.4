\	ArrayMgr.4\	Support for indexed arrays of s-expressions{	ArrayMgr.4description:	Low-level forth routines to allocate and access 1D, 2D, 3D arrays of s-expressions.				Higher-level routines are in Arrays.4, Arrays.T.				Includes support for garbage collection; uses MOVE-DEFERREDneed to do:to improve:		problems:notes:NewCentury 12point, TabStops=4, LineWrap=100.CHANGES:2/13/93 start	dhf:	first cut}\ *********************** Array Descriptor records **************************10 /n * constant /A.D.CHUNKcreate	ARRAY.MGR.BLOCK	/block allotarray.mgr.block	/block erase/a.d.chunk array.mgr.block block.alloc: A.D.BLOCK.INCREASE ( -- )	array.mgr.block +size @				\ s: oldsize(bytes)	array.mgr.block /a.d.chunk block.increase	array.mgr.block +handle @ h@ +	\ s: addr.new	/a.d.chunk erase	;\ Access dimensions and data from array base addr.: +x@ ( addr -- n ) @ ;: +x! ( n addr -- ) ! ;: +y@ ( addr -- n ) /n + @ ;: +y! ( n addr --  ) /n + ! ;/n 2 * constant /n2*: +z@ ( addr -- n ) /n2* + @ ;: +z! ( n addr -- ) /n2* + ! ;/n 3 * constant /n3*: +dataptr ( addr -- n ) /n3* + ;\ Search array.mgr.block for a.d.rec containing given handle.: HANDLE.TO.A.D.REC ( a.hndl -- addr )	dup 0=	if	error> ." Nil handle in HANDLE.TO.A.D.REC " 		abort	then	dup	array.mgr.block +handle @ h@	\ s: a.hndl a.hndl &a.d.rec[0]	array.mgr.block +size @			\ s: a.hndl a.hndl &a.d.rec[0] size(bytes)	bounds	do		i  @ over		\ s: a.hndl a.hndl a.d.rec[n].handle hndl		= if			drop i leave			\ success s: a.hndl &a.d.rec[n]		then					\ failure  s: a.hndl a.hndl	/n +loop	swap over =	if	error> ." Invalid handle in HANDLE.TO.A.D.REC: " .		abort	then		\ s:  &a.d.rec[n]	;	\ *********************** Array test display words **************************\ Dump contents of array.mgr.block: ARRAY.MGR.DUMP (( ; base -- ))	array.mgr.block +handle @	dup hlock ?memerr				\ s: m.hndl	dup h@ to base	\ base = &a.d.rec[0]	cr	array.mgr.block +size @ 0		\ s: m.hndl size(bytes) 0	do		." offset: " i . space		i base +					\ s: m.hndl &a.d.rec[n]		@ dup  ." handle: " . space	\ s: m.hndl a.hndl		dup not-null		if			dup hlock ?memerr		\ s: m.hndl a.hndl			dup h@				\ s: m.hndl a.hndl a.ptr			dup +x@ ." xmax: " . space			dup +y@ ." ymax: " . space			dup +z@ ." zmax: " . space			drop					\ s: m.hndl a.hndl			hunlock ?memerr		\ s: m.hndl		else drop then		cr	/n +loop	hunlock ?memerr	;\ Dump the contents of one array; as s-expressions or integers depending on flag: ARRAY.DUMP (( a.hndl tf ; z y x k -- ))		array.mgr.block +handle @	dup hlock ?memerr	a.hndl			\ s: m.hndl a.hndl	dup not-null	if		dup hlock ?memerr		\ s: m.hndl a.hndl		dup h@					\ s: m.hndl a.hndl a.ptr		dup +x@ to x		dup +y@ dup 0= if drop 1 then to y		dup +z@ dup 0= if drop 1 then to z	\ s: m.hndl a.hndl a.ptr		+dataptr							\ s: m.hndl a.hndl data.ptr		cr		0 to k		z 0 ?do			y 0 ?do				x 0 ?do					." ( z y x )= ( " k . space j . space i . space ." )  "					dup @ tf					if		.sx					else	.					then	cr					/n +				loop			loop			k 1+ to k		loop					\ s: m.hndl a.hndl data.ptr'		drop		hunlock ?memerr		\ s: m.hndl	else drop then	hunlock ?memerr	;6 constant display.width0 value left.indent: ELEMENT.DISPLAY ( addr n -- addr+ )	over @	swap display.width * left.indent + to-column	dup null		if		drop ." nil"		else	dup atomp			if		.atom			else	drop ." ?"		then	then	/n +	;\ Display the contents of an array as s-expressions: ARRAY.DISPLAY (( a.hndl ; z y x k -- ))		array.mgr.block +handle @	dup hlock ?memerr	a.hndl			\ s: m.hndl a.hndl	dup not-null	if		dup hlock ?memerr		\ s: m.hndl a.hndl		dup h@				\ s: m.hndl a.hndl a.ptr		dup +x@ to x		dup +y@ to y		dup +z@ to z			\ s: m.hndl a.hndl a.ptr		+dataptr				\ s: m.hndl a.hndl data.ptr		cr		z 0<> if			0 to k			z 0 ?do				y 0 ?do					." ( " j . space i . space 0 . ." )  "					\ #out @ to left.indent					16 to left.indent					x 0 ?do						i element.display					loop					cr				loop				k 1+ to k				cr			loop					\ s: m.hndl a.hndl data.ptr'		else			y 0<> if				y 0 ?do					." ( " i . space 0 .  ." )  "					\ #out @ to left.indent					14 to left.indent					x 0 ?do						i element.display					loop					cr				loop			else				." ( " 0 .  ." )  "				\ #out @ to left.indent				12 to left.indent				x 0 ?do					i element.display				loop				cr		then then		drop		hunlock ?memerr		\ s: m.hndl	else drop then	hunlock ?memerr	;\ *********************** Array allocation **************************\ This routine is used for 1, 2, or 3 dimensional arrays. Unused z or y,z must be zeros: ARRAY.NEW (( z y x ; base max.n hndl -- \ a.hndl ))	\ Search for an unused array descriptor	0	\ s: n	array.mgr.block +handle @ h@ to base	\ base = &a.d.rec[0]	array.mgr.block +size @	dup /n / to max.n 0		\ s: n size(bytes) 0	do		i base + @					\ s: n  a.d.rec[n].handle		null		if		leave		else	1+		then				\ s: n	/n +loop	\ Increase manager's block of array descriptors if necessary	dup max.n =	if		a.d.block.increase	then	\ s: n	\ Allocate the array handle	x /n*	y 0> if y * then	z 0> if z * then	+dataptr	return swap newHandleClear to hndl	hndl 0 <=	IF	error> hndl . ." Couldn't allocate NEW.ARRAY (z y x)= ("		z . space y . space x . ." )"		abort	THEN	\ s: n	\ Fill in the array dimensions	array.mgr.block +handle @ h@ \ redo; newHandle may have moved base	over /n * +		\ s: n  &a.d.rec[n]	hndl swap !	hndl h@		\ s: n a.ptr	x over +x!	y over +y!	z swap +z!		\ s: n	drop hndl		\ s: a.hndl	;: ARRAY.DISPOSE ( a.hndl -- )	handle.to.a.d.rec			\ s: &a.d.rec[n]	dup  @ swap /n erase	disposHandle ?memerr	;\ *********************** Array fetch and store **************************: ARRAY! ( a.hndl z y x n  --  )	>r >r >r >r h@ 0		\ s: a.ptr 0						r: n x y z	r@  0<> if	\ z<>0?		r> + over +y@  *	\ add z; mult by ymax	else r> drop then		\ s: a.ptr z*ymax				r: n x y	r@  0<> if	\ y<>0?		r> + over +x@ *	\ add y; mult by xmax	else r> drop then		\ s: a.ptr (z*ymax+y)*xmax		r: n x	r> +	/n*				\ s: a.ptr offset(bytes)			r: n	swap +dataptr + r> swap !	;: ARRAY@ ( a.hndl z y x  -- n  )	>r >r >r h@ 0		\ s: a.ptr 0							r: x y z	r@  0<> if	\ z<>0?		r> + over +y@  *	\ add z; mult by ymax	else r> drop then		\ s: a.ptr z*ymax				r: x y	r@  0<> if	\ y<>0?		r> + over +x@ *	\ add y; mult by xmax	else r> drop then		\ s: a.ptr (z*ymax+y)*xmax		r: x	r> +	/n*				\ s: a.ptr offset(bytes)			r:	+ +dataptr @			\ s: n	;\ *********************** Array garbage collection **************************\ Update the cells in an array after garbage collection\ Takes the address of an array descriptor record.: ARRAY.MOVE-CELLS ( a.hndl -- )	dup movehhi ?memerr		\ Move handle hi to prevent fragmentation	dup hlock ?memerr				\ s: a.hndl	dup h@						\ s: a.hndl a.ptr	dup +x@						\ s: a.hndl a.ptr x	over +y@ dup 0>	if		*							\ s: a.hndl a.ptr x*y		over +z@ dup 0>		if			*						\ s: a.hndl a.ptr x*y*z		else drop then	else drop then	/n* swap +dataptr swap			\ s: a.hndl data.ptr size(bytes)	bounds							\ s: a.hndl endaddr addr	do	i @		move-cells		\ update the item and store it back.		i !	/n +loop	\ s: a.hndl	hunlock ?memerr	;\ Call array.move-cells for all array descriptor records: ARRAY.ALL.MOVE-CELLS (( ; base -- )	array.mgr.block +handle @	\ s: m.hndl	dup movehhi ?memerr		\ Move handle hi to prevent fragmentation	dup hlock ?memerr	dup h@ to base	\ base = &a.d.rec[0]	array.mgr.block +size @ 0		\ s: m.hndl size(bytes) 0	do		i base + @					\ s: m.hndl a.hndl		dup not-null		if		array.move-cells		else	drop		then	/n +loop			\ s: m.hndl	hunlock ?memerr	;token.for array.all.move-cells is move-deferred\ Display the contents of an array as s-expressions: COLS.DISPLAY (( a.hndl lst ;  x y  n -- ))		array.mgr.block +handle @	dup hlock ?memerr	a.hndl			\ s: m.hndl a.hndl	dup not-null	if		dup hlock ?memerr		\ s: m.hndl a.hndl		dup h@				\ s: m.hndl a.hndl a.ptr		dup +y@ to y		+dataptr				\ s: m.hndl a.hndl data.ptr		cr		y 0<> lst not-null and if			y 0 ?do				." ( " i . space 0 .  ." )  "				\ #out @ to left.indent				14 to left.indent				lst 0 to n				begin					dup not-null				while					dup car dup not-null					if 						n display.width * left.indent + to-column						integer> to x						a.hndl 0 i x array@			\ s: sx						dup null						if		drop ." nil"						else	dup atomp							if		.atom							else	drop ." ?"							then						then					then					n 1+ to n					cdr				repeat				drop				cr			loop		then		drop		hunlock ?memerr		\ s: m.hndl	else drop then	hunlock ?memerr	;