{	RX.BIG.T3description:	integrated RX system--the Rough Set Stuffneed to do:	xto improve:	XPROBLEMS:	Xnotes:		xCHANGES:2/26/93		first cut. NewCentury 12point, TabStops=4, LineWrap=100.8/23/93		added BETA test for lower approximation -- now need to look at other issues			raised by Ziarko; need to validate BETA}\ --------------------------------------------------------------------------------------------------------------COUNTINGCOMMENT:	ALL ARRAY VALUES ARE SYMBOLIC	ALL ARRAY X&Y VALUES START AT 00	ROW 00 is reserved for NAMESCOMMENT;\ =============================={	CALC.BETA	description:		check degree of intersect of A in B	example input:	( 1 3 4 ) ( 1 3 4 6 7 )	example output	0.6	notes:			x}c:	CALC.BETA	instance.of	flow.pred	i.take		list  list	i.give		number		arguments	*set1 *set2 	my.vars		*count *length *beta	algorithm	( do	( bindq *length  ( length *set2 ) )						( bindq *count  0 )						\ ( display> "SET2 " print ) ( display *length print ) ( display *set2 print )						\ ( display> "BETA " print ) ( display *set1 print ) 						( loop.until	( null? *set1 )	\ for every set1 member							( do	( if.true	( member? ( first *set1 ) *set2 )											( bindq *count ( add1 *count ) ) )									( bindq *set1 ( rest *set1 ) ) ) )						\ ( display *count print )						( bindq *beta ( quotient *count ( float *length ) ) )						\ ( display *beta print )						( return *beta ) )\ =============================={	COMPARE.ROWS?	description:		see if currow (for each P col) is same as given row	example input:		x	example output		x	notes:				x}c:	COMPARE.ROWS?	instance.of		flow.pred	i.take			number  list list 	i.give			flag		arguments		*row *cols *given	\ given is a given row of P data	my.vars		*truth 	algorithm		( do	\ ( display> "Compare Rows " print ) ( display *cols print ) ( display *given print ) 							( bindq *truth T  )							( loop.until	( or?	( null? *cols )	\ for every P col												( not? *truth ) )	\ or mismatch found								( do	( bindq *truth	( same? ( array2@  *array *row ( first *cols ) )															( first *given ) ) )										( bindq *given ( rest *given ) )										( bindq *cols ( rest *cols ) ) ) )							\ ( display *row print ) ( display *truth print )							( return *truth ) )\ =============================={	COUNT.X.PRIME	description:		collect partition of rows which look the same based on given set	example input:	x	example output	list of lists of rows in array which look the same	notes:			x}c:	COUNT.X.PRIME	instance.of	math.func	i.take		list number 	i.give		list			\  list of lists	arguments	*cols *max.y 	my.vars		*row	*checked *result *temp.v *holder *temp.s *xx	algorithm	( do	( display> "Checking X' on " print ) ( display *cols print )						( bindq *result nil )	\ holds list of subsets						\ ( bindq *temp.v nil )	\ holds current P value being checked						( bindq *checked nil )	\ holds N values that have been counted						( bindq *row *max.y )						( loop.until	( equal? *row 0 )	\ for every row except 0							( do	\ take specified contents of row									( bindq *temp.v nil )									\ ( display> "ROW= " print ) ( display *row print ) ( display *temp.v print )									\ ( display> *cols print )									( bindq *xx   *cols )									( loop.until	( null? *xx )	\ for every P col										\ for this row, make a list of Pcol entries										( do	( bindq *temp.v ( cons ( array2@ *array  *row ( first *xx ) )																*temp.v ) )												\ ( display> "Getting Col " print ) ( display ( first *xx ) print )												\ ( display *row print )												\ ( display> *temp.v print )												( bindq *xx ( rest *xx ) ) ) )									\ now have a list (in reverse order) of a given row									\ see if it has already been checked									( bindq *temp.v ( reverse *temp.v ) )									\ ( display> *temp.v print ) ( display> *checked print )									( bindq *temp.s nil )	\ holds subset of rows									( if.true	( not? ( member? *temp.v *checked ) )										( do  \ not checked yet, keep track of it											\ ( display> "NOT MEMBER " print )											\ ( display *temp.v print ) ( display *checked print )											( bindq *checked ( cons *temp.v *checked ) )											( bindq *holder  *row )											( loop.until	( equal? *holder 0 )													\ for every row above this row, skipping row 0												( do	\ gather this row													( if.true	( compare.rows? 																*holder *cols  *temp.v )															( bindq *temp.s 																	( cons *holder *temp.s ) ) )													( bindq *holder ( sub1 *holder ) ) ) ) ) )									\ ( display> " GOT " print ) ( display *temp.s print )									( if.true ( notnull? *temp.s )											( bindq *result ( cons ( reverse *temp.s ) *result ) ) )									( bindq *row ( sub1 *row ) ) ) )						( return ( reverse *result ) ) )											\ =============================={	IND.P.PRIME	description:		collect partition of rows which look the same based on P (given)	example input:	x	example output	list of lists of rows in array which look the same	notes:			P is a list of columns}c:	IND.X.PRIME	instance.of	math.func	i.take		list number 	i.give		list			\  list of lists	arguments	*pset *max.y   	algorithm	( count.x.prime *pset *max.y )\ =============================={	N.PRIME	description:		collect partition based on N (given)	example input:	list of cols called N, max#rows in array, array	example output	list of lists of rows in array which have same N value	notes:			find all members of N which have the same value}c:	N.PRIME	instance.of	math.func	i.take		list number	i.give		list			\  list of lists	arguments	*cols *max.y 	algorithm	( count.x.prime *cols *max.y )\ =============================={	LOWER.IND.P	description:		collect partition based on subset of N in ind.p.prime	example input:	x	example output	list of rows in array 	notes:			RESULT IS NO LONGER ORDERED}c:	LOWER.IND.P	instance.of	math.func	i.take		list list	number	\ N.PRIME subset, IND.P.PRIME list	i.give		list			\ list of rows	arguments	*n.prime.s *ind.prime *beta	my.vars		*result	algorithm	( do	( bindq *result nil )						( loop.until	( null? *ind.prime )	\ for every n.prime							( do	( if.true	( not? ( less.than? 												( calc.beta  ( first *ind.prime ) *n.prime.s )												*beta ) )											( bindq *result ( concat ( copy.list ( first *ind.prime ) )																*result ) ) )									( bindq *ind.prime ( rest *ind.prime ) ) ) )						( display> "LOWER.IND(P)= " print )							( display *n.prime.s print ) ( display *result print )						\ ( display> "LOWER.IND(P)" log )						\ ( display> *n.prime.s log ) ( display> *result log )						( return *result ) )\ =============================={	POS.P.N	description:	positive region of N.PRIME	example input:	x	example output		notes:			RESULT IS NO LONGER ORDERED}c:	POS.P.N	instance.of	math.func	i.take		list list	number	\ N.PRIME list, IND.P.PRIME list	i.give		list			\ union	arguments	*n.prime *ind.prime *beta	my.vars		*result	algorithm	( do	( bindq *result nil )						( loop.until	( null? *n.prime )							( do	( bindq *result										( list.union ( lower.ind.p ( first *n.prime ) *ind.prime *beta )												*result ) )									( bindq *n.prime ( rest *n.prime ) ) ) )						( display> "POS(P,N)= " print ) ( display *result print )						\ ( display> "POS(P,N)=" log ) ( display> *result log )						( return *result ) )\ =============================={	K.P.N	description:		dependency of N on P	example input:	x	example output	x	notes:			*UNIVERSE is cardinality (length) of given universe}: xf/	( sym sym -- sym )		integer> float 		integer> float fswap		f/ >floating ;c:	FQUOTIENT	instance.of	math.func	i.take		number number	i.give		number	forth		%xf/c:	K.P.N	instance.of	math.func	i.take		list list number number	i.give		number	arguments	*n.prime *ind.prime *universe *beta	my.vars		*result	algorithm	( do	( bindq *result 0.0 )						( bindq *result ( fquotient ( length ( pos.p.n *n.prime *ind.prime *beta ) )											 *universe ) )	\ *universe = length						\ ( display> "K(P,N)= " print ) ( display *result  print )						\ ( display> "K(P,N)= " log ) ( display *result log )						( return *result ) )\ =============================={	DO.ROUGH.SETS	description:		the big routine	example input:	x	example output	x	notes:			x}c:	DO.ROUGH.SETS	instance.of	flow.func	i.take		list list number number	i.give		number				\ k(p,n)	arguments	*pset *nset *universe  *beta	my.vars		*n.prime *ind.prime *kpn	algorithm	( do	( display> "DOING ROUGH SETS " print ) ( display *beta print )						( display> "############DOING ROUGH SETS ON P.SET:" log )						( display> *pset log )						( bindq *n.prime ( n.prime *nset  *universe  ) )						( display> "N'= " print ) ( display *n.prime print )						\ ( display> "N'=" log ) ( display> *n.prime log )						( bindq *ind.prime ( ind.x.prime *pset  *universe  ) )						( display> "IND(P)'= " print ) ( display *ind.prime print )						\ ( display> "IND(P)'=" log ) ( display> *ind.prime log )						( bindq *kpn ( k.p.n *n.prime *ind.prime  *universe *beta ) )						( display> "K(P,N)= " print ) ( display *kpn print )						( display> "K(P,N)= " log ) ( display *kpn log )						( return *kpn )						)c:	FIND.MIN.SET	instance.of			flow.func	i.take				list list number number number	i.give				list		arguments			*pset *nset *universe *curkpn *beta	my.vars			*new.kpn *sig *cop *temp *data *psetp	algorithm	( do	\ ( display> "FIND.MIN.SET" print )						( display> "BETA= " log ) ( display *beta log )						( bindq *cop ( copy.list *pset ) )						( bindq *psetp ( copy.list *pset ) )						( bindq *data ( value.of *experiment 'P.DATA ) )						( loop.until ( null? *cop )							( do	( bindq *temp ( first *cop ) )	\ get an attribute column #									( bindq *cop  ( rest *cop ) )									( bindq *psetp ( delete *temp *psetp ) )	\ delete it from set									( display> "Deleted member " print ) ( display *temp print )									\ ( display> "    PSET " print ) ( display> *psetp print )									\ ( display> "PSET" log ) ( display> *psetp log )									\ now calc KPN with it gone									( bindq *new.kpn ( do.rough.sets *psetp *nset *universe *beta ) )									\ given new KPN, calc significance of deleted attribute									( bindq *sig 0.0 )									( if.true	( greater.than? *curkpn 0.0 )											( bindq *sig 												( quotient ( float ( minus *curkpn *new.kpn ) )													*curkpn ) ) )											\ if *sig = 0, no significance in this column									( cond	( ( almost.equal? *sig  0.0   .005 )											  ( do	( display> " Toss that one away " print )													( bindq *pset ( delete *temp *pset ) ) ) )											\ otherwise, put it back											( T ( bindq *psetp ( cons *temp *psetp ) ) ) )									\ ( display> "PSET" print ) ( display *pset print )									( set.value ( nth *data *temp ) 'SIGNIFICANCE *sig )									 ) )						( return *pset ) )comment:\ =============================={	FIND.MIN.SETS	description:		find a minimum set (not all minimum sets)	example input:	( 3 )	example output	( 8 7 4 3 )	notes:			given a core set as initial minset					given a base kpn value of the ensemble						one at a time, add a member of pset to minset						until kpn of minset equals base kpn			NOTE: this does not find ALL minsets, just the first one}c:	FIND.MIN.SETS	instance.of	flow.func	i.take		list list number list number	i.give		list				\ k(p,n)	arguments	*pset *nset *universe *core *maxkpn	my.vars		*curkpn *core *temp *plen *len *minset *results	algorithm	( do	( display> "FINDING MIN SETS " print ) ( display *beta print )						( display> "FINDING MIN SETS ON K(P,N) =  " log )						( display *maxkpn log )						( bindq *curkpn 0.0 )						( bindq *results nil )						( bindq *len ( length *pset ) )						( bindq *plen 0 )						\ put attributes back, 1 at a time until kpn=maxkpn						( loop.until	( equal? *plen *len )							( do	( bindq *temp ( nth *pset *plen ) )									( bindq *minset ( copy.list *core ) )									( if.true	( not? ( member? *temp *minset ) )										( do  ( bindq *minset ( cons *temp *minset ) )											( bindq *curkpn												( do.rough.sets *minset *nset *universe ) )											( if.true	( equal? *curkpn *maxkpn )												( do  ( bindq *results ( cons *minset *results ) )													\ a minset found													\ for now, kill loop and exit													( bindq *plen ( sub1 *len ) ) ) ) ) ) 									( bindq *plen ( add1 *plen ) ) ) )						( return *results ) )\ =============================={	FIND.CORE.SET	description:		a core set is the set of attributes that will be found in all minsets	example input:	x	example output	x	notes:			given a pset					given a base kpn for the ensemble						loop along pset looking for members which, when removed from pset						cause a drop in kpn						collect all such members into a core set}c:	FIND.CORE.SET	instance.of	flow.func	i.take		list list number	i.give		list				\ core set	arguments	*pset *nset *universe 	my.vars		*curkpn *core *xpset *plen *xkpn *del *len *core *minset	algorithm	( do	( display> "FINDING CORE SET" print )						\ pset and nset are the entire universe on first pass						( bindq *curkpn ( do.rough.sets *pset *nset *universe ) )						\ now, one at a time, pick vbls out of pset						( bindq *core nil )						( bindq *plen 0 )						( bindq *len ( length *pset ) )						( loop.until	( equal? *plen	*len )							( do	( bindq *xpset ( copy.list *pset ) )									( bindq *del ( nth *pset  *plen  ) )									\ ( display> "ABOUT TO DELETE " print ) ( display *del print )									\ ( display> "from " print ) ( display *xpset print )									( bindq *xkpn  ( do.rough.sets													 ( delete *del *xpset ) *nset															 *universe ) )									\ now, tell about this column's "worth"									( display> "COL= " log ) ( display ( array2@  *array 0 *del ) log )									( display ( minus *curkpn *xkpn ) log )									\ now save this difference in the frame of the col									\ bigger is better!									( set.value ( array2@ *array  0 *del  ) 'WORTH ( minus *curkpn *xkpn ) )									\ if the col is needed to maintain *curkpn, it's part of "core" set									( if.true	( less.than? *xkpn *curkpn )											( bindq *core ( cons *del *core ) ) )									( display> "CORE= " print ) ( display *plen print ) ( display *core print )									( display *pset  print )									( bindq *plen ( add1 *plen ) ) ) )						( display> "SORTING CORE SET: " print )						( bindq *core ( sort.cols.on.worth *core ) )						( display *core print )						\ now, test core set						\ core set is intersect of all minimum sets						( bindq *minset *pset )		\ the minimum default set						( if.true	( notnull? *core )							( do  \ ( display> "NOW TESTING CORE SET" log )								( display> "SORTED CORE SET=" log ) ( display> *core log )								( bindq *xkpn ( do.rough.sets *core *nset *universe ) )								( display *xkpn print )								\ ( display> *xkpn log )								\ now off to find minimum sets								\ but...								\ if the core set gets a full k(pn), then the core set is the minset								( cond	( ( less.than? *xkpn *curkpn )										  ( bindq *minset 											( find.min.sets *pset *nset *universe  *core *curkpn ) ) )										( T ( bindq *minset *core ) ) ) ) )						( if.true	( null? *core )							( do	( display> "##################### RECURSING" log )									( bindq *pset ( rest *pset ) )	\ clip the pset down if no core found									( bindq *core 										( find.core.set *pset *nset *universe  ) )  \ recurse									( bindq *minset ( second *core ) )									( bindq *core ( first *core ) )								\	( if.true	( notnull? *core )								\		( do  ( display> "THE CORE SET = " log )								\			( display> *core log )								\			( display> "THE MIN SET = " log )								\			( display> *minset log ) ) )											) )						\ ( display> "MIN SETS= " print ) ( display *minset print )						\ ( display> "FINAL MIN SETS=" log ) ( display> *minset log )						( return ( list *core *minset ) )						) comment;