{	RX.BIGLOOP.Tdescription:	integrated RX system--the main loopneed to do:		setup to run on multiple "n" columns				setup to output to log the various cols picked as importantto improve:	XPROBLEMS:	Xnotes:		xCHANGES:2/26/93		first cut. NewCentury 12point, TabStops=4, LineWrap=100.3/01/93		jp2: more integration}\ --------------------------------------------------------------------------------------------------------------ROUGH SETS\ =============================={	TRY.ROUGH.SETS.1	description:		workhorse: run rough sets, rank variables, log results	notes:			x}c:	TRY.ROUGH.SETS.1	instance.of		flow.func	my.creator	jp2	i.take		number list list number	i.give		list					\ minset	arguments	*universe *pset *nset *beta	my.vars		*data   *kpn *temp *minset *pdata *mins	algorithm	( 		do	( display> "BUILDING ROUGH SETS" print )			( bindq *kpn ( do.rough.sets *pset *nset *universe *beta ) )			( bindq *temp ( find.min.set *pset *nset *universe *kpn  *beta ) )			( set.value *experiment  'MIN.SET *temp )			\ *temp is list of columns e.g. ( 34 24 17 )			( display> "FINAL MIN SET = " print ) ( display> *temp  print )			( display> "FINAL MIN SET = " log ) ( display>  *temp  log )			\ now convert minset to column names			( bindq *pdata ( value.of *experiment 'P.DATA ) )			( bindq *minset nil )			( bindq *mins ( copy.list *temp ) )			( loop.until	( null? *temp )				( do	( bindq *minset ( cons ( nth *pdata ( first *temp ) ) *minset  ) )						( bindq *temp ( rest *temp ) ) ) )			( set.value *experiment 'MIN.DATA *minset )			( display> *minset print )			( display> *minset log )			\ *minset is a list of column concepts e.g. ( con_23 con_17 )			\ probably want to "show.node" each element of minset to log			( return *minset )	\ return col concepts			)\ --------------------------------------------------------------------------------------------------------------PRODUCT-MOMENT\ =============================={	TRY.CORRELATIONS.1	description:		workhorse: run qualitative statistics, rank pairs, log results	notes:			x}c:	TRY.CORRELATIONS.1	instance.of		flow.func	my.creator	jp2	i.take		sx		i.give		none	arguments	*exp	algorithm	( 		do	( display> "BUILDING CORRELATIONS" print )			\ ( build.correlations ( get *exp 'DATA.SOURCE ) )			)\ --------------------------------------------------------------------------------------------------------------PIATETSKY-SHAPIRO\ =============================={	BUILD.DEPENDENCY.TREE	description:		workhorse: run qualitative statistics, rank pairs, log results	notes:			x}c:	BUILD.DEPENDENCY.TREE	instance.of		flow.func	my.creator	jp2	i.take		number list list		i.give		list	arguments	*universe *pset *nset	algorithm	( 		do	( display> "BUILDING DEPENDENCY TREE" print )			( if.true ( not? ( number? ( first *pset ) ) )	\ not list of col numbers?					( bindq *pset ( convert.to.cols *pset ) ) )			( return ( calc.dep.tree *pset *nset *universe  ) )			)\ --------------------------------------------------------------------------------------------------------------RX LOOP\ =============================={	DATA>ARRAY	description:		move all data into array	example input:	x	example output	x	notes:			x}c:	DATA>ARRAY	instance.of	flow.func	i.take		list number	i.give		none	arguments	*data *universe	my.vars		*temp *col *row	algorithm	( do	( display> "  MOVING DATA TO ARRAY" print )						( bindq *col 0 )	\ start col						( loop.until	( null? *data )							\ for every data (column)							( do	( bindq *temp ( value.of ( first *data ) 'MY.DATA ) )									( array2!   *array  0  *col  ( first *data ) )	\ header									( set.value ( first *data ) 'MY.COL  *col )									( bindq *row 1 )	\ start row									( loop.until	( greater.than? *row  *universe )										\ don't forget, we started at row=1										( do	( array2! *array *row *col ( first *temp ) ) 												( bindq *row ( add1 *row ) )												( bindq *temp ( rest *temp ) ) ) )									( bindq *data ( rest *data ) )									( bindq *col ( add1 *col ) ) ) ) )comment:	Loop based on the EXPERIMENT declaration--e.g.:	c:	EXPERIMENT.R5		instance.of		experiment		context			economy		data.source		( econ.01 econ.02 tides.01 tides.02 sunspot.01 climat.01 climat.02 )		pre.process		PRE.PROCESS.DATA		\ some knobs	\	start.lag			-3	\	end.lag			3		lag.size			3		interest.threshold	0.3		\ above this, we're interested		go.threshold		1.1		\ above this, select as linked		n.data			econ.02	\ this is the data we want to test against								\ will be changed as we "recurse" to build a tree	Here, we setup all the data into an array, set a global *array, get the pset and nset organized	and so forth. Then we fire up the routine demanded in the knobs.	THIS USES ARRAYS rather than list data.comment;c:	RX.BIGLOOP	instance.of		flow.func	i.take			symbol	i.give			none	arguments		*exp	my.vars		*p.data *pset *nset *universe *meth *methods *minset *deps *deps.all *beta	algorithm		( do	( display> "STARTING A BIGLOOP" print )							( setq *experiment *exp )							( places 4 )		\ display reals to 4 places							\ conditionally build indices							( if.true	( notnull? ( get *experiment 'INDEX.DATA ) )									( build.indices ) )							\ transform all data -- save new cons in *exp 'p.data							( pre.process.data *experiment )							( bindq *universe ( value.of *experiment 'U.SET ) )							( bindq *p.data ( value.of *experiment 'P.DATA ) )							\ now build array and move data there							( setq *array			\ *ARRAY is global								( create.array2									( add1 *universe )			\ max y									( length *p.data ) ) )	\ max x  p+n sets							( display> "  NEW ARRAY = " print ) ( display *array print )							( data>array *p.data *universe )							\ now, go do the work							( bindq *pset ( value.of *experiment 'P.SET ) )							( bindq *nset ( value.of *experiment 'N.SET ) )							( bindq *beta ( value.of *experiment 'BETA ) )							( bindq *minset nil )							( bindq *deps nil )							( bindq *deps.all nil )							( bindq *methods ( get *experiment 'STUDY.METHOD ) )							( loop.until ( null? *methods )								( do	( cond	( ( same? ( first *methods ) 'ROUGH )										  ( bindq *minset											( try.rough.sets.1 *universe *pset *nset *beta ) ) )										( ( same? ( first *methods ) 'DEPEND.MIN )										  ( bindq *deps 											( build.dependency.tree *universe *minset *nset ) ) )										( ( same? ( first *methods ) 'DEPEND.ALL )										  ( bindq *deps.all											( build.dependency.tree *universe *pset *nset ) ) )										( ( same? ( first *methods ) 'PEARSON )										  ( try.correlations.1 *experiment ) )										( T ( display> "NO METHOD!" print ) ) )										( bindq *methods ( rest *methods ) ) ) )							( display> "ROUGH GOT " print ) ( display> *minset print )							( display> "ROUGH GOT " log ) ( display> *minset log )							( display> "DEPEND.MIN GOT " print ) ( display> *deps print )							( display> "DEPEND.MIN GOT" log ) ( display> *deps log )							( display> "DEPEND.ALL GOT " print ) ( display> *deps.all print )							( display> "DEPEND.ALL GOT" log ) ( display> *deps.all log )							( bindq *minset ( list.union *minset *deps ) )							( bindq *minset ( list.union *minset *deps.all ) )							( loop.until	( null? *minset )								( do	( ^log ( show.node ( first *minset ) ) )										( bindq *minset ( rest *minset ) ) ) )							)\ --------------------------------------------------------------------------------------------------------------RX Behavior Rulesc:	THEN.STUDY.RX.1	instance.of		rhs.func	sub.of			information.slot	i.take			symbol	i.give			none	arguments		*exp	algorithm		( rx.bigloop *exp )c:	STUDY.RX.1	instance.of			behavior.rule	sub.of				compute.process	my.creator			jp2	if.task=				study	if.slot=				RX	if.concept=			*experiment	then.study.rx.1	*experiment	attach.to				study