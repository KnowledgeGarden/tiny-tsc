{	ROUGH.SET.SAKdescription:	basic Rough Sets modified by Scott King				based on RX-4.TST.Tneed to do:	rank ordering of attributes			generalize to multiple slot  data moving			trim universe length to shortest data list lengthto improve:	XPROBLEMS:	Xnotes:		xCHANGES:2/09/93		first cut. NewCentury 12point, TabStops=4, LineWrap=100.2/10/93		jp2: running on car data; generalizations for Browning study; first Browning run done2/11/93		jp2: adding rankordering cols}{	ALMOST.EQUAL?	description:		checks to see if two numbers are within some distance of each other	example input:		2.5 2.6 .15	example output:	T	notes:				}c:	ALMOST.EQUAL?	sub.of			predicate	i.take			number number number	i.give			flag	arguments		*num1 *num2 *error	algorithm		( between? *num2 ( minus *num1 *error ) ( plus *num1 *error ) )\ =============================={	CALC.BETA	description:		check degree of intersect of A in B	example input:	( 1 3 4 ) ( 1 3 4 6 7 )	example output	0.6	notes:			x}c:	CALC.BETA	instance.of	flow.pred	i.take		list  list	i.give		number		arguments	*set1 *set2 	my.vars		*count *length	algorithm	( do	( bindq *length ( length *set2 )  )						( bindq *count  0 )						( loop.until	( null? *set1 )	\ for every set1 member							( do	( if.true	( member? ( first *set1 ) *set2 )											( bindq *count ( plus1 *count ) ) )									( bindq *set1 ( rest *set1 ) ) ) )						( return ( quotient *count *length ) ) )\ =============================={	SORT.COLS.ON.WORTH	description:		sort to decending worth-- "bubble sort"	example input:		list of concepts	example output:	sorted list of concepts	notes:				made from SORT.ON.WORTH}c:	GET.COL.WORTH	instance.of	flow.func	i.take		number symbol	i.give		number	arguments	*col *array	algorithm	( value.of ( array2@ *array 0 *col ) 'WORTH )c:	SORT.COLS.ON.WORTH					\ seems to work	instance.of	flow.func	i.take		list symbol	i.give		list	arguments	*list *array	my.vars		*templist  *moved	algorithm	(		do	( bindq *templist nil )			( bindq *moved T )			( loop.until	( not? *moved )				( do	( bindq *moved F )						( loop.until	( null? *list )							  ( do	\ ( display> *list debug ) ( display> "##" debug ) ( display *templist debug )									( cond	( ( equal? ( length *list ) 1 )											  ( do	( bindq *templist ( cons ( first *list ) *templist ) )													( bindq *list ( rest *list ) ) ) )											( ( greater.than?													( get.col.worth ( second *list ) *array )													( get.col.worth ( first *list ) *array ) )											   ( do	( bindq *templist ( cons ( second *list ) *templist ) )													( bindq *list ( cons ( first *list ) ( rest ( rest *list ) ) ) )													( bindq *moved T ) ) )											( T ( do	( bindq *templist ( cons ( first *list ) *templist ) )														( bindq *list ( rest *list ) ) ) ) ) ) )						( bindq *list ( reverse *templist ) )						( bindq *templist nil ) ) )				( return *list )				\ ( display> "sort.on.worth >>" debug ) ( display *list debug )				)\ --------------------------------------------------------------------------------------------------------------COUNTINGCOMMENT:	ALL ARRAY VALUES ARE SYMBOLIC	ALL ARRAY X&Y VALUES START AT 00	ROW 00 is reserved for NAMESCOMMENT;\ =============================={	COMPARE.ROWS?	description:		see if currow (for each P col) is same as given row	example input:		x	example output		x	notes:				THIS SHOULD ELIMINATE ANY ROWS 						WHICH ALREADY COMPARE -- to save some compute time						eliminate by simply putting the row number on a list, then check						the list before comparing all the columns in a row}c:	COMPARE.ROWS?	instance.of		flow.pred	i.take			number  list symbol list 	i.give			flag		arguments		*row *cols *array *given	\ given is a given row of P data	my.vars		*truth 	algorithm		( do	( bindq *truth T  )							( loop.until	( or?	( null? *cols )	\ for every P col												( not? *truth ) )	\ or mismatch found								( do	( bindq *truth	( same? ( array2@  *array *row ( first *cols ) )															( first *given ) ) )										( bindq *given ( rest *given ) )										( bindq *cols ( rest *cols ) ) ) )							( return *truth ) )\ =============================={	COUNT.X.PRIME	description:		collect partition of rows which look the same based on given set	example input:	x	example output	list of lists of rows in array which look the same	notes:			x}c:	COUNT.X.PRIME	instance.of			math.func	i.take				list number  symbol	i.give				list			\  list of lists	arguments			*cols *max.y   *array 	my.vars			*row *checked *result *temp.v *holder *temp.s *xx	algorithm	( do	\ ( display> "Checking X' on " print ) ( display *cols print ) ( display *max.y print )						( bindq *result nil )	\ holds list of subsets						( bindq *checked nil )	\ holds N values that have been counted						( bindq *row *max.y )						( loop.until	( equal? *row 0 )	\ for every row except 0							( do	\ take specified contents of row									( bindq *temp.v nil )									( bindq *xx *cols )									( loop.until	( null? *xx )	\ for every P col										\ for this row, make a list of Pcol entries										( do	( bindq *temp.s ( array2@ *array *row ( first *xx ) ) )												( bindq *temp.v ( cons *temp.s *temp.v ) )												( bindq *xx ( rest *xx ) ) ) )									\ now have a list (in reverse order) of a given row									\ see if it has already been checked									( bindq *temp.v ( reverse *temp.v ) )									( bindq *temp.s nil )	\ holds subset of rows									( if.true	( not? ( member? *temp.v *checked ) )										( do  \ not checked yet, keep track of it											( bindq *checked ( cons *temp.v *checked ) )											( bindq *holder  *row )											( loop.until	( equal? *holder 0 )													\ for every row above this row, skipping row 0												( do	\ gather this row													( if.true	( compare.rows? 																*holder *cols *array *temp.v )															( bindq *temp.s 																	( cons *holder *temp.s ) ) )													( bindq *holder ( sub1 *holder ) ) ) ) ) )									( if.true ( notnull? *temp.s )											( bindq *result ( cons ( reverse *temp.s ) *result ) ) )									( bindq *row ( sub1 *row ) ) ) )						( return ( reverse *result ) ) )											\ =============================={	IND.P.PRIME	description:		collect partition of rows which look the same based on P (given)	example input:	x	example output	list of lists of rows in array which look the same	notes:			P is a list of columns}c:	IND.X.PRIME	instance.of	math.func	i.take		list number  symbol	i.give		list			\  list of lists	arguments	*pset *max.y   *array	algorithm	( count.x.prime *pset *max.y *array )\ =============================={	N.PRIME	description:		collect partition based on N (given)	example input:	list of cols called N, max#rows in array, array	example output	list of lists of rows in array which have same N value	notes:			find all members of N which have the same value}c:	N.PRIME	instance.of	math.func	i.take		list number symbol	i.give		list			\  list of lists	arguments	*cols *max.y *array	algorithm	( count.x.prime *cols *max.y *array )\ =============================={	LOWER.IND.P	description:		collect partition based on subset of N in ind.p.prime	example input:	x	example output	list of rows in array 	notes:			RESULT IS NO LONGER ORDERED}c:	LOWER.IND.P	instance.of	math.func	i.take		list list number		\ N.PRIME subset, IND.P.PRIME list	i.give		list			\ list of rows	arguments	*n.prime.s *ind.prime *beta	my.vars		*result	algorithm	( do	( bindq *result nil )						( loop.until	( null? *ind.prime )	\ for every n.prime							( do	( if.true	( greater.than? 												( calc.beta  ( first *ind.prime ) *n.prime.s )												*beta )											( bindq *result ( concat ( copy.list ( first *ind.prime ) )																*result ) ) )									( bindq *ind.prime ( rest *ind.prime ) ) ) )						\ ( display> "LOWER.IND(P)" log )						\ ( display> *n.prime.s log ) ( display> *result log )						( return *result ) )\ =============================={	POS.P.N	description:		x	example input:	x	example output		notes:			RESULT IS NO LONGER ORDERED}c:	POS.P.N	instance.of	math.func	i.take		list list	number	\ N.PRIME list, IND.P.PRIME list	i.give		list			\ union	arguments	*n.prime *ind.prime *beta	my.vars		*result	algorithm	( do	( bindq *result nil )						( loop.until	( null? *n.prime )							( do	( bindq *result										( list.union ( lower.ind.p ( first *n.prime ) *ind.prime *beta )												*result ) )									( bindq *n.prime ( rest *n.prime ) ) ) )						\ ( display> "POS(P,N)=" log ) ( display> *result log )						( return *result ) )\ =============================={	K.P.N	description:		dependency of N on P	example input:	x	example output	x	notes:			x}: xf/	( sym sym -- sym )		integer> float 		integer> float fswap		f/ >floating ;c:	FQUOTIENT	instance.of	math.func	i.take		number number	i.give		number	forth		%xf/c:	K.P.N	instance.of	math.func	i.take		list list number number	i.give		number	arguments	*n.prime *ind.prime *universe *beta	my.vars		*result	algorithm	( do	( bindq *result 0.0 )						( bindq *result ( fquotient ( length ( pos.p.n *n.prime *ind.prime  *beta ) )											 *universe ) )						( return *result ) )\ =============================={	DO.ROUGH.SETS	description:		the big routine	example input:	x	example output	x	notes:			x}c:	DO.ROUGH.SETS	instance.of	flow.func	i.take		list list number symbol number	i.give		number				\ k(p,n)	arguments	*pset *nset *universe *beta	my.vars		*n.prime *ind.prime *kpn	algorithm	( do	\ ( display> "DOING ROUGH SETS" print )						\ ( display> "############DOING ROUGH SETS" log )						\ ( display> *pset log )						( bindq *n.prime ( n.prime *nset  *universe  *array ) )						\ ( display> "N'= " print ) ( display *n.prime print )						\ ( display> "N'=" log ) ( display> *n.prime log )						( bindq *ind.prime ( ind.x.prime *pset  *universe  *array ) )						\ ( display> "IND(P)'= " print ) ( display *ind.prime print )						\ ( display> "IND(P)'=" log ) ( display> *ind.prime log )						( bindq *kpn ( k.p.n *n.prime *ind.prime  *universe  *beta ) )						( display> "K(P,N)= " print ) ( display *kpn print )						( display> "K(P,N)=" log ) ( display *kpn log )						( return *kpn )						)c:	MAKE.PLIST	sub.of				function 	my.creator			sak	i.take				number	i.give				list 	arguments			*num	my.vars			*list *count	algorithm	( do	( bindq *list nil )						( bindq *count 1 )						( loop.until ( greater.than? *count *num )							( do	( bindq *list ( cons *count *list ) )									( bindq *count ( add1 *count ) ) ) )						( return ( reverse *list ) ) )c:	FIND.MIN.SET	instance.of			flow.func	i.take				list list list number number number	i.give				list		arguments			*pset *nset *universe *curkpn *beta	\ *cop 	my.vars			*psetp *new.kpn *sig	algorithm	( do	\ ( display> "FIND.MIN.SET" print )						( loop.until ( null? *cop )							( do	( display> "Deleted member " print ) 									( display ( value.of ( first *cop ) 'my.col ) print )									( bindq *psetp ( delete ( value.of ( first *cop ) 'MY.COL ) ( copy.list *pset ) ) )									( display> "PSET" log ) ( display> *pset log )									( bindq *new.kpn ( do.rough.sets *psetp *nset *universe *beta ) )									( bindq *sig ( quotient ( float ( minus *curkpn *new.kpn ) ) *curkpn ) )									( if.true ( almost.equal? *sig 0 .005 )										( do	( display> " Toss that one away " print )												( bindq *pset ( delete ( value.of ( first *cop ) 'MY.COL ) *pset ) ) ) )									\ ( display> "PSET" print ) ( display *pset print )									( array2! *array 0 ( value.of ( first *cop ) 'MY.COL ) *sig )									( bindq *cop ( rest *cop ) ) ) )						( return *pset ) )c:	FIND.SIG.VALS	instance.of			flow.func	i.take				list list number symbol number	i.give				list				\ k(p,n)	arguments			*pset *nset *universe *array *curkpn	my.vars			*count *test *new.kpn *sig	algorithm	( do	( display> "FIND.SIG.VALS" print )						( bindq *count *pset )						( bindq *test *pset )						( loop.until ( null? *count )							( do	( display> "Deleted member" print ) 									( display ( first *count ) print )									( bindq *test ( delete ( first *count ) ( copy.list *pset ) ) )									( display *test print )									( bindq *new.kpn ( do.rough.sets *test *nset *universe *array ) )									( bindq *sig ( quotient ( float ( minus *curkpn *new.kpn ) ) *curkpn ) )									( array2! *array 0 ( first *count ) *sig )									( bindq *count ( rest *count ) ) ) )						( return *pset ) )c:	SORT&EVAL.RULES	instance.of			flow.func	i.take				list list number symbol	i.give				list				\ k(p,n)	arguments			*rules *nset *universe *array	my.vars			*cop *pset *curkpn *psetp *new.kpn *sig	algorithm	( do	( display> "SORT&EVAL.RULES" print )						( bindq *cop *rules )						( display *cop print )						( bindq *pset ( make.plist ( length *rules ) ) )						\ ( display> "pset, nset, universe, array" print )						\ ( display *pset print ) ( display *nset print ) ( display *universe print ) ( display *array print )						( bindq *curkpn ( do.rough.sets *pset *nset *universe *array ) )						( if.true ( not? ( equal? *curkpn 0 ) )							( do	( bindq *pset ( find.min.set *cop *pset *nset *universe *array *curkpn ) )									\ ( bindq *pset ( find.sig.vals *pset *nset *universe *array *curkpn ) )									) )						( display> "MINIMAL SET" print ) ( display *pset print ) ( display *curkpn print )						( display> "MINIMAL SET" log ) ( display> *pset log )						( display> "Has K.P.N. of" log ) ( display> *curkpn log )						( return *pset ) )COMMENT:BIG CODE THAT NEEDS TO BE BROKEN DOWN\ =============================={	FIND.CORE.SET	description:		an even bigger routine	example input:	x	example output	x	notes:			x}c:	FIND.CORE.SET	instance.of	flow.func	i.take		list list number symbol	i.give		none				\ k(p,n)	arguments	*pset *nset *universe *array	my.vars		*curkpn *core *xpset *plen *xkpn *del *len *core *minset	algorithm	( do	( display> "FINDING CORE SET" print )						\ pset and nset are the entire universe on first pass						( bindq *curkpn ( do.rough.sets *pset *nset *universe *array ) )						\ now, one at a time, pick vbls out of pset						( bindq *core nil )						( bindq *plen 0 )						( bindq *len ( length *pset ) )						( loop.until	( equal? *plen	*len )							( do	( bindq *xpset ( copy.list *pset ) )									( bindq *del ( nth *pset  *plen  ) )									\ ( display> "ABOUT TO DELETE " print ) ( display *del print )									\ ( display> "from " print ) ( display *xpset print )									( bindq *xkpn  ( do.rough.sets													 ( delete *del *xpset ) *nset															 *universe *array ) )									\ now, tell about this column's "worth"									( display> "COL= " log ) ( display ( array2@ *array 0 *del ) log )									( display ( minus *curkpn *xkpn ) log )									\ now save this difference in the frame of the col									\ bigger is better!									( set.value ( array2@ *array 0 *del ) 'WORTH 														( minus *curkpn *xkpn ) )									\ if the col is needed to maintain *curkpn, it's part of "core" set									( if.true	( less.than? *xkpn *curkpn )											( bindq *core ( cons *del *core ) ) )									( display> "CORE= " print ) ( display *plen print ) ( display *core print )									( display *pset  print )									( bindq *plen ( add1 *plen ) ) ) )						( display> "SORTING CORE SET: " print )						( bindq *core ( sort.cols.on.worth *core *array ) )						( display *core print )						( display> "CORE SET=" log ) ( display> *core log )						\ now, test core set						\ core set is intersect of all minimum sets						( bindq *minset *pset )		\ the minimum default set						( if.true	( notnull? *core )							( do  ( display> "NOW TESTING CORE SET" log )								( bindq *xkpn ( do.rough.sets *core *nset *universe *array ) )								( display *xkpn print )								( display> *xkpn log )								\ now off to find minimum sets								\ but...								\ if the core set gets a full k(pn), then the core set is the minset								( cond	( ( less.than? *xkpn *curkpn )										  ( bindq *minset 											( find.min.sets *pset *nset *universe *array *core *curkpn ) ) )										( T ( bindq *minset *core ) ) ) ) )						( display> "MIN SETS= " print ) ( display *minset print )						( display> "MIN SETS=" log ) ( display> *minset log )						) COMMENT;