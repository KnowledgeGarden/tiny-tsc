{	RX.BIG.T2description:	integrated RX system--the Pearson Product Moment Stuffneed to do:	xto improve:	XPROBLEMS:	Xnotes:		xCHANGES:2/26/93		first cut. NewCentury 12point, TabStops=4, LineWrap=100.}\ =============================={	LIST.PEARSON	description:			calculate Pearson Product Moment on a pair of lists	example input:		x	notes:				first list is the lagged ( trimmed ) one--it's the shortest			if lists are not all the same, must pay attention to which is shortest}c:	LIST.PEARSON	instance.of	math.func	i.take		list number number list number number	i.give		list			\  ( corr sig )	arguments	*arga *meana *deva *argb *meanb *devb	my.vars		*nn	*sum *argx *sig	algorithm	( do						\ ( display> " LP " print ) ( display ( length *arga ) print ) ( display *meana print )					\ ( display *deva print ) ( display ( length *argb ) print ) ( display *meanb print )					\ ( display *devb print )					( bindq *nn ( length *arga ) )					( bindq *sum 0.0 )					( bindq *argx *arga )	\ default value					( if.true	( less.than? ( length *argb ) ( length *arga ) )						( do  ( bindq *argx *argb )	\ use the shortest list for loop control							( bindq *nn ( length *argb ) ) ) )					( loop.until	( null? *argx )						( do	( bindq *sum 									( plus *sum										( times	( minus ( first *arga ) *meana )												( minus ( first *argb ) *meanb ) ) ) )								( bindq *argx ( rest *argx ) )								( bindq *arga ( rest *arga ) )								( bindq *argb ( rest *argb ) ) ) )					( bindq *sum	( quotient  *sum		\ borrow old vbl for "r"									( times 										( float *nn )										( times *deva *devb ) ) ) )					( bindq *sig ( times *sum			\ "t" test for "r"								( sqrt ( quotient	( minus ( float *nn ) 2.0 )												( minus 1.0 ( sqr *sum ) ) ) ) ) )					( return ( list *sum *sig ) ) )\ =============================={	LAG.CORRELATIONS	description:			the inner routine: correlate pairs	example input:		econ.01 tides.02	notes:				bigsum is the double sum for fdep(X,Y)}c:	LAG.CORRELATIONS	instance.of	flow.func	i.take		symbol symbol	i.give		none	arguments	*a  *b	my.vars		 *meana *meanb *deva *devb *#lag *pear *adat *bdat *thr	algorithm	( do ( display> "  CORRELATING " print ) ( display *a print ) ( display *b print )		( bindq *#lag ( value.of 						( value.of 'CURRENT.EXPERIMENT 'MY.EXPERIMENT ) 						 'LAG.SIZE ) )		( bindq *thr ( value.of 						( value.of 'CURRENT.EXPERIMENT 'MY.EXPERIMENT )						'INTEREST.THRESHOLD ) )		( if.true	( not? ( dependent?  *a *b  ) )			\ move below &&&&			( do  ( bindq *adat  ( value.of *a 'MY.DATA ) )				( bindq *bdat  ( value.of *b 'MY.DATA ) )				( bindq *meana ( list.mean *adat ) )				( set.value *a 'MEAN *meana )				( bindq *meanb ( list.mean *bdat ) )				( set.value *b 'MEAN *meanb )				( bindq *deva ( list.std.dev *adat *meana ) )				( set.value *a 'STD.DEV *deva )				( bindq *devb ( list.std.dev *bdat *meanb ) )				( set.value *b 'STD.DEV *devb )				( loop.until	( less.than? *#lag 0 )	\ for each lag value					( do	( bindq *pear ( list.pearson ( clip.list  *adat *#lag ) *meana *deva												*bdat *meanb *devb ) )							( if.true	( greater.than? ( abs ( first *pear ) ) *thr )								( do  ( display> "PAIRS= " log ) ( display  *a  log ) ( display  *b log )									( display " With A lags B by " log ) ( display *#lag log )									( display> "  Correlation= " log ) ( display ( first *pear ) log )									( display "  with significance= " log ) ( display ( second *pear ) log )									) )							( bindq *#lag ( sub1 *#lag ) ) ) )				) ) )\ =============================={	CALC.CORRS	description:			the main routine: builds a dependency tree from all data	example input:		list of databases	example output:		results left in DB frames in LINKS.TO slots	notes:				bigsum is the double sum for fdep(X,Y)		semantics:	A depends on B					A lags B					or					B depends on A -- B lags A}c:	CALC.CORRS	instance.of	flow.func	i.take		list	i.give		none	arguments	*a 	my.vars		*b 	algorithm	( 		do	( display> "dependencies" debug )			( display> *a debug )			\ start a nested loop to grab unique pairs from list of databases			( loop.until	( null? *a )				\ for every *a -- instance of database				( do	( yield )					( bindq *b ( rest *a ) )					( loop.until	( null? *b )						\ for every *b --instance of database -- which is not *a -- factorial design						( do	( lag.correlations ( first *a ) ( first *b ) )	\ A cor B with lag								( lag.correlations ( first *b ) ( first *a ) )	\ B cor A with lag								( bindq *b ( rest *b ) ) ) )					( bindq *a ( rest *a ) ) ) ) )\ =============================={	BUILD.CORRELATIONS	description:			the main routine: builds a dependency tree from all data	example input:		list of databases	example output:		results left in DB frames in LINKS.TO slots	notes:				bigsum is the double sum for fdep(X,Y)}c:	BUILD.CORRELATIONS	instance.of	flow.func	i.take		list	i.give		none	arguments	*data.source 	algorithm	( 		do	( display> "dependencies" debug )			( display> *data.source debug )			\ now look at correlations			( calc.corrs *data.source  )			)\ --------------------------------------------------------------------------------------------------------------RX-TSC Rule Support