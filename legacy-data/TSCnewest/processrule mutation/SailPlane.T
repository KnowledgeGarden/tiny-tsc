{	SailPlane.T	Complete Sailboat KB--high level support	intentions		x	to do:		fix "about.equal?"	dates		04/28/93	first cut, made from sailboat.t.new		04/30/93	lots of additions}\ ______________________________________________________________________ TSC EXTENSIONS\ ______________________________________________________________________ PREDICATESc:	ABOUT.EQUAL?	instance.of	math.pred	i.take		number number	i.give		flag	arguments	*n1 *n2	algorithm	( equal? *n1 *n2 )		\ &&&& for now &&&&\ ______________________________________________________________________ BEHAVIOR SUPPORT\ =============================={	THEN.FILLIN.BIRD.1	description:		Visiting an episode, try to build some daughter episodes.	example input:		x	example output:	x	notes:				only build daughter(s) if it is not terminated			rule gathering depends on ACTORS				&&&&&&&			will have to put some ACTORS (e.g. ( VEHICLE ( *x ) TRUE )			and make sailplane isa vehicle in the KB}c:	THEN.FILLIN.BIRD.1	sub.of		information.slot	instance.of			rhs.func	i.take				symbol	i.give				none	arguments			*ep	algorithm			( do			( display> "filling in boat" debug )		( setq *experiment *ep )		( setq *cur.episode *ep )				\ for simulator on first pass		( set.value *ep 'DESIGN.NOTES nil )		( simulate.bird  )					\ run simulator on new bird frame		( SETQ *BUILDER.RULE ( @CUR.RULE ) )		( NO.CYCLE )								\ inactivate cycle detection in QPT		( if.true	( member? 'EXPERIMENT ( select 'INSTANCE.OF from *ep ) )				( set.value *ep 'START.EPISODE *ep ) )		(  display> "going for sense rules" debug )		( yield )		( exhaust.these.rules *ep ( gather.sense.rules *ep ) )		( yield )		( display> "terminus?" debug ) ( display ( value.of *ep 'terminus ) debug )		( setq *ep.star 'NEXT.DESIGN )		\ to vector QPT new task slot		( setq *prio.star ( plus 300 ( int ( quotient										( times	( value.of *cur.episode 'MAX.L/D ) 												( value.of *cur.episode 'SPEED.L/D ) )										( value.of *cur.episode 'MIN.SINK ) ) ) ) )		\ makes priority a function of performance: run higher performance birds first		\ note: l/d speed was chosen instead of vmax (per armin saxir in soartech)		( if.true ( null? ( value.of *ep 'TERMINUS ) )				\ can time-limit "try.these.rules"				( try.these.rules *ep ( sort.on.worth ( gather.process.rules *ep ) ) ) )		)\ ______________________________________________________________________ DESIGN EVALUATIONcomment:	for now, we consider three figures: minimum sink, maximum l/d, and speed for max l/d	these three sortof define the bird polar	the idea is this:		to mess with a design			mutate a design			compare polars			if polar improves, reward the design rule			otherwise, lightly punish the design rule		to compare polars			if min sink is lower			and max l/d is higher			and speed for max l/d is higher			then improve	( perf.up)			OR			if max l/d is higher			and speed for max l/d is higher			and min sink is approx same	( e.g. +/- 5% )			then improve	(perf.up)comment;c:	GET.POLAR	instance.of	flow.func	i.take		symbol	i.give		list	arguments	*ep	my.vars	*ms *mld *vmld	algorithm	( do	( bindq *ms ( value.of *ep 'min.sink ) )						( bindq *mld ( value.of *ep 'max.l/d ) )						( bindq *vmld ( value.of *ep 'speed.l/d ) )						( return ( list *ms *mld *vmld ) ) )\ ======================={		GET.CUR.POLAR		return polar ( min.sink max.l/d speed.l/d ) from current episode}c:	GET.CUR.POLAR	instance.of	flow.func	i.take		none	i.give		list	my.vars	*ms *mld *vmld	algorithm	( get.polar *cur.episode )\ ======================={		GET.PREV.POLAR		return polar ( min.sink max.l/d speed.l/d ) from previous episode}c:	GET.PREV.POLAR	instance.of	flow.func	i.take		none	i.give		list	my.vars	*ms *mld *vmld *list *exp	algorithm	( do	( bindq *list nil )						( bindq *exp ( value.of *cur.episode 'prev.episode ) )						( if.true	( notnull? *exp )								( bindq *list ( get.polar *exp ) ) )						( return *list ) )c:	GET.EARLIER.POLAR	\ look back 2 episodes from current	instance.of		flow.func	i.take		none	i.give		list	my.vars	*perf	algorithm	( do	( cond	( ( notnull? ( value.of ( value.of *cur.episode 'prev.episode ) 													'prev.episode ) )								  ( bindq *perf 									( get.polar ( value.of	( value.of *cur.episode 'prev.episode )														' prev.episode ) ) ) )								( T ( bindq *perf nil ) ) )						( return *perf ) )\ ======================={		COMPARE.POLARS.1		true if:			if min sink is lower			and max l/d is higher			and speed for max l/d is higher		using slots: 	min.sink max.l/d speed.l/d}c:	COMPARE.POLARS.1	instance.of		flow.pred	i.take			none	i.give			flag	my.vars		*truth *this *prev	algorithm		( do	( bindq *this ( get.cur.polar ) )							( bindq *prev ( get.prev.polar ) )							( bindq *truth ( and? ( notnull? *this ) ( notnull? *prev ) ) )							( if.true	*truth								( do	( bindq *truth ( and?	*truth 														( less.than? ( first *this ) ( first *prev ) ) ) )										( bindq *truth ( and?	*truth 											( greater.than? ( second *this ) ( second *prev ) ) ) )										\ ( bindq *truth ( and?	*truth 										\	( greater.than? ( third *this ) ( third *prev ) ) ) )								) )							( return *truth ) )\ ======================={		COMPARE.POLARS.2		true if:			if min sink is approx. same			and max l/d is higher			and speed for max l/d is higher}c:	COMPARE.POLARS.2	instance.of		flow.pred	i.take			none	i.give			flag	my.vars		*truth *this *prev	algorithm		( do	( bindq *this ( get.cur.polar ) )							( bindq *prev ( get.prev.polar ) )							( bindq *truth ( and? ( notnull? *this ) ( notnull? *prev ) ) )							( if.true	*truth								( do	( bindq *truth ( and?	*truth 											( about.equal? ( first *this ) ( first *prev ) ) ) )										( bindq *truth ( and?	*truth 											( greater.than? ( second *this ) ( second *prev ) ) ) )										\ ( bindq *truth ( and?	*truth 										\	( greater.than? ( third *this ) ( third *prev ) ) ) )								) )							( return *truth ) )\ ======================={		COMPARE.POLARS.3		true if:			if min sink is lower			and max l/d is higher			and speed for max l/d is higher		using slots: 	min.sink max.l/d speed.l/d}c:	COMPARE.POLARS.3	instance.of		flow.pred	i.take			none	i.give			flag	my.vars		*truth *this *prev	algorithm		( do	( bindq *this ( get.prev.polar ) )							( bindq *prev ( get.earlier.polar ) )							( bindq *truth ( and? ( notnull? *this ) ( notnull? *prev ) ) )							( if.true	*truth								( do	( bindq *truth ( and?	*truth 											( less.than? ( first *this ) ( first *prev ) ) ) )										( bindq *truth ( and?	*truth 											( greater.than? ( second *this ) ( second *prev ) ) ) )										\ ( bindq *truth ( and?	*truth 										\	( greater.than? ( third *this ) ( third *prev ) ) ) )								) )							( return *truth ) )\ ======================={		COMPARE.POLARS.4		true if:			if min sink is approx. same			and max l/d is higher			and speed for max l/d is higher}c:	COMPARE.POLARS.4	instance.of		flow.pred	i.take			none	i.give			flag	my.vars		*truth *this *prev	algorithm		( do	( bindq *this ( get.prev.polar ) )							( bindq *prev ( get.earlier.polar ) )							( bindq *truth ( and? ( notnull? *this ) ( notnull? *prev ) ) )							( if.true	*truth								( do	( bindq *truth ( and?	*truth 											( about.equal? ( first *this ) ( first *prev ) ) ) )										( bindq *truth ( and?	*truth 											( greater.than? ( second *this ) ( second *prev ) ) ) )										\ ( bindq *truth ( and?	*truth 										\	( greater.than? ( third *this ) ( third *prev ) ) ) )								) )							( return *truth ) )\ ______________________________________________________________________ DESIGN PROCESS SUPPORTc:	PERF.DOWN?			\ T if performance has NOT improved over previous design	instance.of		flow.pred	i.take		none	i.give		flag	algorithm	( not?	( or?	( compare.polars.1 ) ( compare.polars.2 ) ) )c:	PERF.UP?				\ T if performance has improved over previous design	instance.of		flow.pred	i.take		none	i.give		flag	algorithm	( or?	( compare.polars.1 ) ( compare.polars.2 ) )c:	SAME.MECHANISM?	\ look at current and previous 2 episodes	instance.of		flow.pred	i.take		none	i.give		flag	my.vars	*mech *truth	algorithm	( do	( bindq *mech ( value.of *cur.episode 'mechanism ) )	\ assumes 1						( bindq *truth ( and?	( same? *mech 												( value.of  ( value.of *cur.episode 'prev.episode )													'mechanism ) )											( same? *mech												( value.of														( value.of ( value.of *cur.episode 'prev.episode )														'prev.episode )													'mechanism ) ) ) )						( return *truth ) )c:	MULTI.PERF.UP?		\ T if performance improved over "several" episodes--same mechanism	instance.of		flow.pred	i.take		none	i.give		flag	algorithm	( and?	( perf.up? )						( and?	( or? ( compare.polars.3 ) ( compare.polars.4 ) ) 								( same.mechanism? ) ) )c:	MULTI.PERF.DOWN?	\ T if performance decreased over "several" episodes--same mechanism	instance.of		flow.pred	i.take		none	i.give		flag	algorithm	( and?	( perf.down? )						( and?	( not? ( or? ( compare.polars.3 ) ( compare.polars.4 ) ) )								( same.mechanism? ) ) )c:	NEW.EP?				\ T if this episode has a previous episode	instance.of		flow.pred	i.take		none	i.give		flag	algorithm	( notnull? ( value.of *cur.episode 'prev.episode ) )c:	TOO.MANY.EPS?	instance.of		flow.pred	i.take		none	i.give		flag	algorithm	( greater.than? ( #episodes ) ( value.of *cur.episode 'max#episodes ) )\ =============================={	IF.DESIGN.NOTES	description:		eval a given list returning truth flag	example input:		x	example output:	T	notes:				design notes are written to a slot in the episode by the simulator}c:	IF.DESIGN.NOTES	sub.of		information.slot	instance.of		lhs.pred	return.bind		false	my.creator		jp2	i.take			list	i.give			flag	arguments		*list	my.vars		*truth *notes	algorithm		( do	( bindq *truth T )							( bindq *notes ( first ( select 'design.notes from *cur.episode ) ) )							( loop.until	( or?	( null? *list )												( not? *truth ) )								( do	( bindq *truth ( member? ( first *list ) *notes ) )										( display *truth debug )										( bindq *list ( rest *list ) ) ) )							( display *truth debug )							( return *truth ) )\ =============================={	IF.WITHIN.AR	description:		if current design is within given percentage of user-specified AR	example input:		10	example output:	T	notes:				x}c:	IF.WITHIN.AR	sub.of		information.slot	instance.of		lhs.pred	return.bind		false	my.creator		jp2	i.take			number		\ e.g. 10%	i.give			flag	arguments		*lim	my.vars		*truth *ar *val	algorithm		( do	( bindq *ar ( value.of *cur.episode 'limit.ar ) )							( bindq *val ( minus *ar 											( quotient ( minus 100 *lim ) 100 ) ) )							\ note use of a simulator global vbl here...							( bindq *truth ( not? ( greater.than? *aspect.ratio *val ) ) )							( return *truth ) )\ =============================={	IF.WITHIN.SPAN	description:		if current design is within given percentage of user-specified span	example input:		10	example output:	T	notes:				x}c:	IF.WITHIN.SPAN	sub.of		information.slot	instance.of		lhs.pred	return.bind		false	my.creator		jp2	i.take			number		\ e.g. 10%	i.give			flag	arguments		*lim	my.vars		*truth *sp *val	algorithm		( do	( bindq *sp ( value.of *cur.episode 'limit.span ) )							( bindq *val ( minus *sp 											( quotient ( minus 100 *lim ) 100 ) ) )							\ note use of a simulator global vbl here...							( bindq *truth ( not? ( greater.than? *wing.span *val ) ) )							( return *truth ) )\ =============================={	IF.ABOVE.FIN.S	description:		if current design is within given percentage of user-specified fin area	example input:		10	example output:	T	notes:				x}c:	IF.ABOVE.FIN.S	sub.of		information.slot	instance.of		lhs.pred	return.bind		false	my.creator		jp2	i.take			number		\ e.g. 10%	i.give			flag	arguments		*lim	my.vars		*truth *fs *val	algorithm		( do	( bindq *fs ( value.of *cur.episode 'limit.fin.s ) )							( bindq *val ( minus *fs 											( quotient ( minus 100 *lim ) 100 ) ) )							\ note use of a simulator global vbl here...							( bindq *truth  ( greater.than? *fin.area *val ) )							( return *truth ) )\ =============================={	IF.ABOVE.STAB.S	description:		if current design is within given percentage of user-specified stab area	example input:		10	example output:	T	notes:				x}c:	IF.ABOVE.STAB.S	sub.of		information.slot	instance.of		lhs.pred	return.bind		false	my.creator		jp2	i.take			number		\ e.g. 10%	i.give			flag	arguments		*lim	my.vars		*truth *ss *val	algorithm		( do	( bindq *ss ( value.of *cur.episode 'limit.stab.s ) )							( bindq *val ( minus *ss 											( quotient ( minus 100 *lim ) 100 ) ) )							\ note use of a simulator global vbl here...							( bindq *truth  ( greater.than? *stab.area *val ) )							( return *truth ) )\ =============================={	IF.SUGGEST.INC.AREA	description:		if simulator suggests a change to fin area > given threshold	example input:		5	( threshold value in rule )	example output:	T	notes:				x}c:	IF.SUGGEST.INC.AREA	sub.of		information.slot	instance.of		lhs.pred	return.bind		false	my.creator		jp2	i.take			number		\ percentage increase	i.give			flag	arguments		*inc	my.vars		*truth *fin *val	algorithm		( do	( bindq *fin ( value.of *cur.episode 'finsize ) )							( bindq *truth ( greater.than?  *fin  *inc ) )							( return *truth ) )\ =============================={	IF.SUGGEST.DEC.AREA	description:		if simulator suggests a decrease to fin area > given threshold	example input:		5	( threshold value in rule )	example output:	T	notes:				x}c:	IF.SUGGEST.DEC.AREA	sub.of		information.slot	instance.of		lhs.pred	return.bind		false	my.creator		jp2	i.take			number		\ percentage increase	i.give			flag	arguments		*inc	my.vars		*truth *fin *val	algorithm		( do	( bindq *fin ( value.of *cur.episode 'finsize ) )							( bindq *truth ( greater.than?  *fin  *inc ) )							( bindq *truth ( and? *truth ( less.than? *fin 0.0 ) ) )							( return *truth ) )\ =============================={	THEN.REWARD.1	<MECHANISM>	description:		increment WORTH of the current *cur.episode episode mechanism	notes:				x}c:	THEN.REWARD.1	sub.of		information.slot	instance.of				rhs.func	i.take				symbol	i.give				none	arguments			*slop	my.vars			*worth *mech	algorithm	( do	( bindq *mech ( value.of *cur.episode 'mechanism ) )						( bindq *worth ( get.worth  *mech ) ) \ assume 1 mechanism &&&&						( bindq *worth ( plus *worth 10 ) )	\ **** make knob						( set.value *mech 'worth *worth ) )\ =============================={	THEN.INC.W.SPAN	description:		x	notes:				x}c:	THEN.INC.W.SPAN	sub.of				information.slot	instance.of			rhs.func	i.take				integer	i.give				none	arguments			*incval	algorithm			( increase.w.span.1 *incval )\ =============================={	THEN.INC.W.AR	description:		x	notes:				x}c:	THEN.INC.W.AR	sub.of		information.slot	instance.of				rhs.func	i.take				integer	i.give				none	arguments			*incval	algorithm			( increase.w.ar.1 *incval )\ =============================={	THEN.INC.W.S	description:		increase wing area	notes:				x}c:	THEN.INC.W.S	sub.of		information.slot	instance.of				rhs.func	i.take				integer	i.give				none	arguments			*incval	algorithm			( increase.w.s.1 *incval )\ =============================={	THEN.INC.FIN.AREA	description:		increase fin area by given amount, holding fin AR constant	notes:				x}c:	THEN.INC.FIN.AREA	sub.of			information.slot	instance.of		rhs.func	i.take			integer	i.give			none	arguments		*incval	algorithm		( increase.fin.s.1 *incval )\ =============================={	THEN.INC.STAB.AREA	description:		increase fin area by given amount, holding fin AR constant	notes:				x}c:	THEN.INC.STAB.AREA	sub.of			information.slot	instance.of		rhs.func	i.take			integer	i.give			none	arguments		*incval	algorithm		( increase.stab.s.1 *incval )\ =============================={	THEN.DEC.FIN.AREA	description:		increase fin area by given amount, holding fin AR constant	notes:				x}c:	THEN.DEC.FIN.AREA	sub.of			information.slot	instance.of		rhs.func	i.take			integer	i.give			none	arguments		*incval	algorithm		( decrease.fin.s.1 *incval )\ =============================={	THEN.DEC.STAB.AREA	description:		increase fin area by given amount, holding fin AR constant	notes:				x}c:	THEN.DEC.STAB.AREA	sub.of			information.slot	instance.of		rhs.func	i.take			integer	i.give			none	arguments		*incval	algorithm		( decrease.stab.s.1 *incval )\ =============================={	THEN.EXTEND.FUSE	description:		increase fin area by given amount, holding fin AR constant	notes:				x}c:	THEN.EXTEND.FUSE	sub.of			information.slot	instance.of		rhs.func	i.take			integer	i.give			none	arguments		*incval	algorithm		( inc.fuse.length.1 *incval )\ =============================={	THEN.CONJ.1	description:		form a conjecture in a rule	notes:				&&&& must be modified to ( conj rule ) &&&&			*cur.episode is a global vbl set by caller			modified to use a user-supplied conjecture threshold}c:	THEN.CONJ.1	sub.of		information.slot	instance.of				rhs.func	i.take				symbol	i.give				none	arguments			*conj	my.vars			*rule	algorithm		( if.true		( notnull? ( value.of *cur.episode 'MECHANISM ) )						( do	( bindq *rule ( value.of *cur.episode 'MECHANISM ) )								( if.true	( and?	( null? ( value.of *rule 'CONJECTURES ) )												( greater.than? ( @cur.priority ) 														(  value.of *cur.episode 'CONJ.PRIORITY ) ) )									( do ( set.value *rule 'CONJECTURES *conj )										( display> "made conjecture on rule" log )										( display *rule log ) ( display *conj log )										( make.new.task											'design											'study											*rule											'rule.conj											'( sailboat )											( plus 600 ( value.of *rule 'WORTH ) )												\ higher worth-->higher task priority											( @cur.rule )											'( new.data focus.of.attention ) ) ) ) ) )c:	INC.CONS.VAL	instance.of		math.func	i.take		symbol symbol	i.give		none	arguments	*rule *cons	my.vars	*val *newval	algorithm	( do	( bindq *val ( value.of *rule *cons ) )	\ watch for nil						( bindq *newval							( int ( times ( float *val ) 1.1 ) ) )						( if.true	( equal? *val *newval )								( bindq *newval ( plus *newval 1 ) ) )						( set.value *rule *cons *newval ) )c:	DEC.CONS.VAL	instance.of		math.func	i.take		symbol symbol	i.give		none	arguments	*rule *cons	my.vars	*val *newval	algorithm	( do	( bindq *val ( value.of *rule *cons ) )	\ watch for nil						( bindq *newval							( int ( times ( float *val ) 0.9 ) ) )						( if.true	( equal? *val *newval )								( bindq *newval ( minus *newval 1 ) ) )						( set.value *rule *cons *newval ) )\ =============================={	THEN.CLONE&MUTATE.1	description:		do a random mutation to the consequent variable	notes:				&&&&NEED to  link new rule in}c:	THEN.CLONE&MUTATE.1	sub.of		information.slot	instance.of				rhs.func	i.take				symbol	i.give				none	arguments			*rule	my.vars			*newrule *cons *type	algorithm			( do	( bindq *newrule ( new.atom ) )		\ later: new.rul.atom								( copy.frame *rule *newrule )								( bindq *type ( value.of *newrule 'INSTANCE.OF ) )								( add.value *type 'INSTANCES *newrule )								( append.value 'VEHICLE 'MY.RULES *newrule ) \ HACK &&&&								( REMPROP *newrule 'conjectures )								\ ( SET.VALUE *newrule 'gens *rule )								\ ( set.value *rule 'specs *newrule )								( bindq *cons ( value.of *newrule 'my.rhs ) )	\ assumes 1 rhs								( rnd.do	( inc.cons.val *newrule *cons )											( dec.cons.val *newrule *cons ) )								( set.value *newrule '#tried 0 )								( set.value *newrule '#succeed 0 )								( set.value *newrule 'recent.count 0 )								( set.value *newrule 'worth 100 )								( set.value *newrule 'sibling *rule )								( insert.value *rule 'sibling *newrule )								( insert.value *newrule 'my.creator ( @cur.rule ) )								( insert.value *newrule 'my.source *rule ) )\ =============================={	THEN.CLONE&MUTATE.2	description:		increase the consequent variable	notes:				for specializing an upper.bound value}c:	THEN.CLONE&MUTATE.2	sub.of		information.slot	instance.of				rhs.func	i.take				symbol	i.give				none	arguments			*rule	my.vars			*newrule *cons *type	algorithm			( do	( bindq *newrule ( new.atom ) )		\ later: new.rul.atom								( copy.frame *rule *newrule )								( REMPROP *newrule 'conjectures )								( bindq *type ( value.of *newrule 'INSTANCE.OF ) )								( add.value *type 'INSTANCES *newrule )								( append.value 'VEHICLE 'MY.RULES *newrule ) \ HACK &&&&								( SET.VALUE *newrule 'gens *rule )								( set.value *rule 'specs *newrule )								( bindq *cons ( value.of *newrule 'my.rhs ) )	\ assumes 1 rhs								( inc.cons.val *newrule *cons )								( set.value *newrule '#tried 0 )								( set.value *newrule '#succeed 0 )								( set.value *newrule 'recent.count 0 )								( set.value *newrule 'worth 100 )								( insert.value *newrule 'my.creator ( @cur.rule ) )								( insert.value *newrule 'my.source *rule ) )\ =============================={	THEN.CLONE&MUTATE.3	description:		decrease the consequent variable	notes:				for specializing a lower.bound value}c:	THEN.CLONE&MUTATE.3	sub.of		information.slot	instance.of				rhs.func	i.take				symbol	i.give				none	arguments			*rule	my.vars			*newrule *cons *type	algorithm			( do	( bindq *newrule ( new.atom ) )		\ later: new.rul.atom								( copy.frame *rule *newrule )								( bindq *type ( value.of *newrule 'INSTANCE.OF ) )								( add.value *type 'INSTANCES *newrule )								( append.value 'VEHICLE 'MY.RULES *newrule ) \ HACK &&&&								( REMPROP *newrule 'conjectures )								( SET.VALUE *newrule 'gens *rule )								( set.value *rule 'specs *newrule )								( bindq *cons ( value.of *newrule 'my.rhs ) )	\ assumes 1 rhs								( dec.cons.val *newrule *cons )								( set.value *newrule '#tried 0 )								( set.value *newrule '#succeed 0 )								( set.value *newrule 'recent.count 0 )								( set.value *newrule 'worth 100 )								( insert.value *newrule 'my.creator ( @cur.rule ) )								( insert.value *newrule 'my.source *rule ) )\ =============================={	THEN.CLONE&MUTATE.4	description:		decrease the consequent variable	notes:				for generalizing an upper.bound value}c:	THEN.CLONE&MUTATE.4	sub.of		information.slot	instance.of				rhs.func	i.take				symbol	i.give				none	arguments			*rule	my.vars			*newrule *cons *type	algorithm			( do	( bindq *newrule ( new.atom ) )		\ later: new.rul.atom								( copy.frame *rule *newrule )								( bindq *type ( value.of *newrule 'INSTANCE.OF ) )								( add.value *type 'INSTANCES *newrule )								( append.value 'VEHICLE 'MY.RULES *newrule ) \ HACK &&&&								( REMPROP *newrule 'conjectures )								( SET.VALUE *newrule 'specs *rule )								( set.value *rule 'gens *newrule )								( bindq *cons ( value.of *newrule 'my.rhs ) )	\ assumes 1 rhs								( dec.cons.val *newrule *cons )								( set.value *newrule '#tried 0 )								( set.value *newrule '#succeed 0 )								( set.value *newrule 'recent.count 0 )								( set.value *newrule 'worth 100 )								( insert.value *newrule 'my.creator ( @cur.rule ) )								( insert.value *newrule 'my.source *rule ) )\ =============================={	THEN.CLONE&MUTATE.5	description:		increase the consequent variable	notes:				for generalizing a lower.bound value}c:	THEN.CLONE&MUTATE.5	sub.of		information.slot	instance.of			rhs.func	i.take				symbol	i.give				none	arguments			*rule	my.vars			*newrule *cons *type	algorithm			( do	( bindq *newrule ( new.atom ) )		\ later: new.rul.atom								( copy.frame *rule *newrule )								( bindq *type ( value.of *newrule 'INSTANCE.OF ) )								( add.value *type 'INSTANCES *newrule )								( append.value 'VEHICLE 'MY.RULES *newrule ) \ HACK &&&&								( REMPROP *newrule 'conjectures )								( SET.VALUE *newrule 'specs *rule )								( set.value *rule 'gens *newrule )								( bindq *cons ( value.of *newrule 'my.rhs ) )	\ assumes 1 rhs								( inc.cons.val *newrule *cons )								( set.value *newrule '#tried 0 )								( set.value *newrule '#succeed 0 )								( set.value *newrule 'recent.count 0 )								( set.value *newrule 'worth 100 )								( insert.value *newrule 'my.creator ( @cur.rule ) )								( insert.value *newrule 'my.source *rule ) )\ =============================={	THEN.SUGGEST.GEN.1	description:		post a task to generalize a rule	notes:				x}c:	THEN.SUGGEST.GEN.1	sub.of		information.slot	instance.of			rhs.func	i.take				symbol	i.give				none	arguments			*rule	algorithm			( make.new.task							'design							'fillin							*rule							'sibling.rule							'( generalize )							( value.of *rule 'worth )	\ higher worth-->higher task priority							( @cur.rule )							'( focus.of.attention ) )\ =============================={	THEN.SUGGEST.SPEC.1	description:		post a task to generalize a rule	notes:				x}c:	THEN.SUGGEST.SPEC.1	sub.of		information.slot	instance.of			rhs.func	i.take				symbol	i.give				none	arguments			*rule	algorithm			( make.new.task							'design							'fillin							*rule							'sibling.rule							'( specialize )							( value.of *rule 'worth )	\ higher worth-->higher task priority							( @cur.rule )							'( focus.of.attention ) )\ =============================={	THEN.SUGGEST.RND.SIB	description:		post a task to clone a rule	notes:				x}c:	THEN.SUGGEST.RND.SIB	sub.of		information.slot	instance.of			rhs.func	i.take				symbol	i.give				none	arguments			*rule	algorithm			( make.new.task							'design							'fillin							*rule							'sibling.rule							'( random )							( plus 600 ( value.of *rule 'worth ) )	\ higher worth-->higher task priority							( @cur.rule )							'( focus.of.attention ) )