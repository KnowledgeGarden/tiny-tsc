{	SailPlane.KB	Complete SailPlane KB	intentions		to implement the first "complete" Eurisko-like KB	dates		04/28/93		first cut, made from sailboat.kb.new		04/30/93		lots of additions		05/18/93		comments}comment:	As a trial, consider using a set of "design" rules to build a sailplane in a given representation scheme; then follow with "refine" rules (the existing ones) to optimize by filling in next episodes.  DESIGN rules would, essentially, build the initial conditions.  That way, initial conditions would be built not by the user or by any random selection of features, but would be built by design rules, e.g. symmetricalize, compose, and so forth.  Then, an optimized design would be refined in a tree.  Once several designs have been developed, a comparative study can be made to ask why this design is better than that one, and reward the design rules that set it up.	This will require more of the eurisko behavior such that once a behavior is called for, e.g. fillin <xx> initial.conditions, several approaches can be taken, some at random, some by worth, and so forth.comment;\ ______________________________________________________________________ BEHAVIORS\ ____________________________________________________________ FILLIN\ ======================={			FILLIN.NEXT.BIRD.EP.1			If your task is to fillin next.design on concept C			Then fillin next design episode on concept C}c:	FILLIN.NEXT.BIRD.EP.1	instance.of					behavior.rule	level						basic	sub.of						compute.process	my.creator					jp2	if.task=						fillin	if.slot=						next.design	if.concept=					*con\	if.param=					sailplane	&&&& this slot requires an additional vector for QPT	then.fillin.bird.1			*con	attach.to					fillin\ ======================={			FILLIN.SIBLING.RULE.1			If your task is to fillin sibling.rule on rule R			And parameter is RANDOM			Then clone R to RC			And randomly change some consequent variable by 10%}c:	FILLIN.SIBLING.RULE.1	instance.of					behavior.rule	level						basic	sub.of						compute.process	my.creator					jp2	if.task=						fillin	if.slot=						sibling.rule	if.concept=					*rule	if.param=					random	then.clone&mutate.1		*rule	attach.to					fillin\ ======================={			FILLIN.SIBLING.RULE.2			If your task is to fillin sibling.rule on rule R			And parameter is SPECIALIZE			And variable bound is UPPER			Then clone R to RC			And increase some consequent variable by 10%}c:	FILLIN.SIBLING.RULE.2	instance.of					behavior.rule	level						basic	sub.of						compute.process	my.creator					jp2	if.task=						fillin	if.slot=						sibling.rule	if.concept=					*rule	if.param=					specialize	if.vbl.bound=				*rule upper	then.clone&mutate.2		*rule	attach.to					fillin\ ======================={			FILLIN.SIBLING.RULE.3			If your task is to fillin sibling.rule on rule R			And parameter is SPECIALIZE			And variable bound is LOWER			Then clone R to RC			And decrease some consequent variable by 10%}c:	FILLIN.SIBLING.RULE.3	instance.of					behavior.rule	level						basic	sub.of						compute.process	my.creator					jp2	if.task=						fillin	if.slot=						sibling.rule	if.concept=					*rule	if.param=					specialize	if.vbl.bound=				*rule lower	then.clone&mutate.3		*rule	attach.to					fillin\ ======================={			FILLIN.SIBLING.RULE.4			If your task is to fillin sibling.rule on rule R			And parameter is GENERALIZE			And variable bound is UPPER			Then clone R to RC			And decrease some consequent variable by 10%}c:	FILLIN.SIBLING.RULE.4	instance.of					behavior.rule	level						basic	sub.of						compute.process	my.creator					jp2	if.task=						fillin	if.slot=						sibling.rule	if.concept=					*rule	if.param=					generalize	if.vbl.bound=				*rule upper	then.clone&mutate.4		*rule	attach.to					fillin\ ======================={			FILLIN.SIBLING.RULE.5			If your task is to fillin sibling.rule on rule R			And parameter is GENERALIZE			And variable bound is LOWER			Then clone R to RC			And increase some consequent variable by 10%}c:	FILLIN.SIBLING.RULE.5	instance.of					behavior.rule	level						basic	sub.of						compute.process	my.creator					jp2	if.task=						fillin	if.slot=						sibling.rule	if.concept=					*rule	if.param=					generalize	if.vbl.bound=				*rule lower	then.clone&mutate.5		*rule	attach.to					fillin\ ____________________________________________________________ STUDY\ ======================={			STUDY.RULE.CONJ.1			If your task is to study a rule.conj on rule R			And R has always decreased performance			Then build an initial conditions frame IC for explaining why R always decreases performance			And suggest fillin next.episode on IC--build an explanation}comment:c:	STUDY.RULE.CONJ.1	instance.of					behavior.rule	level						basic	sub.of						compute.process	my.creator					jp2	if.task=						study	if.slot=						rule.conj	if.concept=					*rule*	if.always.decreases.perf		*rule*	thenxxxx					*rule	attach.to					studycomment;\ ======================={			STUDY.RULE.CONJ.1A			If your task is to study a rule.conj on rule R			And R has always decreased performance			Then suggest fillin sibling.rule on R with parameter RANDOM}c:	STUDY.RULE.CONJ.1A	instance.of					behavior.rule	level						basic	sub.of						compute.process	my.creator					jp2	if.task=						study	if.slot=						rule.conj	if.concept=					*rule	if.conj=						*rule always.increase.performance\ *	if.always.decreases.perf		*rule	then.suggest.rnd.sib		*rule	attach.to					study\ ======================={			STUDY.RULE.CONJ.2			If your task is to study a rule.conj on rule R			And R has always increased performance			Then build an initial conditions frame IC for explaining why R always increases performance			And suggest fillin next.episode on IC--build an explanation}comment:c:	STUDY.RULE.CONJ.2	instance.of					behavior.rule	level						basic	sub.of						compute.process	my.creator					jp2	if.task=						study	if.slot=						rule.conj	if.concept=					*rule*	if.always.increases.perf		*rule*	then.XXX					*rule	attach.to					studycomment;\ ======================={			STUDY.RULE.CONJ.2A			If your task is to study a rule.conj on rule R			And R has always increased performance			Then suggest fillin sibling.rule on R with parameter RANDOM}c:	STUDY.RULE.CONJ.2A	instance.of					behavior.rule	level						basic	sub.of						compute.process	my.creator					jp2	if.task=						study	if.slot=						rule.conj	if.concept=					*rule	if.conj=						*rule always.decrease.performance\ *	if.always.increases.perf		*rule	then.suggest.rnd.sib		*rule	attach.to					study\ ______________________________________________________________________ DESIGNcomment:	for now, we consider three figures: minimum sink, maximum l/d, and speed for max l/d	these three sortof define the bird polar	the idea is this:		to mess with a design			mutate a design			compare polars			if polar improves, reward the design rule			otherwise, lightly punish the design rule		to compare polars			if min sink is lower			and max l/d is higher			and speed for max l/d is higher			then improve	( perf.up)			OR			if max l/d is higher			and speed for max l/d is higher			and min sink is approx same	( e.g. +/- 5% )			then improve	(perf.up)comment;\ ____________________________________________________________ WING\ ======================={			INC.W.SPAN.1			If you want to improve performance of a vehicle			And aspect ratio is not greater than user-specified limit minus bandwidth			Then try increasing wingspan by 10%}c:	INC.W.SPAN.1	sub.of				phys.process	instance.of			process.rule	my.creator			jp2	if.actors			( ( vehicle ( *vr1 ) true ) )	if.within.ar			10	\ bandwidth	if.within.span		10	\ bandwidth	then.inc.w.span	10\ ======================={			INC.W.AR.1			If you want to improve performance of a vehicle			And aspect ratio is not greater than user-specified limit minus bandwidth			Then try increasing wing aspect ratio by 10%}c:	INC.W.AR.1	sub.of				phys.process	instance.of			process.rule	my.creator			jp2	if.actors			( ( vehicle ( *vr1 ) true ) )	if.within.ar			10	\ bandwidth	if.within.span		10	\ bandwidth	then.inc.w.ar		10\ ======================={			INC.W.S.1			If you want to improve performance of a vehicle			Then try increasing wing area by 10% holding aspect ratio constant}c:	INC.W.S.1	sub.of				phys.process	instance.of			process.rule	my.creator			jp2	if.actors			( ( vehicle ( *vr1 ) true ) )	if.within.span		10	\ bandwidth	then.inc.w.s		10\ ____________________________________________________________ TAIL\ ======================={			DEC.TAIL.AREA.1			If you want to improve performance of a vehicle			Then try decreasing  fin area by the suggested amount				try decreasing stab area by the suggested amount				try increasing wing.fin & wing.stab to hold tail volume coef about same		Note: this will have no effect on performance until the simulator accounts for			the changes it makes}c:	DEC.TAIL.AREA.1	sub.of				phys.process	instance.of			process.rule	my.creator			jp2	if.actors			( ( vehicle ( *vr1 ) true ) )	if.above.fin.s		10	if.above.stab.s		10	then.dec.fin.area	10	then.dec.stab.area	10	then.extend.fuse	10\ ======================={			INC.STAB.AREA.1			If you want to improve performance of a vehicle			And simulator has suggested increasing fin area			Then try increasing  fin area by the suggested amount}c:	INC.STAB.AREA.1	sub.of				phys.process	instance.of			process.rule	my.creator			jp2	if.actors			( ( vehicle ( *vr1 ) true ) )	then.inc.stab.area	10\ ======================={			INC.FIN.AREA.1			If you want to improve performance of a vehicle			And simulator has suggested increasing fin area			Then try increasing  fin area by the suggested amount}c:	INC.FIN.AREA.1	sub.of				phys.process	instance.of			process.rule	my.creator			jp2	if.actors			( ( vehicle ( *vr1 ) true ) )	if.suggest.inc.area	5		\ % increase threshold	then.inc.fin.area	10\ ======================={			DEC.FIN.AREA.1			If you want to improve performance of a vehicle			And simulator has suggested decreasing fin area			Then try decreasing fin area by the suggested amount}c:	DEC.FIN.AREA.1	sub.of				phys.process	instance.of			process.rule	my.creator			jp2	if.actors			( ( vehicle ( *vr1 ) true ) )	if.suggest.dec.area	5		\ % decrease threshold	then.dec.fin.area	10\ ______________________________________________________________________ EXPLANATION\ will need deep domain physics stuff\ ______________________________________________________________________ META\ __________________________________________________________SENSE\ ======================={			TERMINATE.DESIGN.BRANCH.1			If you have just simulated			And some design action results in reduced performance			Then terminate the branch			And reduce worth of the design rule&&&& this rule prevents the conjecture that a design rule always decreases performance &&&&}c:	TERMINATE.DESIGN.BRANCH.1	sub.of			phys.process	instance.of		SENSE.RULE	my.creator		jp2	if.actors		( ( vehicle ( *vr1 ) true ) )	if.compute		( perf.down? new.ep? )	then.terminate	expansion\ ======================={			TERMINATE.DESIGN.BRANCH.2			If you are extending a tree branch			And #episodes made is greater than max#episodes allowed			Then terminate the branch}c:	TERMINATE.DESIGN.BRANCH.2	sub.of			phys.process	instance.of		SENSE.RULE	my.creator		jp2	if.actors		( ( vehicle ( *vr1 ) true ) )	if.compute		( too.many.eps? )	then.terminate	expansion\ ======================={			REWARD.DESIGN.ACTION.1			If you have just simulated			And some design action results in increased performance			Then increase worth of the design action by 10 units}c:	REWARD.DESIGN.ACTION.1	sub.of			phys.process	instance.of		SENSE.RULE	my.creator		jp2	if.actors		( ( vehicle ( *vr1 ) true ) )	if.compute		( perf.up? new.ep? )				\ may need some work &&&&	then.reward.1	mechanism\ ======================={			DESIGN.CONJ.1			If you have just simulated			And some design action has resulted in increased performance in several episodes			Then conjecture the design action will always improve performance			And suggest studying the conjecture}c:	DESIGN.CONJ.1	sub.of				phys.process	instance.of			SENSE.RULE	my.creator			jp2	if.actors			( ( vehicle (*vr1 ) true ) )	if.compute			( multi.perf.up? )	then.conj.1			always.increase.performance	\ form conj and suggest study\ ======================={			DESIGN.CONJ.2			If you have just simulated			And some design action has resulted in decrease performance in several nodes			Then conjecture the design action will always decrease performance			And suggest studying the conjecture}c:	DESIGN.CONJ.2	sub.of				phys.process	instance.of			SENSE.RULE	my.creator			jp2	if.actors			( ( vehicle (*vr1 ) true ) )	if.compute			( multi.perf.down? )	then.conj.1			always.decrease.performance	\ form conj and suggest study\ ____________________________________________________________ DOMAIN\ ______________________________________________________________________ POST-MORTEM\ these deal with looking at a task just completed to see what happened\	which includes looking at all the various rules which were tried\ ======================={			SUGGEST.SPECIALIZE.RULE.1			If you have a rule R			And it is successful more than 80% of the time--note lower bound			Then suggest fillin sibling.rule on R with parameter SPECIALIZE}c:	SUGGEST.SPECIALIZE.RULE.1	instance.of			behavior.rule	vbl.bound			upper	attach.to			post-mortem	if.rule=				*rule	if.success>			*rule 80			\ not mutible yet	then.suggest.spec.1	*rule\ ======================={			SUGGEST.GENERALIZE.RULE.1			If you have a rule R			And it is successful less than 20% of the time--note upper bound			Then suggest fillin sibling.rule on R with parameter GENERALIZE}c:	SUGGEST.GENERALIZE.RULE.1	instance.of			behavior.rule	attach.to			post-mortem	vbl.bound			lower	if.rule=				*rule	if.success<			*rule 20			\ not mutible yet	then.suggest.gen.1	*rule