/* ========================================	PatRec.body.c	in TSC, we used a frame as follows as a data source:	C:	PDBTEST1		name			TESTPRO1		level			basic		instance.of		protein		functionality		none		source			design.pro		my.data			( ACE ALA PHE ALA GLY VAL LEU THR ALA SER 						VAL ASN CYS ALA LYS ASN ALA LYS ASP LEU 						ILE LEU GLN GLY  ASP GLN ALA THR ASN ARG 						ASN LEU SER ASN THR THR ALA SER VAL ASN 						CYS ALA LYS ILE THR LYS PRO SER GLU SER )		helix.position		( ( 8 15 ) ( 36 43 ) )		sheet.position		( ( 19 25 ) ( 27 31 ) )	The code here approaches a similar database entry architecture.	A protein data file, for this system, is organized as follows:	text, tab delimited, one protein per file	numaminos numhel	numbet	numcoil	<cr>	amino1 amino2 ... aminox <cr>	aminox+1...aminon	<cr>	hstart1 hend1 ... hstartx hendx <cr>	hstartx+1 hendx+1...hstartn hendn <cr>	if no helices, line of 0 0 <cr>	bstart1 bend1 ... bstartx bendx <cr>	bstartx+1 bendx+1...bstartn bendn <cr>	if no betas, line of 0 0 <cr>	chstart1 cend1 ... cstartx cendx <cr>	cstartx+1 cendx+1...cstartn cendn <cr>	if no coils, line of 0 0 <cr>A typical training or testing setup file looks like:pdb3pdb7pdb9NOTE:	the phrase 2' structure refers to a structure which is alpha helix, beta sheet, or coil	a "focus" in a protein is a window of amino acids centered on a particular amino acid	a "feature" is a 2'structure=========================================== */// ______________________________________________________________________ INCLUDES#include <string.h>// #include <Memory.h>#include <math.h>#include "PatRec.body.h"// ______________________________________________________________________ STRUCTURESshort	testWindow	[2*WINDOWRADIUS+1];		// window from test datashort	testStruct		[MAXNUMAA];				// predicted structureshort	actualStruct	[MAXNUMAA];				// actual structureshort	numPros;char		*aax	[3];	// ______________________________________________________________________ STRUCTSFILE	*theLog;			// the log file handleFILE	*TrainData;			// raw dataFILE	*TestData;			//FILE	*TrainSetup;FILE	*TestSetup;// ______________________________________________________________________ GLOBALSchar *features		[FEATURECOUNT]	= { "A", "B", "C", "U" };char  *dataSymbols 	[AACOUNT]	=  {   "GLY", "ALA", "VAL", "LEU", "ILE", "SER", "CYS", "THR", "MET", 								  "PHE", "TYR", "TRP", "PRO", "HIS", "LYS", "ARG", "ASP", "GLU", 								  "ASN", "GLN" };// ______________________________________________________________________ LOCAL PROTOSshort	convertToSym	(void);short	whichFeature	(ProStruct *thePro, short pos );short	predictWindow	(void);void	initAASlots		(void);void	countAA			(void);// ______________________________________________________________________ CODE// ____________________________________________________________ readData// clear out protein databasevoid	clearData		(ProStruct *RawDataH){	short	i, j;	for	( i = 0; i <  MAXNUMPROS; i++ )	{		RawDataH[i].numAminos = 0;		RawDataH[i].numHels = 0;		RawDataH[i].numBets = 0;		RawDataH[i].numCoils = 0;		for	( j = 0; j < MAXNUMAA; j++ )			RawDataH[i].AAV[j] = NONSENSE;		for	( j = 0; j < NUMSTRUCTS; j++ )		{			RawDataH[i].hel[j].start = 0;			RawDataH[i].hel[j].end = 0;		}		for	( j = 0; j < NUMSTRUCTS; j++ )		{			RawDataH[i].bet[j].start = 0;			RawDataH[i].bet[j].end = 0;		}		for	( j = 0; j < NUMSTRUCTS; j++ )		{			RawDataH[i].coil[j].start = 0;			RawDataH[i].coil[j].end = 0;		}	}}// convert an amino acid 3-chr name to a symbolshort	convertToSym	(  ){	short	i;	for	( i = 0; i < AACOUNT; i++ )	{		if	( memcmp(aax,  dataSymbols[i], 3) == 0 )			return i;	}	return unk;}// read protein data from one filevoid	readData (FILE *theFile, short which, ProStruct *RawDataH){	short	scanCode = 0,  j, dataCount = 0, sym;	printf("READING DATA ########\n");	// first line is counts	scanCode = fscanf(theFile, "%d %d %d %d",				&RawDataH[which].numAminos,				&RawDataH[which].numHels,				&RawDataH[which].numBets,				&RawDataH[which].numCoils );	for	( j = 0; j < RawDataH[which].numAminos; j++ )	{		scanCode = fscanf(theFile, "%s", aax);		if	( scanCode != EOF )		{			sym = convertToSym();			if	( sym < AACOUNT )				RawDataH[which].AAV[j] = sym;			else			{				printf("#### Couldn't convert an amino %s\n", aax);				break;			}		}		else			break;	}	for	( j= 0; j < RawDataH[which].numHels; j++ )	{		scanCode = fscanf(theFile,"%d", &RawDataH[which].hel[j].start);		scanCode = fscanf(theFile,"%d", &RawDataH[which].hel[j].end);	}	for	( j= 0; j < RawDataH[which].numBets; j++ )	{		scanCode = fscanf(theFile,"%d", &RawDataH[which].bet[j].start);		scanCode = fscanf(theFile,"%d", &RawDataH[which].bet[j].end);	}	for	( j= 0; j < RawDataH[which].numCoils; j++ )	{		scanCode = fscanf(theFile,"%d", &RawDataH[which].coil[j].start);		scanCode = fscanf(theFile,"%d", &RawDataH[which].coil[j].end);	}}// ____________________________________________________________ Setup// in which we read the setup files which give training and testing protein file namesshort	getTrainSetup	( ){	short	nums = 0;	while	(fscanf(TrainSetup, "%s", &(*TrainFilesH)->files[nums].fname) != EOF)		nums++;	(*TrainFilesH)->numfiles = nums;	return nums;}short	getTestSetup	( ){	short	nums = 0;	while	(fscanf(TestSetup, "%s", &(*TestFilesH)->files[nums].fname) != EOF)		nums++;	(*TestFilesH)->numfiles = nums;	return nums;}	/* ------------------------------------------- predictWindow	take testWindow and find the exemplar that best matches it-------------------- */short	predictWindow	( ){	short	i, pos, winlength = 2*WINDOWRADIUS + 1, minexemp, aa1, aa2;	long double	sum, minsum = 99999.9 ;		for	( i = 0; i < (*ExemplarH)->numExemplars; i++ )	// for each exemplar	{		sum = 0;		// given an exemplar, ripple along its window comparing window elements		//	by summing the deltas		for	( pos = 0; pos < winlength; pos++ )	// for each window position		{				aa1 = (*ExemplarH)->exemplars[i].theWindow[pos];			aa2 = testWindow[pos];			if	( aa1 != aa2 )				sum += (*AminoFrameH)[aa1].ratios[aa2].delta[pos];		}		if	( sum < minsum )		{			minsum = sum;			minexemp = i;		}	}	return (*ExemplarH)->exemplars[minexemp].myPrediction;}/* ------------------------------------------- studyProtein	ripple along a test protein, get predictions for each window--------------------- */void	studyProtein ( short whichpro){	short	i, j, winlength = 2*WINDOWRADIUS + 1, len;	long double	cor, ctrt;		printf("Studying Protein %d\n", whichpro);		len = (*TestDataH)[whichpro].numAminos - 2*WINDOWRADIUS;	for	( i = 0 ; i < len; i++ )	// for each possible focus	{				// get a window of data		for	( j = 0; j < winlength; j++ ) 	// for each window position			testWindow[j] = (*TestDataH)[whichpro].AAV[j+i];					// predict structure represented at the focus (center) of this window		//	 notice we are just saving predictions: they are not saved at the		//	absolute amino location (which would be offset by windowradius) in protein		testStruct[i] = predictWindow();		actualStruct[i] = 				whichFeature(&(*TestDataH)[whichpro], i+WINDOWRADIUS);	}	// testStruct now filled with structure prediction	// actualStruct now filled with what structure is reported to be	// print both to log		for	( i = 0; i < len; i++)		fprintf(theLog, "%s", features[testStruct[i]]);	fprintf(theLog, "  test\n");		for	( i = 0; i < len; i++)		fprintf(theLog, "%s", features[actualStruct[i]]);	fprintf(theLog, "  actual\n");		// calculate %right and print to log	ctrt = 0.0;	for	( i = 0; i < len; i++ )	{		if	( testStruct[i] == actualStruct[i] )			ctrt++;	}	cor =  ctrt / len;	printf("  Percent Correct = %Lg %d %Lg\n", ctrt, len, 100.0 * cor);	fprintf(theLog, "  Percent Correct = %Lg %d %Lg\n", ctrt, len,  100.0 * cor);}// given a position in a protein, see which feature it is in.  It has to be in one of the three typesshort	whichFeature	( ProStruct *thePro, short pos ){	short	i, which = unk;	for	( i = 0; i <  thePro->numHels; i++ )		// for each possible helix 	{		if	( pos >= thePro->hel[i].start &&				pos <= thePro->hel[i].end )		{			which = alpha;			break;		}	}	if	( which == unk )	{		for	( i = 0; i < thePro->numBets; i++ )	// for each possible sheet		{			if	( pos >= thePro->bet[i].start &&					pos <= thePro->bet[i].end )			{				which = beta;				break;			}		}	}	if	( which == unk )	{		for	( i = 0; i < thePro->numCoils; i++ )	// for each possible turn		{			if	( pos >= thePro->coil[i].start &&					pos <= thePro->coil[i].end )			{				which = cturn;				break;			}		}	}	return which;}/* ===========================	COUNT.AA'S	Call INIT.AA.SLOTS to initialize the 	FEATURE.COUNT, ALPHA.COUNT, BETA.COUNT &  COIL.COUNT 	slots of each AA to ( 0 0 ... 0 ) 		where the length of this list is given by *win.length.  	Then for each AA in each of the proteins used for training 	examine the window determined by this AA and *win.rad:		1. Increment the ith entry of the FEATURE.COUNT slot of the AA in window		position i.		2. If the window is centered on an AA which is part of a particular 2' structure, 		increment the ith entry of the corresponding slot of the AA in window position		 i and set the feature flag.		3. Create an exemplar from the window, the current value of 2'struct and the		exemplar weight ( initiallly set to 1 ) and place it on *exemplar.list.		e.g.:	 ( window weight feature )				( ( gly glu pro ... ) 1 B )============================== */void	initAASlots	( ){	short	i, j, winlength = 2 * WINDOWRADIUS+1;	for	( i = 0; i < AACOUNT; i++ )	{		for	( j = 0; j < winlength; j++ )		{			(*AminoFrameH)[i].featureCount[j] = 0;			(*AminoFrameH)[i].alphaCount[j] = 0;			(*AminoFrameH)[i].betaCount[j] = 0;			(*AminoFrameH)[i].coilCount[j] = 0;		}	}}/* ===================================the general algorithm we are solving is for the "distance" between two aminos	for each window position		for each amino acid			for each feature (alpha, beta, coil)				ratio1 +=  #occurances in this position / #occurances			for each other amino acit				for each feature (alpha, beta, coil)					ratio2 +=  #occurances in this position / #occurances				big ratio(1,2) = | ratio1 - ratio2 |				( note, for euclidian distance, you square bigratio					for manhattan distance, don't square it)===================================== */		void	countAA	(void){	short	AA, feature, pos, i, j, k, winlength = 2*WINDOWRADIUS+1, exemp;	short	numexemps;	long double	ratio1, ratio2, denom;	initAASlots();	// clear amino acid "frames"	// count all occurances	for	( i = 0; i <  numPros; i++)	// for every training protein		{		(*ExemplarH)->numExemplars = 0;		numexemps = (*TrainDataH)[i].numAminos - 2*WINDOWRADIUS;		// for every focus in ith protein	(read: for every exemplar)		for	(exemp = 0; exemp < numexemps; exemp++ )		{	// a focus centers at exemp + WINDOWRADIUS			feature = whichFeature( &(*TrainDataH)[i], exemp+WINDOWRADIUS);			// now know what 2struct this focus is in			// make an exemplar out of this location			(*ExemplarH)->exemplars[exemp].myPrediction = feature;			for	( pos = 0; pos < winlength; pos++ )		// for each window position			{				// fill in the window				AA = (*TrainDataH)[i].AAV[exemp+pos];				(*ExemplarH)->exemplars[exemp].theWindow[pos] = AA;				// increment counters				(*AminoFrameH)[AA].featureCount[pos]++;				if	( AA == alpha )					(*AminoFrameH)[AA].alphaCount[pos]++;				else if ( AA == beta )					(*AminoFrameH)[AA].betaCount[pos]++;				else					(*AminoFrameH)[AA].coilCount[pos]++;			}			(*ExemplarH)->numExemplars++;		}	}	// now calculate ratios	& deltas	for	( pos = 0; pos < winlength; pos++ )		// for each window position	{		for	( j = 0; j < AACOUNT; j++ )		// for each amino acid		{			if	( denom = (*AminoFrameH)[j].featureCount[pos] > 0 )			{				ratio1 = (*AminoFrameH)[j].alphaCount[pos] / denom +						(*AminoFrameH)[j].betaCount[pos] / denom +						(*AminoFrameH)[j].coilCount[pos] / denom;			}			else				ratio1 = 0;			for	( k = 0; k < AACOUNT; k++ )		// for every other amino			{				if	( k != j )				{					if	( denom = (*AminoFrameH)[j].featureCount[pos] > 0 )					{						ratio2 = (*AminoFrameH)[k].alphaCount[pos] / denom +								(*AminoFrameH)[k].betaCount[pos] / denom +								(*AminoFrameH)[k].coilCount[pos] / denom;					}					else						ratio2 = 0;					if	( ratio1 > 0 && ratio2 > 0 )						(*AminoFrameH)[j].ratios[k].delta[pos] = fabs( ratio1 - ratio2 );	// delta					else						(*AminoFrameH)[j].ratios[k].delta[pos] = 0;				}			}		}	}}/* -------------------------------------------- trainPatRec	workhorse for setting up arrays from raw data-------------------------------- */void trainPatRec	( ){  	printf("Training the System\n");	printf("  Window radius = %d \n", WINDOWRADIUS );	countAA();	printf("Training Done.\n");}