A View of Discovery for Science and Engineering with TSCªJack ParkThinkAlong Software Inc.Brownsville, CAjackpark@netcom.comAbstractWe discuss discovery of materials properties from the point of view of the Database, with emphasis on the communication of information by means of a Visual Programming Language.  We illustrate a visual programming language, and extend that example to show how the TSC environment, in a technical domain, can apply a visual language to all of the activities in that domain.IntroductionThis document outlines our views on the application of The Scholar's Companionª (TSC) to the domains of science and engineering.  TSC is a discovery system, designed for a variety of kinds of discovery projects.  These range from database mining, to conducting experiments (or analyzing the results of those experiments), to pedagogical discovery projects.TSC is implemented in a combination of environments: Think C, and Prograph CPX.  These environments provide the necessary tools to build a large, complex artificial intelligence application, which TSC is.  Indeed, much of what CPX offers, we are adapting to TSC itself.A Systems ViewDiscovery plays a role in the design, manufacturing, and application of products in any domain.  This is illustrated in figure 1.  The figure takes a database centered view of the flow of information in some domain.  The key points are simply that all of the processes involved in this domain start with the database, and all of the elements of the domain contribute back to the database.Figure 1:  An Arbitrary Technical DomainThis paper discusses each of these elements, from the point of view of communication of the information in this universe.  This communication calls for a discussion of the syntax, semantics, and vocabulary of communicationÑthe language of the domain.Any discussion of a language calls for a discussion of the ontology  on which the language is built.  Ontologies have been characterized as the "furnature" of the domain, furnishing an environment rich enough to support dialogs which occur in that environment [Bunge, XXXX].Finally, we discuss the kinds of natural languages possible in the domain.  In this paper, we discuss two kinds of natural languages: textual and visual.  We postulate that an ideal avenue for discovery, indeed, all of activities in any domain, is a visual, sometimes called graphical language.OntologiesTo be expanded...Natural LanguagesTextualIn TSC, a concept, when viewed in its textual format, takes the form of a frame as illustrated here:c:	Slot	sub_of	Relation	...Such a frame may also be viewed in a visual format as we do below.This is the frame for a concept called Slot.  A concept is the TSC equivalent of a class.  A frame has the components: a name, and some slots.  Thus, this is the defining frame for the concept Slot, which itself has instances of slots.VisualVisual, aka graphical representations can take many forms.  They include sketches, pictures, and icons.  The discussion here is focussed on the icon form of  graphical representation, and programming with that form.At root, the icon programming approach involves selection of icons which have a known semantics, and "wiring" them together to reveal an algorithm designed by the programmer.  In an artificial intelligence application, such as TSC used as a discovery system, icons define several kinds of concepts (or objects): entities, relations, states, and process rules.  Refer to the discussion on the TSC Ontology elsewhere.DatabasesThe message in Figure 1 is that all activities in a domain supply information to the database.  What we call The Database here may, in fact, be several different databases.One thesis of this paper is that discovery power resides in the database.  Without it, no matter how powerful the algorithms of the discovery engine, no discovery of substance will occur.Visual LanguagesPortions of the following discussion are adapted from [Park, 1994].Another thesis of this paper is that a visual (graphical) programming environment is the future of all scientific and technical programming.  Thus, the visual vocabulary discussed here applies to discovery, design, manufacturing, and even application.Prograph ExampleLet us, for overview, look at what Prograph CPX does.  First, here is an image of a Notebook Window in TSC.This window is, in fact, a reusable object in the CPX environment.  It can be cloned and used in any CPX project.  The window is, in fact, a class  in CPX.  Here is a view of its implementation.The image conveys the idea that it is a subclass of another class called Hierarchical Text Window.  The icon for that class has a dark arrow pointing down, to indicate it is an alias for the actual class instance which is defined in another section of the program.  A CPX section is analogous to a TSC Notebook, described below. In CPX, as in TSC, duplicate names are not allowed.  If you wish to use an existing class in a location other than where it was defined, you must use an alias of it.  Further, classes in CPX are almost always "reusable objects"; since you can alias them elsewhere, they can be used elsewhere.  It's a natural outgrowth of this object-oriented environment, and TSC applies the same notions.Notice that the class icon has two halves, separated by a vertical line.  One side has a triangular icon, the other has a squarish icon.  These mean something.  Click on the left half and here is what you get:These are the attributes of the class.  By way of analogy to a TSC frame, they are the slots and their values.  Thus, it can be said that a class  in CPX is analogous to a TSC frame.  Any concept (TSC's version of a class) gets slots in its attribute half of the icon.Click the right half of the class and here is what you get:This is a list of all of the special methods this class has.  Of course, this class inherits all of the methods of the classes above it in that branch of a tree.  These methods are simply those which make this class special.  Let us look at one of the methods:This method is rather simple.  Called by clicking the Tutorial button in the Notebook Window, this method simply creates a run-time instance of TutorialWin, and opens that window.  Thus, clicking the Tutorial button immediately gets you a Tutorial Window open and in front of the Notebook you were working in.  The Open routine for the Tutorial Window is coded to open a TutorialBase (disk file) and fill the window with information.TSCIntro to TSC Knowledge BasesNotebooksAll concepts in TSC are organized in Notebooks.  These are similar in nature to the Notebooks of Mathematica [Wolfram, XXXX].  In fact, the entire of a Notebook, is a recognition that scientists and engineers maintain a personal notebook, sometimes called a Journal, or Lab Book.  There are four kinds of Notebooks in TSC: Basics, Library, User, and Project.In the Basics Notebook, all of the support knowledge which develops the TSC ontology is provided.  Every TSC project will, at the least, require the Basics Notebook.  All other Notebooks layer over the top of the Basics.Library Notebooks are those topical notebooks which extend the Basics to cover specific kinds of knowledge domains, e.g. Thermodynamics, Physics, and so forth.  Library Notebooks are built by ThinkAlong, and by users.  They may be made available on a public or private basis.User Notebooks are those specific topic knowledge bases which support a user's project.  They may be converted to Library Notebooks at will.Project Notebooks bring together all of the knowledge, applying it to some specific project.  There are templates supplied with TSC for a variety of kinds of projects, e.g. Data Mining, Process Control, and so forth.  Prior to execution of a Project, no new knowledge is built in the Notebook.  Only concepts which are defined in some other Notebook may be used, as aliases, as the defining object on which instances are defined in the Project. Results of a Project returns to its Notebook.  This includes any graphical plots of data, any new concepts invented (discovered) during the session, and so forth.  New knowledge may then be copied to a User Notebook and made available to future exercises.TSC  OntologyTSC implements a particular kind of ontology, called Qualitative Process Theory (QPT) [Forbus, XXXX].  There are several variants of qualitative reasoning ontologies discussed in the literature, and they resolve to two kinds of centering: process and entity.  The particular variant we have chosen is of the class Process Centered Ontology.  That is, the TSC ontology encourages discussion of the processes which may be experienced by entities.In order to implement such an ontology, we have adapted an approach suggested by the theater: we draw from the notion of a stage as a metaphor for our implementation.Stage MetaphorConsider the stage in a theater.  What do you see on that stage during a production?  You see not only actors and  props, but you see them standing in relation to each other, and you see them in various states.  In fact, you see those states and relations change from time to time, according to a script.We call the history of events on stage an envisionment.  Each time-step in that envisionment is called an episode.  Thus, the totality of a TSC envisionment maps to all the possible readings of a script, given that script has choices scattered about.  An envisionment is, thus, all possible "chronicles" of the actors.actorsIn TSC, actors are precisely those entities set on a stage.  They play different roles on that stage.  These roles resolve, ultimately, to three kinds:  agent, patient, and prop (support).  In fact, the role played by any individual can change along the envisionment; an agent can become the patient of some other agent, and so forth. Each actor is, itself, an instance of some concept in TSC.  The concept can be any concept, including both animate and inanimate concepts.relationsThere is an enormous number of relationships that can form between actors.  They resolve to the following kinds of relations: spatial, temporal, causal, and part-whole.  Spatial relations resolve to subspecies: location and containment.  Temporal relations include the notions of before, after, during, and numerous subspecies of those.Causal relations are those in which processes (see below) are involved.statesFrom the stage metaphor, it is easy to visualize some actor as angry, as frightened, or as happy, and so forth.  Mapping that to the TSC domain, indeed, those very states might apply when a TSC project has human actors to consider.States, in technical domains, include many of the rates of change experienced in a domain.  These include the derivatives of many of the sensible values the actors can experience: temperature, pressure, position, and so forth.  And, they can include the second derivatives, such as accelerating, decelerating, steady, and so forth.processesScripts from the stage, in some sense, map directly to process rules in TSC.  Depending on the granularity one wishes to break a universe down to, there is a process rule to describe every observable event.  To break that statement down to an example, consider a simple transaction:  an individual buying something from another individual.This transaction, at its highest level (grainiest) is simply the transaction itself.  A process rule for that might look like the following:If there are two individualsAnd one has an objectAnd the other has moneyAnd the other wants the objectAnd one wants the moneyThen one has the money and no longer has the objectAnd the other has the object and no longer has the moneyWe can refine this rule to a constellation of finer-grained rules dealing with all the micro-activities involved, like reaching for a wallet, pulling a wallet out of a pocket, opening the money pocket of the wallet, and so forth.  It should be clear that knowledge of any physical process can be refined to any desired level of granularity.Intro to TSC Visual Programming The entire notion of a visual language, whether for TSC, or any other program environment, calls for the ability to extend the vocabulary.  Indeed, the TSC vocabulary of concepts is extensible, and its visual vocabulary is deemed equally extensible.  TSC will provide an icon-building window such that a new icon can be built by any user, and used immediately in a project.  The icon identifier will then be associated with the concept for which it stands (e.g.  process rule) by being made the value of a my.icon slot. ConceptsIt seems reasonable that a TSC frame would have slots, and possibly could have methods as well.  This would imply that TSC will come with a rich body of canned methods to do special things so a knowledge programmer can attach some of those methods to some of the new concepts.  All concepts would inherit a variety of methods directly from the roots of the trees.  Inherited methods would include pretty-printing the frame structure, displaying a concept tree, creating new concepts. In TSC, the primitive super concept is Root.  Every concept in TSC has to be a sub of something else.  There are five major trees growing from Root: Thing, Stuff, Idea, Datatype, and Recipe.To see how the CPX illustration above might map to a TSC KB, consider this sketch, which illustrates the nature of contents of a Basics Notebook:This "wiring diagram" clearly shows the concept Slot as a sub of the concept Relation which, itself, is a sub of the concept Idea.   Idea is one of the primary "trees" in TSC, so it is a sub of the primitive concept Root.Note that concepts are represented by an icon with names just outside the symbol.ActorsEach TSC concept has the capacity to play an actor role in a TSC Project.  Our concern here is the kinds of icons each different roll will assume.  Here, we discuss and illustrate with crude sketches, the different kinds of icons to be used.  The actual icons finally used are still subject to design.  Note, the "icons" for actors will actually be graphic sprites with the name typed inside.  Thus, each will be selected from a pallet dragged and dropped into the image and a name typed inside.agentsThe intent of an agent icon is to convey the essence of this actor: the aggressor, the individual which does some action or causes some change in an episode.  Thus, the icon is somewhat tallish, if not square:patientsThe patient icon conveys the essence of this actor: the receiver of the aggression, the object which experiences the change.  Borrowing from the image of a patient laying on a surgical gurney, we get:supporting conceptsThe supporting concept icon conveys the image of strength; these are the actors in an episode necessary to the process, but neither an agent or patient:RelationsRelations are to be the arcs (wires) which connect actors.  Thus, if an actor abuts a patient, we would get the following kind of wiring diagram:The illustration is taken from the domain of immunology.  Notice that the wiring diagram applies instances rather than the defined concepts.  A process rule using this particular arrangement might look like:If an actor is a stimulated macrophageAnd an actor is cytokinesAnd an actor is viral antigenAnd macrophage abuts cytokinesAnd macrophate abuts viral antigenThen macrophage ingests viral antigenStatesIt is expected that there will be variants of the different actor icons, each reflecting some kind of state the actor can be in.  This still requires much thinking.Science and EngineeringFor science and engineering, an entire vocabulary of icons is anticipated.  These will cover issues of design, manufacturing, and application.  Specific manufacturing processes will have process rules in the TSC ontology, and will have their own custom icon.Programming by ExampleThe ability to "program by example" means that you build diagrams of the stage, before and after, in the case of rules, and you design a database and assemble the tasks to fill that database in the case of projects.Rule CreationConsider this rule illustrated above:If an actor is a macrophageAnd an actor is cytokinesAnd an actor is viral antigenAnd macrophage abuts cytokinesAnd macrophate abuts viral antigenThen macrophage ingests viral antigenHow might such a rule be constructed?  TSC offers two ways:¥ textual creation of a rule¥ graphic creation of a rule by exampleProgramming by example is the topic of this section.  We begin by looking at all the antecedents (IF statements).  Let us look at them by example.First, we need an actor which is a macrophage.  We also need an actor which is a cytokine.  And we need an actor which is antigen.  Let us look at the processes by which these actors come about.  We know the following rule:If an actor is viral antigenAnd an actor is a macrophageAnd antigen abuts macrophageThen macrophage is stimulatedGraphically, this appears as:Here, the viral antigen assumes the role of agent, and macrophage assumes the roll of patient.   The rule makes a change to the actors: macrophage.01 becomes stimulated macrophage.01.NOTE: stimulated macrophage can either be a sub of macrophage, with its own actor as illustrated, or it could be just macrophage with some special icon identifier to show it is in the stimulated state.  For now, as illustrated appears to be the right way to go.Next, we consider this rule:If an actor is a stimulated macrophageThen macrophage secretes cytokinesGraphically, this tiny rule appears as:The stimulated macrophage has secreted a new actor: cytokines 23.Finally, we consider the main rule listed above.Cytokines are seen in a supporting role, with stimulated macrophage abuting antigen.  The result is that stimulated macrophage has ingested antigen.NOTE: this is awkward.  It might be better if there were an intermediate view and a result view.  In the intermediate view, macrophage links to antigen with an "ingests" link.  You can tell who ingests whom by differentiating between agent and patient. This is illustrated below.In all of the rules illustrated, the actors are seen by their placement on the diagram.  There is no need to individually identify the actors, as is required in the textual rule design.  TSC automatically translates this diagram into the textual version, and that is stored in the notebook.Project CreationProject creation involves the following general steps:1-	design a database as a data source2-	design a database as a destination3-	design the experimentEach of these is (will be) illustrated here.ReferencesBungeForbusPark, Jack, "TSC Graphical Rep", ThinkAlong internal document, 1994.Wolfram In CPX, you just enter a section window (akin to a TSC Notebook) and command-click somewhere in the window.  Presto, you get a new unnamed concept.  Type in a name and now you have a full-fledged conceptÑthat is, full fledged once you wire it to a super concept. Materials Discovery      (rough draft)	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   