{	PopSimVars.4description:	PopSim version of the HLL file VARIABLES.4.  This was created so the				PopSim translator could work with local and global bindings without				conficting with other TSC operations.need to do:		xto improve:		xPROBLEMS:		xnotes:			x=== PLEASE FORMAT THIS doc with Monaco Font, tab stops 4, 9 pt, Margin 100, Reduced 73 %.=== ANNOTATION: #### = HACK, ???? = QUESTION, **** = UNTESTED, $$$$ = TO-DO, &&&& = NOTECHANGES:}decimal\ ______________________________________________________________________ globalsanchor			PS.&LOCAL.MATCHES		\ the local variable bindings list, a stack of a-listsanchor			PS.&GLOBAL.MATCH		\ the global variable list, a single a-list\ ______________________________________________________________________ LOCAL VARIABLES{These are not used for compiled routines, but they are used for various matching needs.}: PS.PUSH-BINDINGS	( list -- )				PS.&LOCAL.MATCHES cons to-anchor PS.&LOCAL.MATCHES				;: PS.GET-BINDINGS	( -- list )				PS.&LOCAL.MATCHES first				;: PS.POP-BINDINGS	( -- list )				ps.get-bindings				PS.&LOCAL.MATCHES rest to-anchor PS.&LOCAL.MATCHES				;\	don't need to put the list back: this is surgical\	might rewrite it as:\	pop-bindings drop push-bindings: PS.PUT-BINDINGS	( list -- )				PS.&LOCAL.MATCHES car!				;: PS.INIT-BINDINGS	( -- )				nil to-anchor PS.&LOCAL.MATCHES				;: PS.!BINDQ		( value variable -- ) \ set value for atom. stack is set up like "!"				dup ?symbolvar 0=				IF		error> ." PS.!BINDQ: Supposed to have a symbolvar: "						swap .SX/NF space .SX/NF ABORT				THEN				dup ps.get-bindings assoc ?dup				IF										\ s: value var binding						nip swap						\ s: binding value						>list							\ s: binding (value)						swap cdr!	\ patch in new 2nd	\ s:						EXIT				THEN									\ s: value atom						swap >list						\ s: atom (value)						cons							\ s: (atom value)						ps.get-bindings cons ps.put-bindings	\ s:				;: PS.BINDQ			( variable value -- )	\ interpreted version				swap ps.!bindq				;: PS.+!BINDQ		( value variable -- )	\ adds a binding				dup ?symbolvar 0=				IF		error> ." PS.+!BINDQ: Supposed to have a symbolvar: "						swap .SX/NF space .SX/NF ABORT				THEN				dup ps.get-bindings assoc				\ s: value var assoclist				?dup				IF		nip								\ s: value assoclist						tuck second						\ s: assoclist value bindings						eunion							\ s: assoclist bindings'						swap cdr car!	\ patch in 2nd	\ s:						EXIT				THEN									\ s: value var						swap >list >list				\ s: var ((value))						cons							\ s: (var (value))						ps.get-bindings cons ps.put-bindings	\ s:				;: PS.?VARIABLE		( c -- val T | F )			\ called by match.atom in MATCHING.4				dup ?symbolvar				IF		ps.get-bindings assoc						+IF		second						THEN	true	( return val T or NIL T )		EXIT				THEN drop false ( return F )				;: PS.SHOW.BINDINGS ( -- )				ps.get-bindings ( not-null )				IF		ps.pop-bindings dup ps.push-bindings				THEN	.sx				;\ ______________________________________________________________________ GLOBAL VARIABLES: PS.INIT.GLOBAL	( -- )				nil to-anchor PS.&GLOBAL.MATCH				;: PS.!SETQ			( value variable -- )		\ NOTE STACK ORDER: IT'S ....SX *VARIABLE....				dup PS.&GLOBAL.MATCH assoc ?dup				IF		( s: value atom binding ) nip swap >list swap cdr!		EXIT				THEN	( s: value atom ) swap >list insert						PS.&GLOBAL.MATCH insert to-anchor PS.&GLOBAL.MATCH				;: PS.SETQ			( variable value -- )		\ interpreted version				swap ps.!setq				;