{	PopSim.Translate.4description:	Words used to translate and send TSC experiment frames to the PopSim Server.need to do:	Provide defaults - or report error - for missing property values.  Some of this has been done.				Need to discuss policy for error detection, reporting, recovery - could get very involved.			Save actor list from experiment frame as global bindings.  Use it to verify existence of				actor definitions (mainly for unmatched args in verb (eg. secretes, abuts) frames) during				rule translations.to improve:	Combine concentration.of and density.of into one word for either; use sub.of ca.actor or ca.background				during translation.PROBLEMS:	Xnotes:			XNewCentury 12point, TabStops=4, LineWrap=100.CHANGES:5/12/92 start	dhf:	first cut}variable base.fname 100 allotp" ps_" base.fname "copy  \ Default base namevariable camfile.refnumvariable filename 100 allot: build.filename ( experiment -- pstr )	base.fname filename "copy	+name@ >STR filename "cat\	+name@ >STR filename "copy	filename ;: camfile.createopen ( experiment -- )\    build.filename return swap 0 curdir @	build.filename return swap 0 return GetDesktopDirID    ascii QED1 ascii TEXT     fcreateopen camfile.refnum !;: camfile.write (  -- )\	b.pointer @ b.count @ 	final.b.str	camfile.refnum @ fwrite ;: camfile.close	camfile.refnum @ fclose;variable tmpname 100 allot: camfile.send.text ( experiment  -- )	+name@ >STR tmpname "copy tmpname	final.b.str ( name.StrPtr text.Ptr text.Cnt )	SendCATextEvent;: camfile.send.open	0 curdir @ filename	SendCAOpenEvent;: ca.translate.dimensions ( experiment -- )	dup not-null	if	dup		'' ca.dimensions pget		dup not-null		if	cr dup car			dup not-null			if	.atom 32 emit ." GRID.WIDTH !" cr			else drop then			cdr		then		dup not-null		if	car			dup not-null			if	.atom 32 emit ." GRID.HEIGHT !" cr			else drop then		else drop then		'' ca.neighborhood pget		dup not-null		if	cr dup car			dup not-null			if	.atom 32 emit ." NEIGHBOR.WIDTH !" cr			else drop then			cdr		then		dup not-null		if	car			dup not-null			if	.atom 32 emit ." NEIGHBOR.HEIGHT !" cr			else drop then		else drop then	else drop then;0 value initial.fill.sym: ca.translate.initial.fill ( experiment -- )	'' NULL.ACTOR.SYM to initial.fill.sym	dup not-null	if	'' initial.conditions pget		dup not-null		if	car '' ca.initial.fill pget			dup not-null			if	cr car				dup not-null				if						to initial.fill.sym				then			else drop then		else drop then	else drop then	initial.fill.sym .atom 32 emit ." INIT.GRID.SITES" cr;: .boundary ( sx -- )	dup '' true swap member not-null	if	dup cdr car car dup not-null		if	dup ?bound.var dup not-null			if	nip '' ca.actor isa?				if	dup					cdr car car ?bound.var .atom 32 emit					." SET." car .atom cr				else drop then			else				true to ca.error.flag				drop nip ." \ VARIABLE NOT BOUND: " .atom cr			then		else drop then	else drop then;: ca.translate.boundaries ( experiment -- )	dup not-null	if	'' ca.boundaries pget		dup not-null		if	cr car			dup not-null			if	dup				'' TOP.BORDER car.of.member dup not-null				if	.boundary else drop then				dup				'' BOTTOM.BORDER car.of.member dup not-null				if	.boundary else drop then			then drop		else drop then	else drop then;: .i.concentration ( sx -- ) \ Output a background concentration	dup '' true swap member not-null ( s: sx tf )	if	dup cdr car car dup not-null ( s: sx var tf )		if	dup ?bound.var dup not-null ( s: sx var b.var tf )			if	nip '' ca.background isa?				if	dup ( s: sx sx )					cdr car cdr car .atom 32 emit \ output  info. value					cdr car car ?bound.var dup '' ca.decay.rate pget dup not-null					if	car dup not-null ( s: b.var decay )						if	.atom 32 emit  \ output decay.rate						else drop ." 0 " then					else drop ." 0 " then					.atom 32 emit \ output info. name					." INIT.BACKGROUND "					cr				else drop then			else				true to ca.error.flag				drop nip ." \ VARIABLE NOT BOUND: " .atom cr			then		else drop drop then	else drop then;: .l.i.concentration ( list -- ) \ Output all background concentrations in populations slot	'' CONCENTRATION.OF	swap ( sym list )	begin dup not-null	while  over ( sym list sym )		over car ( sym list sym car )		car equal ( sym list tf )		if dup car  .i.concentration then		cdr	repeat	drop drop;: ca.translate.concentrations ( experiment -- )	dup not-null	if	'' initial.conditions pget		dup not-null		if	car '' ca.populations pget			dup not-null			if	cr car				dup not-null				if	dup					.l.i.concentration				then drop			else drop then		else drop then	else drop then;: .a.population ( sx -- ) \ Output an actor population	dup '' true swap member not-null	if	dup cdr car car dup not-null		if	dup ?bound.var dup not-null			if	nip '' ca.actor isa?				if	dup					initial.fill.sym .atom 32 emit					cdr car car ?bound.var .atom 32 emit					cdr car cdr car .atom 32 emit ." RANDOM.REPLACE"					cr				else drop then			else				true to ca.error.flag				drop nip ." \ VARIABLE NOT BOUND: " .atom cr			then		else drop then	else drop then;: .l.a.population ( list -- ) \ Output all actor populations in populations slot	'' POPULATION.OF	swap ( sym list )	begin dup not-null	while  over ( sym list sym )		over car ( sym list sym car )		car equal ( sym list tf )		if  dup car .a.population then		cdr	repeat	drop drop;: .a.density ( sx -- ) \ Output an actor density	dup '' true swap member not-null	if	dup cdr car car dup not-null		if	dup ?bound.var dup not-null			if	nip '' ca.actor isa?				if	dup					initial.fill.sym .atom 32 emit					cdr car car ?bound.var .atom 32 emit					." GRID.WIDTH @ GRID.HEIGHT @ * "					cdr car cdr car .atom 32 emit ." * 100 / RANDOM.REPLACE"					cr				else drop then			else				true to ca.error.flag				drop nip ." \ VARIABLE NOT BOUND: " .atom cr			then		else drop then	else drop then;: .l.a.density ( list -- ) \ Output all actor densities in populations slot	'' DENSITY.OF	swap ( sym list )	begin dup not-null	while  over ( sym list sym )		over car ( sym list sym car )		car equal ( sym list tf )		if  dup car .a.density then		cdr	repeat	drop drop;: ca.translate.populations ( experiment -- )	dup not-null	if	'' initial.conditions pget		dup not-null		if	car '' ca.populations pget			dup not-null			if	cr car				dup not-null				if	dup					.l.a.population					dup					.l.a.density				then drop			else drop then		else drop then	else drop then;: ca.translate.flow ( experiment -- )	dup not-null	if	'' ca.flow pget		dup not-null		if	cr car			dup not-null			if	.atom 32 emit ." FLOW !" cr			else drop then		else drop then	else drop then;: ca.translate.turbulance ( experiment -- )	dup not-null	if	'' ca.turbulance pget		dup not-null		if	cr car			dup not-null			if	.atom 32 emit ." TURBULANCE !"  cr			else drop then		else drop then	else drop then;: ca.translate.iterations ( experiment -- )	dup not-null	if	'' ca.iterations pget		dup not-null		if	cr dup car			dup not-null			if	.atom 32 emit ." MAX.ITER.CNT !" cr			else drop then			cdr		then		dup not-null		if	car			dup not-null			if	.atom 32 emit ." REPORT.ITER.CNT !" cr			else drop then		else drop then	else drop then;variable actor.countvariable background.count32 constant max.featuresvariable feature.maskvariable feature.count: .actor  ( actor -- )	dup '' ca.actor isa?	if	1 actor.count +!		actor.count @ . 32 emit		." CONSTANT " .atom cr	else		dup '' ca.background isa?		if	1 background.count +!			background.count @ . 32 emit			." CONSTANT " .atom cr		else			dup '' ca.actor.feature isa?			if				feature.mask @ . 32 emit ." CONSTANT " .atom cr				feature.mask @ 2* feature.mask !			else drop			then		then	then;anchor tmp.actors.listnil to-anchor tmp.actors.list: ca.translate.actors ( experiment -- )	\ 1 feature.mask !	0 actor.count !	0 background.count !	get.actors.list	nil to-anchor tmp.actors.list	dup not-null	if	cr		begin			dup not-null		while			dup car dup not-null			if	car dup not-null				if					dup tmp.actors.list member null					if						dup tmp.actors.list cons to-anchor tmp.actors.list						.actor					else drop then				else drop then			else drop then			cdr		repeat drop	else drop then	nil to-anchor tmp.actors.list;anchor proto.list: init.prototype.list ( sentence slot -- )	false types.matched !	over car swap	( s: sentence atom slot )	over over		( s: sentence atom slot atom slot )	mgetx dup not-null	if		( s: sentence atom slot proto.list.list )		nip nip car		( s: sentence proto.list )	else	( s: sentence atom slot nil )		true to ca.error.flag		rot rot cr ." \ NO PROTO SLOT: "  .atom  ." ; FOR: " .atom cr	then	( s: sentence proto.list )	to-anchor proto.list	drop	;: next.prototype ( sentence -- prototype )	nil swap proto.list	( s: nil sentence proto.list )	begin		2 pick null			\ haven't found one?		over not-null and	\ and not end of list?	while		dup car		( s: nil sentence proto.list prototype )		dup not-null		if	( s: nil sentence proto.list prototype )			2 pick swap  ( s: nil sentence proto.list sentence prototype )			test.prototype ( s: nil sentence proto.list tf )			if\				over over car cr ." Good PROTO: "  .sx   ." SENT.: "  .sx cr				rot drop	( s: sentence proto.list )				dup car	( s: sentence proto.list prototype )				rot rot		( s: prototype sentence proto.list )			then		( s: prototype|nil sentence proto.list )		else drop then	( s: prototype|nil sentence proto.list )		cdr		\ ." Continuing " .s cr	repeat		( s: prototype|nil sentence proto.list )	\ ." Exiting " .s cr	to-anchor proto.list	drop	;: end.prototype.list ( sentence -- sentence )	types.matched @ not	if		true to ca.error.flag		dup ." \ MISSING PROTOTYPE FOR: "  save.ca.slot .atom 32 emit .sx cr	then	nil to-anchor proto.list	;\ For each relation in initial conditions, define a feature for each matching prototype.\ Save all initialized relations in my.relations.list for use later in test.uninitialized.relation.: ca.translate.relations ( experiment -- )	1 feature.mask !	0 feature.count !	'' if.relates to-anchor save.slot	'' ca.relations to-anchor save.ca.slot	get.relations.list		( s: sentence.list )	nil to-anchor my.relations.list		begin				( s: sentence.list )			dup not-null		while\			dup ." Sentence List " .sx cr			dup car dup not-null			if	( s: sentence.list sentence )				\ ." Entering init.proto.list " .s cr				dup '' ca.relations init.prototype.list	( s: sentence.list sentence )				\ ." Exited init.proto.list " .s cr				begin					\ dup '' ca.relations match.sentence.to.prototype					\ ." Entering next.prototype " .s cr					dup next.prototype					\ ." Exited next.prototype " .s cr					dup not-null				while	( s: sentence.list sentence prototype )\					over over ." Prototype " .sx cr ." Sentence " .sx cr					over	( s: sentence.list sentence prototype sentence )					dup truth? forth.list	( s: sentence.list sentence forth.list )					dup not-null					if		( s: sentence.list sentence forth.list )						dup my.relations.list member null	\ check for duplicates						if	( s: sentence.list sentence forth.list)							feature.count @ max.features >=							if								true to ca.error.flag								." \ TOO MANY ACTOR FEATURES, ALLOWED UP TO: "								max.features . cr								drop							else								dup my.relations.list cons to-anchor my.relations.list								feature.mask @ . 32 emit ." CONSTANT "								feature.mask @ 2* feature.mask !								feature.count @ 1+ feature.count !								begin									dup not-null								while									dup car .atom									cdr								repeat drop								space ." \ relation converted to feature " cr							then						else drop then		( s: sentence.list sentence )					else drop then		( s: sentence.list sentence )				repeat drop	( s: sentence.list sentence )				\ ." Entering end.prototype.list " .s cr				end.prototype.list				\ ." Exited end.prototype.list " .s cr				drop		( s: sentence.list )			else drop then		( s: sentence.list )\				dup ." Sentence List " .sx cr			cdr	( s: sentence.list )		repeat drop\	Save my.relations.list to check for uninitialized relations during rule building.\	nil to-anchor my.relations.list;\ X  [']  X  >NAME  COLOR  SYMBOL  LIFESPAN REGISTER.ACTOR: ca.translate.registrations ( experiment -- )\	cr ." Registrations go here. " cr	get.actors.list	nil to-anchor tmp.actors.list	dup not-null	if	cr		begin			dup not-null		while			dup car car dup not-null			\ if	?bound.var then dup not-null			if	dup '' ca.actor isa? else false then			if	dup tmp.actors.list member null else false then			if	dup ( s: list actor actor )				dup tmp.actors.list cons to-anchor tmp.actors.list				dup '' ca.lifespan pget dup not-null				if car then dup null				if drop '' MAX.LIFESPAN then swap  ( s: list actor lifespan actor )				dup '' ca.symbol pget dup not-null				if car then dup null				if drop '' @ then swap	( s: list actor lifespan symbol actor )				dup '' ca.color pget dup not-null				if car then dup null				if	drop '' 255				else dup					numberp 0=					if	'' palette pget dup not-null						if car then dup null						if drop '' 255 then					then				then				swap	( s: list actor lifespan symbol color actor )				( actor ) dup .atom 32 emit ." ['] " .atom 32 emit ." >NAME "				( color ) .atom 32 emit				( symbol ) ." ASCII " .atom 32 emit				( lifespan ) .atom 32 emit			\	( actor ) ." ['] " .atom 32 emit 				drop ." REGISTER.ACTOR" cr			else drop then			cdr		repeat drop	else drop then	nil to-anchor tmp.actors.list;: popsim.register.rules ( experiment -- )	drop	my.rules.list	begin		dup not-null	( list tf )	while		dup car dup not-null	( list car tf )		if	dup '' popsim.rule isa? else false then		if	." ['] " .atom 32 emit ." REGISTER.RULE" cr else drop then	( list )		cdr	repeat drop;: ca.translate.experiment ( experiment -- )	ps.init.global	ps.init-bindings	dup	true to use.global.bindings	dup not-null	if		{	'' initial.conditions pget dup not-null			if	car '' actors pget  dup not-null				if	car then			then		}		get.actors.list	then	dup not-null	if make.actor.bindings	else drop then	cr ." FORGET CAM.DEFINITION"	cr ." : CAM.DEFINITION ;" cr	dup ca.translate.dimensions	dup ca.translate.actors	dup ca.translate.relations	dup ca.translate.rules	cr ." : REGISTRATION" cr		dup popsim.register.rules		dup ca.translate.registrations		dup ca.translate.concentrations	." ;" cr	." TOKEN.FOR REGISTRATION IS (REGISTRATION)" cr	cr ." : INITIALIZATION" cr		dup ca.translate.initial.fill		dup ca.translate.boundaries		dup ca.translate.populations		dup ca.translate.flow		dup ca.translate.turbulance		dup ca.translate.iterations	." ;" cr	." TOKEN.FOR INITIALIZATION IS (INITIALIZATION)" cr	drop	ps.init.global	ps.init-bindings	nil to-anchor my.relations.list	nil to-anchor my.rules.list;: ca.clear.results ( experiment -- )	'' ca.results nil pput;: ca ( experiment -- tf )	dup not-null	if		0 to ca.error.flag		buffer>		dup ca.clear.results		dup ca.translate.experiment			dup camfile.createopen			camfile.write			camfile.close		ca.error.flag 0=		if 			camfile.send.text		else			drop		then			kill-buffer		\  don't output to screen, may be too much text!		\ <buffer		\ kill it or close it, but not both	else drop then	ca.error.flag 0=;: ca.make.file ( experiment --  tf )	dup not-null	if		0 to ca.error.flag		buffer>			dup ca.clear.results			dup ca.translate.experiment			dup camfile.createopen				camfile.write				camfile.close			drop		<buffer	else drop then	ca.error.flag 0=;: ca.test ( experiment -- tf )	ca.translate.experiment	ca.error.flag 0=;