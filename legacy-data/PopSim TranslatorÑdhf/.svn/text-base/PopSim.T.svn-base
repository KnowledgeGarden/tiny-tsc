{	PopSim.Tdescription:	PopSim primitive frames for slots, actors, states, and relations.need to do:		Xto improve:		XPROBLEMS:	Xnotes:			XNewCentury 12point, TabStops=4, LineWrap=100.CHANGES:5/11/92 start	dhf:	first cut						created actor attribute frames: ca.background, ca.actor						created initial conditions frames: population.of, concentration.of,						ca.dimensions, ca.boundaries, ca.populations, ca.flow, ca.turbulance}c:	popsim.rule	my.creator	dhf	sub.of	rulec:	initial.conditions	my.creator	dhf	sub.of	information.slot{c:	experiment	my.creator	dhf	sub.of	idea}\ ---------------------------------------------------------------------------------------------Slotsc:	ca.symbol	my.creator	dhf	sub.of	information.slotc:	ca.color	my.creator	dhf	sub.of	information.slotc:	ca.lifespan	my.creator	dhf	sub.of	information.slotc:	ca.decay.rate	my.creator	dhf	sub.of	information.slotc:	ca.focus.actor	my.creator	dhf	sub.of	information.slotc:	ca.actors	my.creator	dhf	sub.of	information.slot	to.get		%igetc:	ca.relations	my.creator	dhf	sub.of	information.slot	to.get		%iget{	not usedc:	ca.if.actors	my.creator	dhf	sub.of	information.slot	to.get		%igetc:	ca.if.not.actors	my.creator	dhf	sub.of	information.slot	to.get		%iget}c:	ca.if.relates	my.creator	dhf	sub.of	information.slot	to.get		%igetc:	ca.if.not.relates	my.creator	dhf	sub.of	information.slot	to.get		%igetc:	ca.if.states	my.creator	dhf	sub.of	information.slot	to.get		%igetc:	ca.if.not.states	my.creator	dhf	sub.of	information.slot	to.get		%igetc:	ca.then.actors	my.creator	dhf	sub.of	information.slot	to.get		%igetc:	ca.then.not.actors	my.creator	dhf	sub.of	information.slot	to.get		%igetc:	ca.then.relates	my.creator	dhf	sub.of	information.slot	to.get		%igetc:	ca.then.not.relates	my.creator	dhf	sub.of	information.slot	to.get		%igetc:	ca.then.states	my.creator	dhf	sub.of	information.slot	to.get		%igetc:	ca.then.not.states	my.creator	dhf	sub.of	information.slot	to.get		%iget\ ---------------------------------------------------------------------------------------------Experiment Parameters\ Initial Conditions Slotsc:	ca.dimensions	my.creator	dhf	sub.of	information.slotc:	ca.neighborhood	my.creator	dhf	sub.of	information.slotc:	ca.initial.fill	my.creator	dhf	sub.of	information.slotc:	ca.boundaries	my.creator	dhf	sub.of	information.slotc:	ca.populations	my.creator	dhf	sub.of	information.slotc:	ca.flow	my.creator	dhf	sub.of	information.slotc:	ca.turbulance	my.creator	dhf	sub.of	information.slot\ Other Experiment Slotsc:	ca.iterations	my.creator	dhf	sub.of	information.slotc:	ca.results	my.creator	dhf	sub.of	information.slot\ Population & concentration predicatesc:	population.of	my.creator	dhfc:	density.of	my.creator	dhfc:	concentration.of	my.creator	dhf\ ---------------------------------------------------------------------------------------------Actors & Attributesc:	ca.actor	sub.of		thing	my.creator	dhf	ca.then.actors	( ( ( ca.actor ) ( 1 ( ) ) (  ( drop $self ) ( drop NULL.ACTOR.SYM ) ) ) )c:	null.actor.sym	sub.of			ca.actor	my.creator		dhfc:	ca.background	sub.of		stuff	my.creator	dhfc:	ca.actor.feature	sub.of		idea	my.creator	dhf\ ---------------------------------------------------------------------------------------------Relations\ In the translation prototypes below, the following symbols have special meanings.\	$* is a wildcard type specifier - matches any type\	$# is an integer type specifier\	$SELF means substitute the the name of the actual state or relation being translated.\	$$SELF means substitute the the name of the actual state or relation being translated,\			and append to preceding word to make one long word.\	$2 means substitute the name of argument #2.\	$$2 means substitute the name of argument #2, and append to preceding word to make one long word.\ Note: Prototypes in ca.relations slots must have the same translation for both true and false qualifiers.COMMENT:	NOTE:  the frame compiler "+c:" is used instead of "c:" so that whatever NEW information is in the following frame is ADDED to any previous definition.  If "c:" is used, all earlier definition of a given frame is "forgotten."	ALSO, the primary purpose of these extensions is to support a translator which reads TSC process rules and writes Forth code for the PopSim simulator.COMMENT;\  Here are the default translations for all relations.  These will be used if not overridden in a more specific frame.COMMENT:\ This version does not support commutation of relations automatically.  That is, it causes code to be\ generated only when the current focus actor is the FIRST argument to the relation.  Another version\ of the default translation prototypes follows these.+c:	RELATION	my.creator			dhf	ca.relations		( ( ( ca.actor $* ) ( 1 (  ) ) ( ( $SELF $$2 ) ( $SELF $$2 ) ) )							   ( ( ca.actor ) ( 1 (  ) ) ( ( $SELF ) ( $SELF ) ) ) )	ca.if.relates			( ( ( ca.actor $* ) ( 1 (  ) ) ( ( $SELF $$2 ?FEATURES )													      ( $SELF $$2 ?FEATURES NOT ) ) )							   ( ( ca.actor ) ( 1 (  ) ) ( ( $SELF ?FEATURES )												      ( $SELF ?FEATURES NOT ) ) ) )	ca.if.not.relates		( ( ( ca.actor $* ) ( 1 (  ) ) ( ( $SELF $$2 ?FEATURES NOT )													      ( $SELF $$2 ?FEATURES ) ) )							   ( ( ca.actor ) ( 1 (  ) ) ( ( $SELF ?FEATURES NOT )													( $SELF ?FEATURES ) ) ) )	ca.if.states			( ( ( ca.actor $* ) ( 1 (  ) ) ( ( $SELF $$2 ?FEATURES )													      ( $SELF $$2 ?FEATURES NOT ) ) )							   ( ( ca.actor ) ( 1 (  ) ) ( ( $SELF ?FEATURES )												      ( $SELF ?FEATURES NOT ) ) ) )	ca.if.not.states		( ( ( ca.actor $* ) ( 1 (  ) ) ( ( $SELF $$2 ?FEATURES NOT )													      ( $SELF $$2 ?FEATURES ) ) )							   ( ( ca.actor ) ( 1 (  ) ) ( ( $SELF ?FEATURES NOT )													( $SELF ?FEATURES ) ) ) )	ca.then.relates		( ( ( ca.actor $* ) ( 1 (  ) ) ( ( $SELF $$2 TRUE SET.FEATURES )													      ( $SELF $$2 FALSE SET.FEATURES ) ) )							   ( ( ca.actor ) ( 1 (  ) ) ( ( $SELF TRUE SET.FEATURES )													      ( $SELF FALSE SET.FEATURES ) ) ) )	ca.then.not.relates	( ( ( ca.actor $* ) ( 1 (  ) ) ( ( $SELF $$2 FALSE SET.FEATURES )											      ( $SELF $$2 TRUE SET.FEATURES ) ) )							   ( ( ca.actor ) ( 1 (  ) ) ( ( $SELF TRUE SET.FEATURES )													      ( $SELF FALSE SET.FEATURES ) ) ) )	ca.then.states		( ( ( ca.actor $* ) ( 1 (  ) ) ( ( $SELF $$2 TRUE SET.FEATURES )													      ( $SELF $$2 FALSE SET.FEATURES ) ) )							   ( ( ca.actor ) ( 1 (  ) ) ( ( $SELF TRUE SET.FEATURES )													      ( $SELF FALSE SET.FEATURES ) ) ) )	ca.then.not.states	( ( ( ca.actor $* ) ( 1 (  ) ) ( ( $SELF $$2 FALSE SET.FEATURES )											      ( $SELF $$2 TRUE SET.FEATURES ) ) )							   ( ( ca.actor ) ( 1 (  ) ) ( ( $SELF TRUE SET.FEATURES )													      ( $SELF FALSE SET.FEATURES ) ) ) )COMMENT;\ This version supports relations and their commutation automatically.  That is, it causes code to be\ generated when the current focus actor is EITHER the FIRST or SECOND argument to the relation.\ For example, the relation message ( RELATE *X *Y ) would translate to the actor-feature \ "RELATE.TYPE-Y" when the actor bound to *X is the focus, and it would translate to "RELATE.TYPE-X"\ when the actor bound to *Y is the focus.\ This default method may not be appropriate for relations that do not commute.  See the definitions for\ PART.OF below to see how it is implemented as the commutation or inverse of HAS.PART.+c:	RELATION	my.creator			dhf	ca.relations		( ( ( ca.actor $* ) ( 1 (  ) ) ( ( $SELF $$2 ) ( $SELF $$2 ) ) )						  ( ( $* ca.actor ) ( 2 (  ) ) ( ( $SELF $$1 ) ( $SELF $$1 ) ) )							   ( ( ca.actor ) ( 1 (  ) ) ( ( $SELF ) ( $SELF ) ) ) )	ca.if.relates			( ( ( ca.actor $* ) ( 1 (  ) ) ( ( $SELF $$2 ?FEATURES )													      ( $SELF $$2 ?FEATURES NOT ) ) )						  ( ( $* ca.actor ) ( 2 (  ) ) ( ( $SELF $$1 ?FEATURES )													      ( $SELF $$1 ?FEATURES NOT ) ) )							   ( ( ca.actor ) ( 1 (  ) ) ( ( $SELF ?FEATURES )												      ( $SELF ?FEATURES NOT ) ) ) )	ca.if.not.relates		( ( ( ca.actor $* ) ( 1 (  ) ) ( ( $SELF $$2 ?FEATURES NOT )													      ( $SELF $$2 ?FEATURES ) ) )						  ( ( $* ca.actor ) ( 2 (  ) ) ( ( $SELF $$1 ?FEATURES NOT )													      ( $SELF $$1 ?FEATURES ) ) )							   ( ( ca.actor ) ( 1 (  ) ) ( ( $SELF ?FEATURES NOT )													( $SELF ?FEATURES ) ) ) )	ca.if.states			( ( ( ca.actor $* ) ( 1 (  ) ) ( ( $SELF $$2 ?FEATURES )													      ( $SELF $$2 ?FEATURES NOT ) ) )						  ( ( $* ca.actor ) ( 2 (  ) ) ( ( $SELF $$1 ?FEATURES )													      ( $SELF $$1 ?FEATURES NOT ) ) )							   ( ( ca.actor ) ( 1 (  ) ) ( ( $SELF ?FEATURES )												      ( $SELF ?FEATURES NOT ) ) ) )	ca.if.not.states		( ( ( ca.actor $* ) ( 1 (  ) ) ( ( $SELF $$2 ?FEATURES NOT )													      ( $SELF $$2 ?FEATURES ) ) )						  ( ( $* ca.actor ) ( 2 (  ) ) ( ( $SELF $$1 ?FEATURES NOT )													      ( $SELF $$1 ?FEATURES ) ) )							   ( ( ca.actor ) ( 1 (  ) ) ( ( $SELF ?FEATURES NOT )													( $SELF ?FEATURES ) ) ) )	ca.then.relates		( ( ( ca.actor $* ) ( 1 (  ) ) ( ( $SELF $$2 TRUE SET.FEATURES )													      ( $SELF $$2 FALSE SET.FEATURES ) ) )						  ( ( $* ca.actor ) ( 2 (  ) ) ( ( $SELF $$1 TRUE SET.FEATURES )													      ( $SELF $$1 FALSE SET.FEATURES ) ) )							   ( ( ca.actor ) ( 1 (  ) ) ( ( $SELF TRUE SET.FEATURES )													      ( $SELF FALSE SET.FEATURES ) ) ) )	ca.then.not.relates	( ( ( ca.actor $* ) ( 1 (  ) ) ( ( $SELF $$2 FALSE SET.FEATURES )											      ( $SELF $$2 TRUE SET.FEATURES ) ) )						  ( ( $* ca.actor ) ( 2 (  ) ) ( ( $SELF $$1 FALSE SET.FEATURES )											      ( $SELF $$1 TRUE SET.FEATURES ) ) )							   ( ( ca.actor ) ( 1 (  ) ) ( ( $SELF TRUE SET.FEATURES )													      ( $SELF FALSE SET.FEATURES ) ) ) )	ca.then.states		( ( ( ca.actor $* ) ( 1 (  ) ) ( ( $SELF $$2 TRUE SET.FEATURES )													      ( $SELF $$2 FALSE SET.FEATURES ) ) )						  ( ( $* ca.actor  ) ( 2 (  ) ) ( ( $SELF $$1 TRUE SET.FEATURES )													      ( $SELF $$1 FALSE SET.FEATURES ) ) )							   ( ( ca.actor ) ( 1 (  ) ) ( ( $SELF TRUE SET.FEATURES )													      ( $SELF FALSE SET.FEATURES ) ) ) )	ca.then.not.states	( ( ( ca.actor $* ) ( 1 (  ) ) ( ( $SELF $$2 FALSE SET.FEATURES )											      ( $SELF $$2 TRUE SET.FEATURES ) ) )						  ( ( $* ca.actor ) ( 2 (  ) ) ( ( $SELF $$1 FALSE SET.FEATURES )											      ( $SELF $$1 TRUE SET.FEATURES ) ) )							   ( ( ca.actor ) ( 1 (  ) ) ( ( $SELF TRUE SET.FEATURES )													      ( $SELF FALSE SET.FEATURES ) ) ) )\ ABUTS has some special requirements for translation.  Unlike other relations which are conv erted to\ actor features to be asserted via SET.FEATURES and tested via ?FEATURES, ABUTS is a spacial relation\ which can be tested directly.  Thus it is implemented directly as a function for antecedents and ignored\ in consequents.+c:	ABUTS	level				basic	sub.of				relation	my.creator			dhf	ca.relations		( ( ( ca.actor ca.actor ) ( 1 (  ) ) ( (  ) (  ) ) )   \ These translate to nothing						  ( ( ca.actor ca.actor ) ( 2 (  ) ) ( (  ) (  ) ) )    \ This prevents conversion of relation to an actor feature.						  ( ( ca.actor ca.background ) ( 1 (  ) ) (  (  ) (  ) ) ) )	ca.if.relates			( ( ( ca.actor ca.actor ) ( 1 ( 2 ) ) (  ( ABUTS ) ( ABUTS NOT ) ) )						   ( ( ca.actor ca.actor ) ( 2 ( 1 ) ) ( ( ABUTS ) ( ABUTS NOT ) ) )						   ( ( ca.actor ca.background ) ( 1 ( 2 ) ) ( ( ?BACKGROUND ) ( ?BACKGROUND NOT ) ) ) )	ca.if.not.relates		( ( ( ca.actor ca.actor ) ( 1 ( 2 ) ) (  ( ABUTS NOT ) ( ABUTS ) ) )						   ( ( ca.actor ca.actor ) ( 2 ( 1 ) ) ( ( ABUTS NOT ) ( ABUTS ) ) )						   ( ( ca.actor ca.background ) ( 1 ( 2 ) ) ( ( ?BACKGROUND NOT ) ( ?BACKGROUND ) ) ) )	ca.if.states			( ( ( ca.actor ca.actor ) ( 1 ( 2 ) ) (  ( ABUTS ) ( ABUTS NOT ) ) )						   ( ( ca.actor ca.actor ) ( 2 ( 1 ) ) ( ( ABUTS ) ( ABUTS NOT ) ) )						   ( ( ca.actor ca.background ) ( 1 ( 2 ) ) ( ( ?BACKGROUND ) ( ?BACKGROUND NOT ) ) ) )	ca.if.states			( ( ( ca.actor ca.actor ) ( 1 ( 2 ) ) (  ( ABUTS NOT ) ( ABUTS ) ) )						   ( ( ca.actor ca.actor ) ( 2 ( 1 ) ) ( ( ABUTS NOT ) ( ABUTS ) ) )						   ( ( ca.actor ca.background ) ( 1 ( 2 ) ) ( ( ?BACKGROUND NOT ) ( ?BACKGROUND ) ) ) )	ca.then.relates		( ( ( ca.actor ca.actor ) ( 1 ( ) ) (  ( ) (  ) ) )						   ( ( ca.actor ca.actor ) ( 2 ( ) ) ( ( ) (  ) ) )						   ( ( ca.actor ca.background ) ( 1 ( ) ) ( (  ) (  ) ) ) )	ca.then.not.relates	( ( ( ca.actor ca.actor ) ( 1 ( ) ) (  (  ) (  ) ) )						   ( ( ca.actor ca.actor ) ( 2 ( ) ) ( (  ) (  ) ) )						   ( ( ca.actor ca.background ) ( 1 ( ) ) ( (  ) (  ) ) ) )	ca.then.states			( ( ( ca.actor ca.actor ) ( 1 ( ) ) (  (  ) (  ) ) )						   ( ( ca.actor ca.actor ) ( 2 ( ) ) ( ( ) (  ) ) )						   ( ( ca.actor ca.background ) ( 1 ( ) ) ( (  ) (  ) ) ) )	ca.then.not.states	( ( ( ca.actor ca.actor ) ( 1 ( ) ) (  (  ) ( ) ) )						   ( ( ca.actor ca.actor ) ( 2 ( ) ) ( (  ) (  ) ) )						   ( ( ca.actor ca.background ) ( 1 ( ) ) ( (  ) (  ) ) ) )+c:	PART.OF	level				basic	sub.of				relation	my.creator			dhf	ca.relations		( ( ( $* ca.actor ) ( 2 (  ) ) ( ( HAS.PART  $$1 ) ( HAS.PART  $$1 ) ) ) )	ca.if.relates			( ( ( $* ca.actor ) ( 2 (  ) ) ( ( HAS.PART  $$1 ?FEATURES )											      ( HAS.PART  $$1 ?FEATURES NOT ) ) ) )	ca.if.not.relates		( ( ( $* ca.actor ) ( 2 (  ) ) ( ( HAS.PART  $$1 ?FEATURES NOT )											      ( HAS.PART  $$1 ?FEATURES ) ) ) )	ca.if.states			( ( ( $* ca.actor ) ( 2 (  ) ) ( ( HAS.PART  $$1 ?FEATURES )											      ( HAS.PART  $$1 ?FEATURES NOT ) ) ) )	ca.if.not.states		( ( ( $* ca.actor ) ( 2 (  ) ) ( ( HAS.PART  $$1 ?FEATURES NOT )											      ( HAS.PART  $$1 ?FEATURES ) ) ) )	ca.then.relates		( ( ( $* ca.actor ) ( 2 (  ) ) ( ( HAS.PART  $$1 TRUE SET.FEATURES )											      ( HAS.PART  $$1 FALSE SET.FEATURES ) ) ) )	ca.then.not.relates	( ( ( $* ca.actor ) ( 2 (  ) ) ( ( HAS.PART  $$1 FALSE SET.FEATURES )											      ( HAS.PART  $$1 TRUE SET.FEATURES ) ) ) )	ca.then.states		( ( ( $* ca.actor ) ( 2 (  ) ) ( ( HAS.PART  $$1 TRUE SET.FEATURES )											      ( HAS.PART  $$1 FALSE SET.FEATURES ) ) ) )	ca.then.not.states	( ( ( $* ca.actor ) ( 2 (  ) ) ( ( HAS.PART  $$1 FALSE SET.FEATURES )											      ( HAS.PART  $$1 TRUE SET.FEATURES ) ) ) )\ This is the non-commuting version of the default prototypes for a relation.  It is needed to prevent \ HAS.PART from generating commuted translations.+c:	HAS.PART	my.creator			dhf	ca.relations		( ( ( ca.actor $* ) ( 1 (  ) ) ( ( $SELF $$2 ) ( $SELF $$2 ) ) ) )	ca.if.relates			( ( ( ca.actor $* ) ( 1 (  ) ) ( ( $SELF $$2 ?FEATURES )													      ( $SELF $$2 ?FEATURES NOT ) ) ) )	ca.if.not.relates		( ( ( ca.actor $* ) ( 1 (  ) ) ( ( $SELF $$2 ?FEATURES NOT )													      ( $SELF $$2 ?FEATURES ) ) ) )	ca.if.states			( ( ( ca.actor $* ) ( 1 (  ) ) ( ( $SELF $$2 ?FEATURES )													      ( $SELF $$2 ?FEATURES NOT ) ) ) )	ca.if.not.states		( ( ( ca.actor $* ) ( 1 (  ) ) ( ( $SELF $$2 ?FEATURES NOT )													      ( $SELF $$2 ?FEATURES ) ) ) )	ca.then.relates		( ( ( ca.actor $* ) ( 1 (  ) ) ( ( $SELF $$2 TRUE SET.FEATURES )													      ( $SELF $$2 FALSE SET.FEATURES ) ) ) )	ca.then.not.relates	( ( ( ca.actor $* ) ( 1 (  ) ) ( ( $SELF $$2 FALSE SET.FEATURES )											      ( $SELF $$2 TRUE SET.FEATURES ) ) ) )	ca.then.states		( ( ( ca.actor $* ) ( 1 (  ) ) ( ( $SELF $$2 TRUE SET.FEATURES )													      ( $SELF $$2 FALSE SET.FEATURES ) ) ) )	ca.then.not.states	( ( ( ca.actor $* ) ( 1 (  ) ) ( ( $SELF $$2 FALSE SET.FEATURES )											      ( $SELF $$2 TRUE SET.FEATURES ) ) ) )+c:	SECRETES	my.creator	dhf	level				basic	sub.of				relation	ca.then.states		( ( ( ca.actor ca.background ) ( 1 ( 2 ) ) 								( ( 10 ADD.BACKGROUND $SELF $$2 TRUE SET.FEATURES ) 								( $SELF $$2 FALSE SET.FEATURES ) ) ) )	ca.then.relates		( ( ( ca.actor ca.background ) ( 1 ( 2 ) ) 								( ( 10 ADD.BACKGROUND $SELF $$2 TRUE SET.FEATURES ) 								( $SELF $$2 FALSE SET.FEATURES ) ) ) )c:	HAS.FEATURE	my.creator	dhf	level		basic	ca.if.states	( ( ( ca.actor ca.actor.feature ) ( 1 ( 2 ) ) (  ( ?FEATURES ) ( ?FEATURES NOT ) ) ) )	ca.then.states	( ( ( ca.actor ca.actor.feature ) ( 1 ( 2 ) ) ( ( TRUE SET.FEATURES ) ( FALSE SET.FEATURES ) ) ) )c:	EXTEND.LIFE	my.creator	dhf	level				basic	ca.then.states		( ( ( ca.actor ) ( 1 ( ) ) ( ( 5 EXTEND.LIFE ) ( ) ) ) )