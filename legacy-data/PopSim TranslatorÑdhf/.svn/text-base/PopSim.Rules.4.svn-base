{	PopSim.Rules.4description:	Words used to translate TSC rule frames for the PopSim Server.  These words are used in the				file PopSim.Translator.4.need to do:		Xto improve:		Verify all actors were declared in actors list of experiment.				Currently translation can leave actors undefined which will not be noticed				until rules are compiled in PopSim Server.PROBLEMS:	Xnotes:			XNewCentury 12point, TabStops=4, LineWrap=100.CHANGES:5/16/92 start	dhf:	first cut}0 value ca.error.flag0 value rule.count\	GET.UP belongs in META.4.\	The version there doesn't test synonyms: GET.UP		( con -- list tf )	\ true if not-null				dup '' SUB.OF pget				over '' INSTANCE.OF pget union				swap '' SYNONYM pget union				dup not-null;\	(IG & IGET belong in META.4.\	The version there doesn't test synonyms or check for cyclesanchor iget.slot   nil to-anchor iget.slotanchor iget.cycle.check   nil to-anchor iget.cycle.check: (IG			( frame  -- T|F )				iget.slot				mget dup null				IF		drop false				ELSE	to-anchor get/put.m true				THEN;: IGET ( frame slot -- x )			to-anchor iget.slot	( s: frame )\			." IGET frame & list " dup .sx space iget.cycle.check .sx cr			dup iget.cycle.check member null			if				dup iget.cycle.check cons to-anchor iget.cycle.check				dup iget.slot \			." IGET frame & slot " over .sx space dup .sx  cr				pget dup null				IF		drop	( s: frame )						get.up	( s: framelist tf ) \ inherit along slots						IF		[token.for] (ig ?MAPCAR ( framelist -- sx|nil )						ELSE	drop nil						THEN not-null						IF		get/put.m	\ get result						ELSE	nil \ no value available						THEN				ELSE	nip	\ s: result.of.pget				THEN			else drop nil			then;\ Used for first call to get a slot value list using inheritance.  Subsequent mget calls using to.get methods\ will call iget directly.  This separation is required to properly initialize cycle-checking.  Actually, this\ word should probably not be used directly.  Instead, MGETx should be called first to allow the target slot\ to determine the actual get method used.: IGETx ( frame slot -- x )	nil to-anchor iget.cycle.check	IGET	nil to-anchor iget.cycle.check;\ Used for first call to get a slot value list using the get method in the slot's to.get slot.  This separation\ is required to properly initialize cycle-checking.: MGETx ( frame slot -- x )	nil to-anchor iget.cycle.check	MGET	nil to-anchor iget.cycle.check;\ Old TSC : !BINDQ !VARIABLE ;\ Old TSC : ISA? (ISA ;\ Test if symbol is a popsim global variable.  Return true and bound value if it is, false if it isn't.: ps.?global		( c -- val T | F )				dup not-null				IF		ps.&global.match assoc dup not-null						IF		second						THEN	true	( return val T or NIL T )				ELSE drop false ( return F )				THEN				;true  value use.global.bindings\ Test if symbol is a popsim variable.  Return bound value if it is, nil if it isn't.: ?bound.var ( sx -- sx | nil ) \ a variation of ?variable or ?global	use.global.bindings	if ps.?global else ps.?variable  then	not if nil then ;\ Take a list of actor sentences and create variable-actor bindings.\ Either global or local bindings may be created depending on state of use.global.bindings flag.: make.actor.bindings ( list -- )	begin		dup not-null	while		dup car dup not-null		if	dup car swap cdr car car			use.global.bindings			if ps.!setq else ps.!bindq then\			.atom 32 emit .atom cr		else drop then		cdr	repeat	drop;\ car.of.member searches a list of lists and returns with the first\ sublist which has the given symbol as its first element.\ Used, for example, to search a list of sentences to find those beginning with a given word.: car.of.member ( list.of.sublists symbol -- sublist )	swap ( sym list )	begin dup not-null	while  over ( sym list sym )		over car ( sym list sym car )		car equal		if car swap drop exit		else cdr then	repeat	swap drop ( null );anchor my.relations.listnil to-anchor my.relations.list\ Create a list of relation sentences without duplicates ( filtered by eunion ).\ Data taken from the if.relates slot of the initial conditions frame.: get.relations.list ( experiment -- relations.list )	nil to-anchor my.relations.list	dup not-null	if	'' initial.conditions pget dup not-null		if	car '' if.relates pget dup not-null			if car				begin					dup not-null				while					dup car dup not-null					if							my.relations.list eunion to-anchor my.relations.list					else drop then					cdr				repeat			then		then	then	drop	my.relations.list	nil to-anchor my.relations.list;anchor my.actors.listnil to-anchor my.actors.list\ Create a list of actor sentences without duplicates ( filtered by member ).\ Data taken from the if.actors slot of the initial conditions frame.: get.actors.list ( experiment -- actor.list )	nil to-anchor my.actors.list	dup not-null	if	'' initial.conditions pget dup not-null		if	car '' if.actors pget dup not-null			if car				begin					dup not-null				while					dup car dup not-null					if						dup my.actors.list member null						if							my.actors.list cons to-anchor my.actors.list						else drop then					else drop then					cdr				repeat			then		then	then	drop	my.actors.list	nil to-anchor my.actors.list;variable then.countanchor save.actor  nil to-anchor save.actoranchor save.slot     nil to-anchor save.slotanchor save.ca.slot     nil to-anchor save.ca.slotanchor tmp.save.ca.slot     nil to-anchor tmp.save.ca.slotvariable types.matchedanchor save.rule    nil to-anchor save.rulevariable unmatched.antecedentvariable consequents.found\ Compare proto param types to sentence param types.\ In example below, is *b-cell bound to a sub.of ca.actor, and is *cytokine bound to a sub.of ca.background?\  ( abuts ( *b-cell *cytokine ) true )   \  ( ( ca.actor ca.background ) ( 1 ( 2 ) ) ( ( ?background ) ( ?background not ) ) )\  sentence:		( abuts ( *b-cell *cytokine ) true )\  prototype:	( ( ca.actor ca.background ) ( 1 ( 2 ) ) ( ( ?background ) ( ?background not ) ) ): match.types ( sentence prototype -- tf )	car swap cdr car ( s: proto.params sent.params )	over length over length =	if		begin	( s: proto.params sent.params )			over not-null over not-null and		while			over car over car over not-null over not-null and			if	( s: proto.params sent.params proto.param sent.param )				over '' $# equal   \ check for integer literal				if	integerp					if drop cdr swap cdr swap					else drop drop drop false exit then				else					dup ?bound.var dup not-null					if		( s: proto.params sent.params proto.param sent.param bound.param)						nip swap	( s: proto.params sent.params bound.param proto.param )						dup '' $* equal  \ check for wildcard type						if	drop drop false						else isa? not then						if drop drop false exit						else cdr swap cdr swap then					else						true to ca.error.flag						drop ." \ PARAMETER NOT BOUND: " .atom 32 emit cr						drop cdr swap cdr swap \ keep going					then				then			else <>  \ two nulls are a match?				if	drop drop drop drop false exit				else cdr swap cdr swap then			then		repeat drop drop	else drop drop false exit then	true;\ Check if sentence param indicated by main proto param# is bound to actor type stored in save.actor.\ In example below, is param #1 (*b-cell) bound to the current save.actor type?\  sentence:		( abuts ( *b-cell *helper-t-cell ) true )\  prototype:	( ( ca.actor ca.actor ) ( 1 ( 2 ) ) ( ( abuts ) ( abuts not ) ) ): match.focus.param ( sentence prototype -- tf )	use.global.bindings	if	drop drop true exit then	\ Map main proto param# to sentence param;  compare actor bound to param to save.actor.	swap cdr car swap cdr car car integer> 1- list-nth dup ?bound.var dup not-null	if	nip dup not-null  ( s: test.actor tf )		if	save.actor equal			if	true			else false then		else  drop false then	else		true to ca.error.flag		drop drop \ ." \ PARAMETER NOT BOUND B: " .atom 32 emit cr		false	then;\ Given a sentence and a prototype, return true if they match in parameter types and focus.\ Used by match.sentence.to.prototype below.: test.prototype ( sentence prototype -- tf )	over over	match.types	if	true types.matched !	else 		drop drop false exit \		cr ." Bad PROTO: "  .sx  ." SENT.: "  .sx cr false exit	then	match.focus.param;\ Given a sentence and the slot type to lookup in the verb frame, try to match a prototype.\  If successful return the prototype, else return nil.: match.sentence.to.prototype ( sentence slot -- prototype )	false types.matched !	nil rot rot over car swap over over mgetx dup not-null	if		nip nip car	else		true to ca.error.flag		rot rot cr ." \ NO PROTO SLOT: "  .atom  ." ; FOR: " .atom cr	then ( s: nil sentence proto.list )	\ dup cr ." PROT LIST: "  .sx cr	begin		dup not-null	while		dup car		dup not-null		if	( s: nil sentence proto.list prototype )			\ >r over r> ( s: nil sentence proto.list sentence prototype )			2 pick swap  ( s: nil sentence proto.list sentence prototype )			test.prototype ( s: nil sentence proto.list tf )			if\				over over car cr ." Good PROTO: "  .sx   ." SENT.: "  .sx cr				rot drop car swap nil ( s: prototype sentence nil )			else cdr then		else drop cdr then	repeat	types.matched @ not	if		true to ca.error.flag		drop ." \ MISSING PROTOTYPE FOR: "  save.ca.slot .atom 32 emit .sx cr	else drop drop then;\ Output actors bound to parameters in a sentence according to the forth param# list in a prototype.\ In the example below the actor type bound to param #2 (*helper-t-cell) would be output.\  sentence:		( abuts ( *b-cell *helper-t-cell ) true )\  prototype:	( ( ca.actor ca.actor ) ( 1 ( 2 ) ) ( ( abuts ) ( abuts not ) ) ): .params ( sentence prototype -- )	\ Map proto forth param#s to sentence params;  output actors bound to sentence params.	swap cdr car swap cdr car cdr car ( s: sentence.params proto.params )	begin		dup not-null	while		over over car integer> 1- list-nth dup ?bound.var dup not-null ( s: sentence.params proto.params forth.param tf )		if	nip .atom 32 emit		else			true to ca.error.flag			drop drop \ ." \ PARAMETER NOT BOUND C: " .atom 32 emit cr		then		cdr	repeat drop drop;\ Return the truth value of a sentence.: truth? ( sentence -- tf )	cdr cdr car '' true equal;\ If symbol is an integer return it unchanged, otherwise return the atom bound to symbol.: $.literal.bound ( symbol -- symbol' )	dup integerp	\ check for integer literal	if	exit then	?bound.var		\ must be a bound variable;\ Substitute a sentence verb or parameter atom for a $ or $$ prototype atom.: $.substitution ( sentence forth.words atom -- sentence forth.words atom'  )		dup +name@ >STR 2+ c@ ascii $ = 0=	\ check if second char is not also '$'		if		\ '$' means include normal preceding space.			dup '' $self equal  ( s: sentence forth.words word )			if	drop  over car  then			dup '' $1 equal			if	drop  over cdr car first $.literal.bound then			dup '' $2 equal			if	drop  over cdr car second $.literal.bound  then			dup '' $3 equal			if	drop  over cdr car third $.literal.bound then			dup '' $4 equal			if	drop  over cdr car fourth $.literal.bound then			dup '' $5 equal			if	drop  over cdr car fifth $.literal.bound space then		else	\ '$$' means replace the preceding space with a '.'.			dup '' $$self equal  ( s: sentence forth.words word )			if	drop  over car then			dup '' $$1 equal			if	drop  over cdr car first $.literal.bound then			dup '' $$2 equal			if	drop  over cdr car second $.literal.bound then			dup '' $$3 equal			if	drop  over cdr car third $.literal.bound then			dup '' $$4 equal			if	drop  over cdr car fourth $.literal.bound then			dup '' $$5 equal			if	drop  over cdr car fifth $.literal.bound then		then;\ Print the forth translation of a sentence given its prototype.: .forth ( prototype sentence tf -- )	rot swap  ( s: sentence prototype tf )	swap cdr cdr car swap ( s: sentence forth.choices tf )	if	car else cdr car then ( s: sentence forth.words )	begin		dup not-null	while		dup car		dup symbolp		if 			dup +name@ >STR 1+ c@ ascii $ =			if				dup +name@ >STR 2+ c@ ascii $ =				if	ascii . emit	\ '$$' means replace the preceding space with a '.'.				else space then	\ '$' means include normal preceding space.				true			else false space then		else false space then		if	$.substitution then		.atom		cdr	repeat drop drop;anchor my.forth.list\ Build a list containing the forth translation of a sentence given its prototype.\ Used for initializing relations from sentences in if.relates slot of initial conditions frame.\ Also used in testing for uninitialized relations during translation of rules.: forth.list ( prototype sentence tf -- list )	nil to-anchor my.forth.list\	over ." forth.list " .sx cr	rot swap  ( s: sentence prototype tf )\	over ." forth.list " .sx cr	swap cdr cdr car swap ( s: sentence forth.choices tf )	if	car else cdr car then ( s: sentence forth.words )\	dup ." forth.list " .sx cr	begin		dup not-null	while		dup car\		dup ." forth.list " .sx cr		dup symbolp		if 			dup +name@ >STR 1+ c@ ascii $ =			if				dup +name@ >STR 2+ c@ ascii $ =	\ '$$' means insert a '.'.				if	 '' .  my.forth.list append to-anchor my.forth.list   then				true			else false then		else false then		if	$.substitution then		my.forth.list append to-anchor my.forth.list		cdr	repeat drop drop	my.forth.list	nil to-anchor my.forth.list;\ Test for uninintialized relation during rule translation.  Report error if found.\ Given a sentence and prototype; build a forth.list like those in ca.translate.relations.\ Check to be sure this forth.list is a member of the my.relations.list created in ca.translate.relations.: test.uninitialized.relation ( sentence prototype -- sentence prototype )		\ ." \ *** test.unitialized.relation " over .sx cr	over car '' sub.of pget   ( s: sentence.list sentence prototype sub.of.list )	'' relation swap member not-null	if	( s: sentence.list sentence prototype )		save.ca.slot to-anchor tmp.save.ca.slot	\ save tmp.save.ca.slot		'' ca.relations to-anchor save.ca.slot		\ change save.ca.slot		over dup '' ca.relations match.sentence.to.prototype 		tmp.save.ca.slot to-anchor save.ca.slot	\ restore save.ca.slot		( s: sentence.list sentence prototype sentence prototype' )			\ ." \ *** test.unitialized.relation " over over .sx space .sx cr		over truth? >r swap r> forth.list ( s: sentence.list sentence prototype forth.list )			\ ." \ *** test.unitialized.relation forth.list " dup .sx cr		dup not-null  \ ignore if forth.list is empty - relation was not converted to feature		if	my.relations.list member null	\ test for match to forth.list in my.relations.list		else drop false then		if	( s: sentence.list sentence prototype )			true to ca.error.flag			." \ UNINITIALIZED RELATION:  "  over .sx cr		then	then;\ Given a rule and a bound *var-actor pair, save the actor as the current focus in save.actor then output \ relevant translations of all sentences in one of the rule's  antecedent slots.  The slot to be translated was\ previously stored in save.slot and the prototype slot was saved in save.ca.slot.: .if.slot ( binding.pair rule -- )	swap dup cdr car to-anchor save.actor swap	( binding.pair rule )	save.slot pget dup not-null	if car then	( binding.pair sentence.list )	begin		dup not-null	while		dup car dup not-null		if	( binding.pair sentence.list sentence )			2 pick car over	( binding.pair sentence.list sentence *var sentence )			cdr car member			if				dup save.ca.slot match.sentence.to.prototype  ( binding.pair sentence.list sentence prototype )				dup not-null				if	( binding.pair sentence.list sentence prototype )					\ test for uninintialized relations					test.uninitialized.relation					over over .params swap dup truth? .forth cr					." IF " 1 then.count +!				else					true unmatched.antecedent !					drop drop				then			else drop then		else drop then		cdr	repeat drop drop;\ Given a rule and a bound *var-actor pair, save the actor as the current focus in save.actor then output \ relevant translations of all sentences in one of the rule's consequent slots.  The slot to be translated was\ previously stored in save.slot and the prototype slot was saved in save.ca.slot.: .then.slot ( binding.pair rule -- )	swap dup cdr car to-anchor save.actor swap	( binding.pair rule )	save.slot pget dup not-null	if car then	( binding.pair sentence.list )	begin		dup not-null	while		dup car dup not-null		if	( binding.pair sentence.list sentence )			2 pick car over	( binding.pair sentence.list sentence *var sentence )			cdr car member			if				dup save.ca.slot match.sentence.to.prototype  ( binding.pair sentence.list sentence prototype )				dup not-null				if	( binding.pair sentence.list sentence prototype )					\ test for uninintialized relations					test.uninitialized.relation					over over .params swap dup truth? .forth cr					true consequents.found !				else					drop drop				then			else drop then		else drop then		cdr	repeat drop drop;: .if.relates ( binding.pair rule -- )	'' if.relates to-anchor save.slot	'' ca.if.relates to-anchor save.ca.slot	.if.slot;: .if.not.relates ( binding.pair rule -- )\	." if.not.relates " swap .atom 32 emit .atom cr	'' if.not.relates to-anchor save.slot	'' ca.if.not.relates to-anchor save.ca.slot	.if.slot;: .if.states ( binding.pair rule -- )\	." if.states " swap .atom 32 emit .atom cr	'' if.states to-anchor save.slot	'' ca.if.states to-anchor save.ca.slot	.if.slot;: .if.not.states ( binding.pair rule -- )\	." if.not.states " swap .atom 32 emit .atom cr	'' if.not.states to-anchor save.slot	'' ca.not.if.states to-anchor save.ca.slot	.if.slot;: .then.relates ( binding.pair rule -- )	'' then.relates to-anchor save.slot	'' ca.then.relates to-anchor save.ca.slot	.then.slot;: .then.not.relates ( binding.pair rule -- )	'' then.not.relates to-anchor save.slot	'' ca.then.not.relates to-anchor save.ca.slot	.then.slot;: .then.states ( binding.pair rule -- )\	." then.states " swap .atom 32 emit .atom cr	'' then.states to-anchor save.slot	'' ca.then.states to-anchor save.ca.slot	.then.slot;: .then.not.states ( binding.pair rule -- )\	." then.not.states " swap .atom 32 emit .atom cr	'' then.not.states to-anchor save.slot	'' ca.then.not.states to-anchor save.ca.slot	.then.slot;: .then.actors ( binding.pair rule -- )\	." then.actors " swap .atom 32 emit .atom cr	'' then.actors to-anchor save.slot	'' ca.then.actors to-anchor save.ca.slot	.then.slot;: .then.not.actors ( binding.pair rule -- )\	." then.not.actors " swap .atom 32 emit .atom cr	'' then.not.actors to-anchor save.slot	'' ca.then.not.actors to-anchor save.ca.slot	.then.slot;\ Output "then" enough times to balance the "if" output during translation of antecedents.\ Then.count is accumulated in the routine .if.slot.: .thens	then.count @ dup 0 >	if		0 do ." THEN " loop	else drop then;\ Translate the messages in the if.not.actors slot of a rule.  Outputs a list of all actor types appearing\ in the messages followed by the forth word CHECK.INHIBITORS.  PopSim uses this information to\ prevent a rule from firing if the neighborhood contains any unbound actors of the types listed.  Note\ that binding is performed first via BIND.NEIGHBORS so a rule may require one of a particular\ actor type, but not allow two, etc.: .if.not.actors ( rule -- )	'' if.not.actors pget dup not-null	if car then	( rule actor.list )	0 swap	( rule count actor.list )	begin		dup not-null	while		dup car		dup truth?		if	car	( rule count actor.list actor )			dup '' ca.actor isa?			if	.atom 32 emit				swap 1+ swap			else drop then		else drop ." FALSE IF.NOT.ACTOR MESSAGE " \ for ( x.actor ( *x ) false ) error.\		else drop ." NULL.ACTOR.SYM " \ for ( x.actor ( *x ) false ), bind *x to a null actor.			swap 1+ swap		then		cdr	repeat drop	( count )	dup 0<>	if		. 32 emit		." CHECK.INHIBITORS " cr		." 0= IF FALSE EXIT THEN  " cr	else		drop	then;\ Translate the messages in the if.not.actors slot of a rule.  Outputs a list of all actor types appearing\ in the messages.  It also outputs NULL.ACTOR.SYM once for each sentence in the then.create slot.\ The list of actors is followed by the forth word BIND.NEIGHBORS.  PopSim uses this information to\ bind the cells in a neighborhood to actors in the rule.: .actor.bindings ( rule -- )	dup '' if.actors pget dup not-null	if car then	( rule actor.list )	0 swap	( rule count actor.list )	begin		dup not-null	while		dup car		dup truth?		if	car	( rule count actor.list actor )			dup '' ca.actor isa?			if	.atom 32 emit				swap 1+ swap			else drop then\		else drop ." FALSE ACTOR MESSAGE " \ for ( x.actor ( *x ) false ) error.		else drop ." NULL.ACTOR.SYM " \ for ( x.actor ( *x ) false ), bind *x to a null actor.			swap 1+ swap		then		cdr	repeat drop	( rule count )	swap '' then.create pget dup not-null	\ bind to null actor for each "then.create" variable	if car then	( count variable.list )	begin		dup not-null	while		dup car dup not-null		if drop ." NULL.ACTOR.SYM "			swap 1+ swap		then		cdr	repeat drop	( count )	. 32 emit	." BIND.NEIGHBORS " cr	." 0= IF FALSE EXIT THEN  " cr;\ Look ahead to contents of then.create and then.actors to get actor sentences for actors which will\ be created by the rule and are thus not included in the if.actors slot.  These are added to the actor list\ in .antecedents and .consequents before calling make.actor.bindings.: add.then.create (( actor.list rule ; var.list then.list -- new.list ))	actor.list copy-list to new.list	rule '' then.create pget dup not-null	\ check "then.actors" for each "then.create" variable	if car then to var.list	var.list null if exit then	rule '' then.actors pget dup not-null	if car then to then.list	then.list null if exit then	begin		then.list not-null	while		then.list car dup not-null	( actor.msg ) \ eg. ( actor.x ( *x ) true )		if	dup cdr car car	( actor.msg var  )			var.list member not-null			if	new.list append to new.list			else drop then		then		then.list cdr to then.list	repeat	;0 value binding.id\ Output all the antecedents of a rule.  Loop through all actors to give each the focus.: .antecedents ( rule -- )	dup to-anchor save.rule	0 ps.push-bindings	dup '' if.actors pget dup not-null	if car then ( rule actor.list )	over add.then.create ( rule actor.list )	make.actor.bindings ps.get-bindings	( rule bindings.list )	reverse	0 to binding.id	begin		dup not-null	while	( rule bindings.list )		over over car	( rule bindings.list rule binding.pair )		dup cdr car '' ca.actor isa?	( rule bindings.list rule binding.pair tf )		if	swap	( rule bindings.list binding.pair rule )			." FALSE" cr	\ default for FAILED antecedents is false			binding.id . 32 emit ." SET.CURRENT.ACTOR " cr			0 then.count !			over over .if.relates			over over .if.not.relates			over over .if.states			over over .if.not.states			then.count @ 0 >			if					." DROP TRUE "				.thens cr				." 0= IF FALSE EXIT THEN  " cr	\ exit if antecedents fail			else				." DROP " cr			then			binding.id 1+ to binding.id		then		drop drop	( rule bindings.list )		cdr	repeat	drop drop	ps.pop-bindings drop;\ Output all the consequents of a rule.  Loop through all actors to give each the focus.: .consequents ( rule -- )	dup to-anchor save.rule	0 ps.push-bindings	dup '' if.actors pget dup not-null	if car then	over add.then.create ( rule actor.list )	make.actor.bindings ps.get-bindings	( rule bindings.list )	reverse	0 then.count !	0 to binding.id	begin		dup not-null	while	( rule bindings.list )		over over car	( rule bindings.list rule binding.pair )		dup cdr car '' ca.actor isa?	( rule bindings.list rule binding.pair tf )		if	swap	( rule bindings.list binding.pair rule )			binding.id . 32 emit ." SET.CURRENT.SYMBOLS " cr			over over .then.relates			over over .then.not.relates			over over .then.states			over over .then.not.states			over over .then.actors			over over .then.not.actors			." GET.CURRENT.SYMBOLS " cr			binding.id 1+ to binding.id		then		drop drop	( rule bindings.list )		cdr	repeat	." TRUE "	drop drop	ps.pop-bindings drop;: .a.rule ( rule -- )	cr dup ." : " .atom cr	dup .actor.bindings	dup .if.not.actors	dup .antecedents	dup .consequents\	Include the following line for debugging; causes rule to print its name when it fires.	dup ascii . emit ascii " emit space  rule.count . space .atom ascii " emit space ." cr" cr	." ;" cr	drop;anchor my.rules.listnil to-anchor my.rules.list\ Get actors from initial conditions frame, and build a list of all rules in their my.rules and my.sense slot.: popsim.translate.rules.setup ( experiment -- rules.list )	nil to-anchor my.rules.list	false to use.global.bindings	dup get.actors.list	dup not-null	if	cr then	begin		dup not-null	( list )	while		dup car car dup not-null	( list caar )		if	dup '' ca.actor isa?		else false then				( list caar tf )		if	'' my.rules pget	( list rule-list )			my.rules.list union to-anchor my.rules.list		else drop then	( list )		cdr	repeat drop	get.actors.list	dup not-null	if	cr then	begin		dup not-null	( list )	while		dup car car dup not-null	( list caar )		if	dup '' ca.actor isa?		else false then				( list caar tf )		if	'' my.sense pget	( list rule-list )			my.rules.list union to-anchor my.rules.list		else drop then	( list )		cdr	repeat drop	my.rules.list;: popsim.translate.rules ( experiment -- )	popsim.translate.rules.setup ( list )	0 to rule.count	begin		dup not-null	( list tf )	while		dup car dup not-null	( list car tf )		if	dup '' popsim.rule isa? else false then		if			rule.count  1+ to rule.count			cr ." \ Rule# " rule.count .			.a.rule		else drop then	( list )		cdr	repeat drop	true to use.global.bindings;: ca.translate.rules ( experiment -- )	popsim.translate.rules ;