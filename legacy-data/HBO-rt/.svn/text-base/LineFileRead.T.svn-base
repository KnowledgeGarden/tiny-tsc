{	LineFileRead.Tdescription:	Read from a specialty (brookhaven) protein database				ALWAYS STARTS AT count = 1need to do:		to improve:		XPROBLEMS:	Xglobal vbls used:	notes:			read lines until some "answer" data comes up				gather answer data				stop at first ATOM line				ready to begin trial				we assume the following ordering of file lines as uniform across all files				...				SEQRES				...				HELIX				...				ATOM			we stop if we ever reach ATOMCHANGES:6/01/92			first cut. NewCentury 12point, TabStops=4, LineWrap=100.}\ ____________________________________________________________ LINE READING\ =============================={	BIO-OPEN	description:			example input:		x	example output:		x	notes:				x}c:	BIO-OPEN	sub.of	function	i.take	symbol	i.give	integer	forth	%bio-open\ =============================={	BIO-CLOSE	description:			example input:		x	example output:		x	notes:				x}c:	BIO-CLOSE	sub.of	function	i.take	none	i.give	none	forth	%bio-close\ =============================={	BIO-READLINE	description:		read a line, leaving it in "tempstring"	example input:		x	example output:		T if eof encountered (no data)	notes:				x}c:	BIO-READLINE	sub.of	function	i.take	none	i.give	flag	forth	%bio-readline\ =============================={	BIO-LISTLINE	description:		turn a "tempstring" line into a list	example input:		x	example output:	nil if nothing in tempstring	notes:				x}c:	BIO-LISTLINE	sub.of	function	i.take	none	i.give	list	forth	%bio-listline\ ____________________________________________________________ LINE RECOGNITION\ look at first word in line\ =============================={	TURN?	description:		look for a hairpin turn	example input:		x	example output:		T	notes:				x}\ =============================={	SHEET?	description:		look for a §-sheet	example input:		x	example output:		T	notes:				x}\ =============================={	T-ATOM?	description:		look for a helix	example input:		x	example output:		T	notes:				line to check is in "tempstring"}c:	T-ATOM?	sub.of	predicate	i.take	none	i.give	flag	forth	%t-atom?\ =============================={	T-HELIX?	description:		look for a helix	example input:		x	example output:		T	notes:				line to check is in "tempstring"}c:	T-HELIX?	sub.of	predicate	i.take	none	i.give	flag	forth	%t-helix?\ =============================={	T-SEQRES?	description:		look for sequence data	example input:		x	example output:		T	notes:				line to check is in "tempstring"}c:	T-SEQRES?	sub.of	predicate	i.take	none	i.give	flag	forth	%t-seqres?\ ____________________________________________________________ LINE PARSING\ give appropriate data from a line to caller\	if line = ATOM, return the amino acid\ ____________________________________________________________ FILE PARSING"( *AMINO.ACIDS  *ALTERNATES )" &GLOBAL.LIST union to-anchor &GLOBAL.LIST"( setq *amino.acids  '(ala arg asn asp cys gln glu gly his ile leu lys met phe pro ser thr trp tyr val ace exc unk pca  nh2 ) )" eval drop"( setq *alternates  '( aarg  barg nh1aarg nh2aarg nh1barg nh2barg hem hoh nad sps ips ) )" eval drop\ =============================={	SCAN.TILL.ATOM	description:		look for beginning of atom	example input:		x	example output:		( F T ) if "ATOM" found, ( T F ) if "ATOM" not found	notes:				x}c:	SCAN.TILL.ATOM	sub.of		function	i.take		list	i.give		list	arguments	*files	my.vars	*eof  *atom	algorithm	( do	( display> "scan.till.atom" debug )						( bindq *eof F )						( bindq *atom F )						( loop.until	( or?	*atom *eof )								( do	( bindq *eof ( bio-readline ) )										( if.true ( and? *eof													( notnull? ( rest *files ) ) )											( do ( bio-close ) 												( bio-open ( second *files ) ) 												( bindq *files ( rest *files ) )												( bindq *eof ( bio-readline ) ) ) )										( if.true	( not? *eof )											( do	( bindq *atom ( t-atom? ) ) ) ) ) )						( display ( list *eof *atom ) debug )						( return ( list *eof *atom ) ) )\ =============================={	SCAN.TILL.SEQRES	description:		look for beginning of sequence data	example input:		x	example output:		( F T ) if "SEQRES" found, ( T F ) if "SEQRES" not found						( T T ) if got past and found ATOM	notes:				x}c:	SCAN.TILL.SEQRES	sub.of		function	i.take		none	i.give		list	my.vars	*eof *seqres *atom	algorithm	( do	( display> "scan.till.seqres" debug )						( bindq *eof ( bio-readline ) )						( bindq *seqres ( t-seqres? ) )						( bindq *atom ( t-atom? ) )						( loop.until	( or?	*seqres *eof )								( do	( bindq *eof ( bio-readline ) )										( if.true	( not? *eof )											( do	( bindq *seqres ( t-seqres? ) ) 													( bindq *atom ( t-atom? ) ) ) ) ) )						( if.true	*atom							( do	( bindq *eof T )									( bindq *seqres T ) ) )						( return ( list *eof *seqres ) ) )\ =============================={	FIND.NEXT.ATOM	description:		look for next beginning atom of next sequence	example input:		x	example output:	( 	notes:				x}c:	FIND.NEXT.ATOM	sub.of		function	i.take		sx	i.give		list	arguments	*tag	my.vars	*eof  *list *new.tag *atom	algorithm	( do	( display> "find.next.atom" debug ) ( display *tag debug ) 						( bindq *eof ( bio-readline ) )						( bindq *list ( bio-listline ) )						( display> "list" debug ) ( display *list debug )						( loop.until  ( member? ( first *list ) *amino.acids )							( do	( display> "first list" debug ) ( display ( first *list ) debug )									( bindq *list ( rest *list ) ) ) )						( display> "out of loop" debug ) ( display ( first *list ) debug )						( bindq *new.tag ( second *list ) )						( display> "new.tag" debug ) ( display *new.tag debug )						( loop.until	( not? ( same? *tag *new.tag ) )								( do	( bindq *eof ( bio-readline ) )										( bindq *list ( bio-listline ) )										( loop.until  ( or? ( null? ( first *list ) )														( or? ( member? ( first *list ) *amino.acids ) 														( member? ( first *list ) *alternates ) ) )										( do	( display> "first list" debug ) ( display ( first *list ) debug )												( bindq *list ( rest *list ) ) ) )										( display> "out of loop" debug ) ( display ( first *list ) debug )										( cond	( ( null? ( first *list ) )												( bindq *new.tag nil ) )												( T ( bindq *new.tag ( second *list ) ) ) )										( display> "new.tag" debug ) ( display *new.tag debug ) ) )						( if.true ( notnull? *new.tag )							( bindq *atom ( first *list ) ) )						( display  ( list *new.tag *atom ( third *list ) ) debug )						( return ( list *new.tag *atom ( third *list ) ) ) )\ =============================={	GET.ATOM.OFFSET	description:		get starting offset from first line of ATOM	example input:		( ATOM      1  N   MET     6      25.470  24.761   6.928  1.00 3473      1CLA 197 )	example output:	MET 6	notes:				should probably skip to first amino acid, then grab second--in case of different line}c:	GET.ATOM.OFFSET	sub.of		function	i.take		none	i.give		list	my.vars	*tag *list *atom	algorithm	( do	( bindq *tag nil ) 						( bindq *list ( bio-listline ) )	\ get the line						( loop.until  ( member? ( first *list ) *amino.acids )							( bindq *list ( rest *list ) ) )						( bindq *atom ( first *list ) )						( if.true ( not? ( number? ( second *list ) ) )							( do ( bindq *tag ( second *list ) )								( bindq *list ( rest *list ) ) ) )						( display> "atom=" debug ) ( display *atom debug )						( display *tag debug ) ( display ( second *list ) debug )						( return ( list *tag *atom ( second *list ) ) ) )comment:	There are several cases that need to be considered by check.atoms.offset.	It will return a list like ( ( a 1 ) ( b 2 ) ( c 1 ) ( d 3 ) ) for multi.sequenced protiens,	but for single sequences it only returns ( 1 ).comment;c:	CHECK.ATOMS.OFFSET	sub.of		function	i.take		list	i.give		list	arguments	*list	my.vars	*atom *seqs *first *seq *offset *number	algorithm	( do	( bindq *offset nil )						( bindq *seqs ( get 'pdb.data 'my.data ) )						( loop.until ( null? *list )							( do	( bindq *first ( first *list ) )								( bindq *atom ( second *first ) )								( bindq *seq ( first *seqs ) )								( display> "atom" debug ) ( display *first debug )								( display> "sequence" debug ) ( display *seq debug )								( if.true ( same? ( first *first ) ( first *seq ) )									( do	( bindq *seq ( rest *seq ) )											( cond	( ( same? *atom ( first *seq ) )														( bindq *offset ( cons ( list ( first *first ) ( third *first ) ) *offset ) ) )													( T ( do	( bindq *number ( third *first ) )															( loop.until ( equal? *number 1 )																( do ( bindq *seq ( rest *seq ) )																	( bindq *number ( sub1 *number ) ) ) )																( if.true ( same? *atom ( first *seq ) )																	( bindq *offset ( cons ( list ( first *first ) 1 ) *offset ) ) ) ) ) ) ) )								( bindq *seqs ( rest *seqs ) )								( bindq *list ( rest *list ) ) ) )						( if.true ( null? ( first ( first *offset ) ) )							( bindq *offset ( list ( second ( first *offset ) ) ) ) )						( bindq *offset ( reverse *offset ) )						( display> "out fo check.atoms" debug ) ( display *offset debug )						( return *offset ) )c:	GET.ATOMS	sub.of		function	i.take		none	i.give		list	my.vars	*tags *num.seq *first.atom *atoms *atom	algorithm	( do	( bindq *tags nil )						( display> "PDB.DATA" debug ) ( display ( get 'pdb.data 'my.data ) debug )						( bindq *num.seq ( length ( get 'pdb.data 'my.data ) ) )						( display> "number of sequences is" debug ) ( display *num.seq debug )						( bindq *first.atom ( get.atom.offset ) )						( bindq  *tags ( cons ( first *first.atom ) *tags ) )						( bindq *atoms ( list *first.atom ) )						( display> "atoms" debug ) ( display *atoms debug )						( bindq *num.seq ( sub1 *num.seq ) )						( loop.until ( equal? *num.seq 0 )							( do	( display> "into loop get.atoms" debug )									( bindq *first.atom ( find.next.atom ( first *first.atom ) ) )									( if.true ( not? ( member? ( first *first.atom ) *tags ) )										( do ( bindq  *tags ( cons ( first *first.atom ) *tags ) )											( bindq *atoms ( cons *first.atom *atoms ) ) ) )									( display> "atoms" debug ) ( display *atoms debug )									( bindq *num.seq ( sub1 *num.seq ) ) ) )						( bindq *atoms ( reverse *atoms ) )						( display> "atoms" debug ) ( display *atoms debug )						( bindq *atoms ( check.atoms.offset *atoms ) )						( display> "atoms" debug ) ( display *atoms debug )						( return *atoms ) )\ =============================={	SEQRES.LEX	description:		get rid of junk in seqres line	example input:		( SEQRES   1    213  MET ASN TYR THR LYS PHE ASP VAL LYS ASN TRP VAL ARG  1CLA 146 )	example output:	(  MET ASN TYR THR LYS PHE ASP VAL LYS ASN TRP VAL ARG )	notes:				Many proteins have subsequences, they need to be found.	}c:	SEQRES.LEX	sub.of		function	i.take		list	i.give		list	arguments	*list	my.vars	*seq.tag	algorithm	( do	( loop.until ( member? ( third *list ) *amino.acids )								( bindq *list ( rest *list ) ) )				\ get to first amino acid						( bindq *seq.tag ( first *list ) )						( if.true ( number? *seq.tag )							( bindq *seq.tag nil) )						( bindq *list ( rest ( rest *list ) ) )						( bindq *list ( reverse *list ) )						( loop.until ( member? ( first *list ) *amino.acids )								( bindq *list ( rest *list ) ) )				  \ nuke hind end junk						( display> "seqres.lex" debug ) ( display ( list *seq.tag ( reverse *list ) ) debug )						( return ( list *seq.tag ( reverse *list ) ) ) )comment:c:	SEQRES.LEX	sub.of		function	i.take		list	i.give		list	arguments	*list	algorithm	( do	( loop.until ( member? ( first *list ) *amino.acids )								( bindq *list ( rest *list ) ) )				\ get to first amino acid						( bindq *list ( reverse *list ) )						( loop.until ( member? ( first *list ) *amino.acids )								( bindq *list ( rest *list ) ) )				  \ nuke hind end junk						( display> "seqres.lex" debug ) ( display ( reverse *list ) debug )						( return ( reverse *list ) ) )comment;\ =============================={	COLLECT.SEQRES	description:		read data to *con 'my.data	example input:		x	example output:	( T T )  if hit eof before running out of seqres lines 						( T F )  if got-em all and hit eof						( F T ) if got-em all before eof						( F F ) should never exit like this	notes:				starts at first line of seqres data which is in "tempstring"		makes an entry like:			( PRO GLY GLU ARG ... )		on entry, we are at the first line of SEQRES data		so we collect more lines until we nolonger get SEQRES lines}c:	COLLECT.SEQRES	sub.of		function	i.take		symbol	i.give		list	arguments	*con	my.vars	*eof  *thelist *templist *seq.tag *truth	algorithm	( do	\ ( display> "collecting seqres" debug )						( set.value *con 'my.data nil )						( bindq *thelist nil )						( bindq *templist ( bio-listline ) )						( bindq *templist ( seqres.lex *templist ) )						\ ( display> "templist" debug ) ( display *templist debug )						( bindq *seq.tag ( first *templist ) )						( bindq *templist ( second *templist ) )						\ ( display> "templist" debug ) ( display *templist debug )						( bindq *thelist  ( reverse *templist ) )						( bindq *eof F )						( bindq *truth T )						( loop.until	( or? *eof  ( not? *truth ) )							( do	( bindq *eof ( bio-readline ) )									( bindq *truth ( t-seqres? ) )									( if.true	*truth 										( do ( bindq *templist ( bio-listline ) )											( bindq *templist ( seqres.lex *templist ) )											\ ( display> "tags" debug ) ( display *seq.tag debug ) ( display ( first *templist ) debug )											( cond	( ( same? *seq.tag ( first *templist ) )														( do	( bindq *templist ( second *templist ) )																\ ( display> "templist" debug ) ( display *templist debug )																( bindq *thelist ( concat  ( reverse *templist ) *thelist ) ) ) )													( T ( do	\ ( display> "thelist" debug ) ( display ( cons *seq.tag ( reverse *thelist ) ) debug )															\ ( display> ( value.of *con 'my.data )  debug )															( cond ( ( null? ( value.of *con 'my.data ) )																	( put *con 'my.data ( list ( cons *seq.tag ( reverse *thelist ) ) ) ) )																	( T ( append.value *con 'my.data ( cons *seq.tag ( reverse *thelist ) ) ) ) )															( bindq *seq.tag ( first *templist ) )															( bindq *templist ( second *templist ) )															( bindq *thelist  ( reverse *templist ) ) ) ) ) ) ) ) )						\ ( display> "thelist" debug ) ( display ( cons *seq.tag ( reverse *thelist ) ) debug )						( cond ( ( null? ( value.of *con 'my.data ) )								( put *con 'my.data ( list ( cons *seq.tag ( reverse *thelist ) ) ) ) )								( T ( append.value *con 'my.data ( cons *seq.tag ( reverse *thelist ) ) ) ) )						\ ( display ( list *eof *truth ) debug )						( return ( list *eof *truth ) ) )comment:c:	COLLECT.SEQRES	sub.of		function	i.take		symbol	i.give		list	arguments	*con	my.vars	*eof  *thelist *templist *truth	algorithm	( do	\ ( display> "collecting seqres" debug )						( bindq *thelist nil )						( bindq *templist ( bio-listline ) )						( bindq *templist ( seqres.lex *templist ) )						( bindq *thelist ( concat ( reverse *templist ) *thelist ) )						( bindq *eof F )						( bindq *truth T )						( loop.until	( or? *eof  ( not? *truth ) )							( do	( bindq *eof ( bio-readline ) )									( bindq *truth ( t-seqres? ) )									( if.true	*truth 										( do ( bindq *templist ( bio-listline ) )											( bindq *templist (seqres.lex *templist ) )											( bindq *thelist ( concat  ( reverse *templist ) *thelist ) ) ) ) ) )						\ ( display> "thelist" debug ) ( display *thelist debug )						( put *con 'my.data ( list ( reverse *thelist ) ) ) \ put a single sequence-list						\ ( display ( list *eof *truth ) debug )						( return ( list *eof *truth ) ) )comment;		\ =============================={	SCAN.TILL.HELIX	description:		look for beginning of helix data	example input:		x	example output:		( F T ) if "HELIX" found						( T F ) if "HELIX not found						( T T ) if "ATOM" found	we went past HELIX	notes:				x}c:	SCAN.TILL.HELIX	sub.of		function	i.take		none	i.give		list	my.vars	*eof *helix *atom	algorithm	( do	( display> "scan.till.helix" debug ) 						( bindq *eof F )						( bindq *atom F )						( bindq *helix ( t-helix? )  )						( loop.until	( or?	*helix  ( or? *atom *eof ) )								( do ( bindq *eof ( bio-readline ) )									( if.true	( not? *eof )										( do	( bindq *helix ( t-helix? ) ) 												( bindq *atom ( t-atom? ) ) ) ) ) )						( if.true	*atom								( do ( bindq *eof T )									( bindq *helix T ) ) )						( display ( list *eof *helix ) debug )						( return ( list *eof *helix ) ) )\ =============================={	CACHE.HELIX	description:		read raw data to *con 'my.data	example input:		typically: PDB.DATA	example output:		T if hit eof before running out of helix lines	notes:				starts at first line of helix data				just copy the lines of helix data to the fram}c:	CACHE.HELIX	sub.of		function	i.take		symbol	i.give		list	arguments	*con	my.vars	*eof  *thelist *templist *truth	algorithm	( do	( display> "collecting helix" debug )						( bindq *thelist nil )						( bindq *templist ( bio-listline ) )						( display *templist debug )						( bindq *thelist ( cons *templist *thelist ) )						( bindq *eof F )						( bindq *truth T )						( loop.until	( or? *eof  ( not? *truth ) )							( do	( bindq *eof ( bio-readline ) )									( bindq *truth ( t-helix? ) )									( if.true	*truth 										( do ( bindq *templist ( bio-listline ) )											\ ( display *templist debug )											( bindq *thelist ( cons   *templist  *thelist ) ) ) ) ) )						\ ( display> "the list from cache.helix =" debug ) ( display *thelist debug )						( put *con 'helices ( reverse *thelist ) )						( return ( list *eof *truth ) ) )\ =============================={	HELIX.LEX	description:		get rid of junk in seqres line	example input:		( HELIX 1 A ALA 12 GLN 31 1 3WRP 96 ) 1			or: 		(HELIX 1 H1 ARG 19 ARG 28 1 24-28 RIGHT-HANDED PI 1CLA 176) 6	example output:		(  MET ASN TYR THR LYS PHE ASP VAL LYS ASN TRP VAL ARG )	notes:				x		makes an entry like:			( PRO GLY GLU ARG ... )		parsing the left end implies doing "rest" until "first" gets an amino acid		parsing the right end implies doing "rest" until "length" = 4		because of an "offset" in the datafiles, we must grab lines of helix data from the file, saving them		in "helices" list until later, then must get the FIRST line of ATOM, and get from it the offset		which is the number of the amino acid that atom belongs to--it could be 0, 6, or other, or typically 1.}c:	HELIX.LEX	sub.of		function	i.take		list list	i.give		list	arguments	*seqres *offset				my.vars	*truth *tag *aminos *sub *name *off *temp *num.set *count	algorithm	( do	\ ( display> "helix.lex <<" debug ) ( display *seqres debug ) ( display *offset debug )						( bindq *truth F )						( bindq *tag nil )						( bindq *aminos ( get 'pdb.data 'my.data ) )	\ seq-list \ &&&&not general&&&&						\ ( display> "*aminos=" debug ) ( display *aminos debug )						( display> "*seqres=" debug ) ( display *seqres debug )						\ ( display> "*amino.acids=" debug ) ( display *amino.acids debug )						( loop.until	( or? ( null? *seqres ) ( member? ( first *seqres ) *amino.acids ) )	\ get to first amino acid									( bindq *seqres ( rest *seqres ) ) )						( if.true ( null? *seqres )							( display "Helix list never matched list" ERROR ) )						( if.true	( not? ( number? ( second *seqres ) ) )							( do	( bindq *tag ( second *seqres ) )									( display> "tag" debug ) ( display *tag debug )									( bindq *seqres ( delete ( second *seqres ) *seqres ) )									( bindq *seqres ( delete ( fourth *seqres ) *seqres ) ) ) )						( bindq *seqres ( reverse *seqres ) )						( loop.until	( equal? ( length *seqres ) 4 )				\ nuke hind-end junk									( bindq *seqres ( rest *seqres ) ) )						\ ( display> "seqres" debug ) ( display *seqres debug )						( cond	( ( notnull? *tag )									( bindq *seqres ( list *tag ( reverse *seqres ) ) ) )								( T ( bindq *seqres ( reverse *seqres ) ) ) )						( display> "list.like" debug ) ( display *seqres debug )  \ *seqres looks like ( ALA 12 GLN 31 ) or ( A ALA 12 GLN 31 )						( bindq *temp nil )						( cond	( ( member? ( first *seqres ) *amino.acids )									( do	( bindq *truth T )											\ ( display> "only one sequence" debug ) ( display ( first *aminos ) debug ) 											( bindq *sub ( first *aminos ) )											( bindq *num.set ( first *offset ) ) ) )								( T ( do	\ ( display> "more than one sequence" debug ) ( display *aminos debug )										( bindq *sub ( first *aminos ) )										\ ( display> "sub" debug ) ( display *sub debug )										( bindq *name ( first *sub ) )										\ ( display> "name" debug ) ( display *name debug )										( loop.until ( same? *tag *name )											( do	( bindq *aminos ( rest *aminos ) )													\ ( display> "aminos" debug ) ( display *aminos debug )													( bindq *sub ( first *aminos ) )													\ ( display> "sub" debug ) ( display *sub debug )													( bindq *name ( first *sub ) ) ) )										( bindq *off ( first *offset ) )										( bindq *name ( first *off ) )										\ ( display> "name" debug ) ( display *name debug )										( loop.until ( same? *tag *name )											( do	( bindq *offset ( rest *offset ) )													\ ( display> "offset" debug ) ( display *offset debug )													( bindq *off ( first *offset ) )													\ ( display> "off" debug ) ( display *off debug )													( bindq *name ( first *off ) ) ) )										( bindq *num.set ( second *off ) )										( bindq *seqres ( second *seqres ) )										\ ( display> "seqres" debug ) ( display *seqres debug )										) ) )						( display> "num.set" debug ) ( display *num.set debug )						( bindq *count ( minus ( second *seqres ) *num.set ) )						( display> "count" debug ) ( display *count debug )						( loop.until		( equal? *count 0 )							( do	( bindq *sub ( rest *sub ) )									( bindq *count ( minus *count 1 ) ) ) )						( bindq *count ( minus ( fourth *seqres ) ( second *seqres ) ) )						( bindq *count ( plus  *count 1 ) )						( bindq *sub ( rest *sub ) )						\ ( display> "sub=" debug ) ( display *sub debug )						( loop.until		( equal? *count  0 )							( do	( bindq *temp ( cons ( first *sub ) *temp ) )									( bindq *sub ( rest *sub ) )									( bindq *count ( minus *count 1 ) ) ) )						( bindq *temp ( reverse *temp ) )						( display> "helix.lex >>" debug ) ( display *temp debug )						( return *temp ) )\ =============================={	CONVERT.HELIX	description:		convert raw helix data to actual helix sequences	example input:		typically: PDB.DATA 1	example output:		T if hit eof before running out of helix lines	notes:				raw data is in *con 'my.data			must wait until "offset" found in first line of ATOM}c:	CONVERT.HELIX	sub.of		function	i.take		symbol list	i.give		flag	arguments	*con *offset	my.vars		*raw  *thelist *templist 	algorithm	( do	\ ( display> "CONVERT.HELIX <<" debug ) ( display *con debug ) ( display *offset debug )						( bindq *thelist nil )						( bindq *raw ( get *con 'helices ) ) 	\ list of sequences						\ ( display> "raw=" debug ) ( display *raw debug )						( loop.until	( null? *raw )							( do	( bindq *templist ( first *raw ) ) 	\ one sequence-list									( bindq *raw ( rest *raw ) )									( bindq *templist ( helix.lex *templist  *offset ) )									\ ( display> templist.from.helix.lex= debug ) ( display *templist debug )									( bindq *thelist ( cons   *templist  *thelist ) ) ) )						\ ( display> "the list from convert.helix =" debug ) ( display *thelist debug )						( put *con 'helices ( reverse *thelist ) )						( return ( null? *thelist  ) ) )comment:			( bindq *num.seq ( length ( value.of 'pdb.data 'my.data ) ) )			( bindq *atom ( scan.till.atom *files ) )	\ get offset			( bindq *offset ( get.atom.offset *num.seq ) )			( bindq *offset ( check.atom.offset *offset ) )			( bindq *x ( convert.helix 'pdb.data *offset ) )comment;COMMENT:CHANGE TO SHEET\ =============================={	SCAN.TILL.SHEET	description:		look for beginning of sheet data	example input:		x	example output:		( F T ) if "SHEET" found						( T F ) if "SHEET not found						( T T ) if "ATOM" found	we went past SHEET	notes:				x}c:	SCAN.TILL.SHEET	sub.of		function	i.take		none	i.give		list	my.vars	*eof *sheet *atom	algorithm	( do	( display> "scan.till.sheet" debug ) 						( bindq *eof F )						( bindq *atom F )						( bindq *sheet ( t-sheet? )  )						( loop.until	( or?	*sheet  ( or? *atom *eof ) )								( do ( bindq *eof ( bio-readline ) )									( if.true	( not? *eof )										( do	( bindq *sheet ( t-sheet? ) ) 												( bindq *atom ( t-atom? ) ) ) ) ) )						( if.true	*atom								( do ( bindq *eof T )									( bindq *sheet T ) ) )						( display ( list *eof *sheet ) debug )						( return ( list *eof *sheet ) ) )\ =============================={	CACHE.SHEET	description:		read raw data to *con 'my.data	example input:		typically: PDB.DATA	example output:		T if hit eof before running out of sheet lines	notes:				starts at first line of sheet data				just copy the lines of sheet data to the fram}c:	CACHE.SHEET	sub.of		function	i.take		symbol	i.give		list	arguments	*con	my.vars	*eof  *thelist *templist *truth	algorithm	( do	( display> "collecting sheet" debug )						( bindq *thelist nil )						( bindq *templist ( bio-listline ) )						( display *templist debug )						( bindq *thelist ( cons *templist *thelist ) )						( bindq *eof F )						( bindq *truth T )						( loop.until	( or? *eof  ( not? *truth ) )							( do	( bindq *eof ( bio-readline ) )									( bindq *truth ( t-sheet? ) )									( if.true	*truth 										( do ( bindq *templist ( bio-listline ) )											\ ( display *templist debug )											( bindq *thelist ( cons   *templist  *thelist ) ) ) ) ) )						\ ( display> "the list from cache.sheet =" debug ) ( display *thelist debug )						( put *con 'sheet ( reverse *thelist ) )						( return ( list *eof *truth ) ) )\ =============================={	SHEET.LEX	description:		get rid of junk in seqres line	example input:		( SHEET 1 A ALA 12 GLN 31 1 3WRP 96 ) 1			or: 		(SHEET 1 H1 ARG 19 ARG 28 1 24-28 RIGHT-HANDED PI 1CLA 176) 6	example output:		(  MET ASN TYR THR LYS PHE ASP VAL LYS ASN TRP VAL ARG )	notes:				x		makes an entry like:			( PRO GLY GLU ARG ... )		parsing the left end implies doing "rest" until "first" gets an amino acid		parsing the right end implies doing "rest" until "length" = 4		because of an "offset" in the datafiles, we must grab lines of sheet data from the file, saving them		in "sheet" list until later, then must get the FIRST line of ATOM, and get from it the offset		which is the number of the amino acid that atom belongs to--it could be 0, 6, or other, or typically 1.}c:	SHEET.LEX	sub.of		function	i.take		list list	i.give		list	arguments	*seqres *offset				my.vars	*truth *tag *aminos *sub *name *off *temp *num.set *count	algorithm	( do	\ ( display> "sheet.lex <<" debug ) ( display *seqres debug ) ( display *offset debug )						( bindq *truth F )						( bindq *tag nil )						( bindq *aminos ( get 'pdb.data 'my.data ) )	\ seq-list \ &&&&not general&&&&						\ ( display> "*aminos=" debug ) ( display *aminos debug )						( display> "*seqres=" debug ) ( display *seqres debug )						\ ( display> "*amino.acids=" debug ) ( display *amino.acids debug )						( loop.until	( or? ( null? *seqres ) ( member? ( first *seqres ) *amino.acids ) )	\ get to first amino acid									( bindq *seqres ( rest *seqres ) ) )						( if.true ( null? *seqres )							( display "SHEET list never matched list" ERROR ) )						( if.true	( not? ( number? ( second *seqres ) ) )							( do	( bindq *tag ( second *seqres ) )									( display> "tag" debug ) ( display *tag debug )									( bindq *seqres ( delete ( second *seqres ) *seqres ) )									( bindq *seqres ( delete ( fourth *seqres ) *seqres ) ) ) )						( bindq *seqres ( reverse *seqres ) )						( loop.until	( equal? ( length *seqres ) 4 )				\ nuke hind-end junk									( bindq *seqres ( rest *seqres ) ) )						\ ( display> "seqres" debug ) ( display *seqres debug )						( cond	( ( notnull? *tag )									( bindq *seqres ( list *tag ( reverse *seqres ) ) ) )								( T ( bindq *seqres ( reverse *seqres ) ) ) )						( display> "list.like" debug ) ( display *seqres debug )  \ *seqres looks like ( ALA 12 GLN 31 ) or ( A ALA 12 GLN 31 )						( bindq *temp nil )						( cond	( ( member? ( first *seqres ) *amino.acids )									( do	( bindq *truth T )											\ ( display> "only one sequence" debug ) ( display ( first *aminos ) debug ) 											( bindq *sub ( first *aminos ) )											( bindq *num.set ( first *offset ) ) ) )								( T ( do	\ ( display> "more than one sequence" debug ) ( display *aminos debug )										( bindq *sub ( first *aminos ) )										\ ( display> "sub" debug ) ( display *sub debug )										( bindq *name ( first *sub ) )										\ ( display> "name" debug ) ( display *name debug )										( loop.until ( same? *tag *name )											( do	( bindq *aminos ( rest *aminos ) )													\ ( display> "aminos" debug ) ( display *aminos debug )													( bindq *sub ( first *aminos ) )													\ ( display> "sub" debug ) ( display *sub debug )													( bindq *name ( first *sub ) ) ) )										( bindq *off ( first *offset ) )										( bindq *name ( first *off ) )										\ ( display> "name" debug ) ( display *name debug )										( loop.until ( same? *tag *name )											( do	( bindq *offset ( rest *offset ) )													\ ( display> "offset" debug ) ( display *offset debug )													( bindq *off ( first *offset ) )													\ ( display> "off" debug ) ( display *off debug )													( bindq *name ( first *off ) ) ) )										( bindq *num.set ( second *off ) )										( bindq *seqres ( second *seqres ) )										\ ( display> "seqres" debug ) ( display *seqres debug )										) ) )						( display> "num.set" debug ) ( display *num.set debug )						( bindq *count ( minus ( second *seqres ) *num.set ) )						( display> "count" debug ) ( display *count debug )						( loop.until		( equal? *count 0 )							( do	( bindq *sub ( rest *sub ) )									( bindq *count ( minus *count 1 ) ) ) )						( bindq *count ( minus ( fourth *seqres ) ( second *seqres ) ) )						( bindq *count ( plus  *count 1 ) )						( bindq *sub ( rest *sub ) )						\ ( display> "sub=" debug ) ( display *sub debug )						( loop.until		( equal? *count  0 )							( do	( bindq *temp ( cons ( first *sub ) *temp ) )									( bindq *sub ( rest *sub ) )									( bindq *count ( minus *count 1 ) ) ) )						( bindq *temp ( reverse *temp ) )						( display> "sheet.lex >>" debug ) ( display *temp debug )						( return *temp ) )\ =============================={	CONVERT.SHEET	description:		convert raw sheet data to actual sheet sequences	example input:		typically: PDB.DATA 1	example output:		T if hit eof before running out of sheet lines	notes:				raw data is in *con 'my.data			must wait until "offset" found in first line of ATOM}c:	CONVERT.SHEET	sub.of		function	i.take		symbol list	i.give		flag	arguments	*con *offset	my.vars		*raw  *thelist *templist 	algorithm	( do	\ ( display> "CONVERT.SHEET <<" debug ) ( display *con debug ) ( display *offset debug )						( bindq *thelist nil )						( bindq *raw ( get *con 'sheet ) ) 	\ list of sequences						\ ( display> "raw=" debug ) ( display *raw debug )						( loop.until	( null? *raw )							( do	( bindq *templist ( first *raw ) ) 	\ one sequence-list									( bindq *raw ( rest *raw ) )									( bindq *templist ( sheet.lex *templist  *offset ) )									\ ( display> templist.from.sheet.lex= debug ) ( display *templist debug )									( bindq *thelist ( cons   *templist  *thelist ) ) ) )						\ ( display> "the list from convert.sheet =" debug ) ( display *thelist debug )						( put *con 'sheet ( reverse *thelist ) )						( return ( null? *thelist  ) ) )COMMENT;\ ____________________________________________________________ FILE READINGcomment:	scan till seqres	read data into "raw.data" of experiment frame	scan till helix	build helices slot of experiment frame	if eof found, get next file from current file listcomment;\ =============================={	BIO-READFILE	description:		get data	example input:		list of file names	( 3wp1 3wp2 ... )	example output:			notes:				read data to PDB.DATA frame}c:	BIO-READFILE	sub.of		function	i.take		list	i.give		none	arguments	*files	my.vars	*seqres *helix *refnum *offset *atom *x	algorithm	( do ( display> "reading:" debug ) ( display *files debug )					( bindq *seqres F )					( bindq *helix F )					( loop.until	( null? *files )						( do	( bindq *refnum ( bio-open ( first *files ) ) )								( cond	( ( equal? *refnum 0 )										  ( display> "cannot open file" debug ) )										( T	( do \ ( display> "looking for seqres in" debug ) 												\ ( display ( first *files ) debug )												( bindq *seqres ( scan.till.seqres ) )												( if.true	( and?	( second *seqres ) ( not? ( first *seqres ) ) )													( do ( bindq *seqres ( collect.seqres 'pdb.data ) )														\ *seqres = ( T T  ) if eof before all seqres collected														( if.true	( not? ( second *seqres ) )															( do ( display> "looking for helix in" debug ) 																( display ( first *files ) debug )																( bindq *helix ( scan.till.helix ) )																\ *helix = ( T F ) if eof before helix found																( cond	( ( and? ( second *helix ) ( not? ( first *helix ) ) )																	 	( do ( bindq *helix ( cache.helix 'pdb.data ) )																			( bindq *atom nil )																				\ ( display> "about to scan atom" debug ) ( display ( first *files ) debug )																			( bindq *atom ( scan.till.atom *files ) )	\ get offset																			( display> ( show.node 'pdb.data ) log )																			( bindq *offset ( get.atoms ) )																			( display> "offset:" debug ) ( display *offset debug )																			( bindq *x ( convert.helix 'pdb.data *offset ) )																			( bindq *files nil ) ) )			\ done																		( T ( set.value 'pdb.data 'helices nil ) ) )																	\ ( if.true ( and? ( not? ( second *helix ) )																\				( not? ( first *helix ) ) )																\		( bindq *files nil ) )																		 ) ) ) ) ) ) )								( bio-close )								( bindq *files ( rest *files ) ) 								( if.true	( and? ( first *seqres ) ( second *seqres ) )	\ hit ATOM											( bindq *files nil ) )								\ ( if.true	( second *atom )			\ got first line of atom--nuke *files								\			( bindq *files nil ) )								( if.true	( and? ( first *helix ) ( second *helix ) )	\ hit ATOM											( bindq *files nil ) ) ) ) )comment:c:	BIO-TEST	sub.of	function	i.take	none	i.give	none	algorithm	( bio-readfile ( first ( select 'data.files from 'experiment.h3 ) ) )comment;comment:C:  PDB.DATA     INSTANCE.OF     DATA.BASE    MY.DATA         ( MET ALA GLN GLN SER PRO TYR SER ALA ALA MET ALA GLU GLN ARG 					HIS GLN GLU TRP LEU ARG PHE VAL ASP LEU LEU LYS ASN ALA TYR GLN 					ASN ASP LEU HIS LEU PRO LEU LEU ASN LEU MET LEU THR PRO ASP GLU 					ARG GLU ALA LEU GLY THR ARG VAL ARG ILE VAL GLU GLU LEU LEU ARG 					GLY GLU MET SER GLN ARG GLU LEU LYS ASN GLU LEU GLY ALA GLY ILE 					ALA THR ILE THR ARG GLY SER ASN SER LEU LYS ALA ALA PRO VAL GLU 					LEU ARG GLN TRP LEU GLU GLU VAL LEU LEU LYS SER ASP )	* patched to be correct * HELICES         ( ALA GLU GLN ARG HIS GLN GLU TRP LEU ARG PHE  VAL ASP LEU LEU LYS ASN ALA TYR GLN )  ( HIS LEU PRO LEU LEU ASN LEU MET )  ( ASP GLU ARG GLU ALA LEU GLY THR ARG VAL ARG ILE VAL GLU GLU LEU LEU ARG )   ( GLN ARG GLU LEU LYS ASN GLU )  ( ILE ALA THR ILE THR ARG GLY SER ASN SER LEU LYS ALA )  ( VAL GLU LEU ARG GLN TRP LEU GLU GLU VAL LEU LEU )C:  PDB.DATA     INSTANCE.OF     DATA.BASE    MY.DATA         ( MET ALA GLN GLN SER PRO TYR SER ALA ALA MET ALA GLU GLN ARG					HIS GLN GLU TRP LEU ARG PHE VAL ASP LEU LEU LYS ASN ALA TYR GLN 					ASN ASP LEU HIS LEU PRO LEU LEU ASN LEU MET LEU THR PRO ASP GLU 					ARG GLU ALA LEU GLY THR ARG VAL ARG ILE VAL GLU GLU LEU LEU ARG					GLY GLU MET SER GLN ARG GLU LEU LYS ASN GLU LEU GLY ALA GLY ILE 					ALA THR ILE THR ARG GLY SER ASN SER LEU LYS ALA ALA PRO VAL GLU 					LEU ARG GLN TRP LEU GLU GLU VAL LEU LEU LYS SER ASP )*** wrong representation ***    HELICES         ( ( ALA GLU GLN ARG HIS GLN GLU TRP LEU ARG PHE 						VAL ASP LEU LEU LYS ASN ALA TYR GLN ) 				( HIS LEU PRO LEU LEU ASN LEU MET )				( ASP GLU ARG GLU ALA LEU GLY THR ARG VAL ARG ILE VAL GLU GLU LEU LEU ARG ) 				( GLN ARG GLU LEU LYS ASN GLU )				( ILE ALA THR ILE THR ARG GLY SER ASN SER LEU LYS ALA ) 				( VAL GLU LEU ARG GLN TRP LEU GLU GLU VAL LEU LEU ) )comment;