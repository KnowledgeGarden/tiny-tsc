{	Materials.T		".T" files are Taxonomy files		NOTES:	 +c: used in case concept already exists		950105	jp2: first cut based on AGJ notes	950301	jp2: minor updates	950415	jp2:	additions	Ideal Model of kinds of materials	+c:	<name>		sub.of				material		applications		...		characterizers		...		behavior.models		...		formation.models	...}+c:	MATERIAL	sub.of			stuff	\ =================================================GAS+c:	GAS	sub.of				material	\ ==============================================PLASMA+c:	PLASMA	sub.of				material\ ==============================================LIQUID+c:	LIQUID	sub.of				material	\ ==============================================SOLUTION+c:	SOLUTION	sub.of	material	\ &&&& should this be sub.of liquid ????						\ see "&&&&" in Extensions.TSC		+c:	ideal.solution		sub.of	solution			+c:	regular.solution		sub.of	solution			+c:	ELEMENT	sub.of		material		+c:	electropositive.element		sub.of	element		easily.dissociates.to	positive.ion free.electron		\ ==============================================INFERENCE SUPPORT{ ======================	BOND.TYPE		inputs	pair of elements	outputs	bond.type or UNKNOWN	========================= }{  commented out for now until we better understand this conceptc:	IS .EITHER?			\ this will need testing	instance.of	flow.pred	i.take		sx sx symbol	i.give		flag	arguments	*elem1 *elem2 *it	my.vars		*truth *defn	algorithm	( do	( bindq *defn ( value.of *it 'definition ) )						\ note: only one definition allowed						\ no error checking if definition is missing						( cond	( ( eval *defn *elem1 )								  ( bindq *truth T ) )								( ( eval *defn *elem2 )								  ( bindq *truth T ) )								( T ( bindq *truth F ) ) ) 						( return *truth ) )c:	IS.IT?	instance.of	flow.pred	i.take		symbol sx sx	i.give		flag	arguments	*bond *elem1 *elem2	my.vars		*truth *req	algorithm	( do			( bindq *truth F )		( bindq *req ( value.of *bond 'requires.pair ) )		( loop.until	( null? *req ) 			( do	( if.true ( is.either? 									*elem1 *elem2 ( first ( first *req ) ) )							( if.true ( is.either? 									*elem1 *elem2 ( second ( first *req ) ) )									( do	( bindq *truth T ) 											( bindq *req null )  \ kill list											) ) )					( bindq *req ( rest *req ) ) ) )  \ next requires		( return *truth ) )	c:	IS.IONIC?	instance.of	flow.pred	i.take		sx sx	i.give		flag	arguments	*elem1 *elem2	my.vars		*truth	algorithm	( is.it? 'ionic.bond *elem1 *elem2 )c:	IS.COVALENT?	instance.of	flow.pred	i.take		sx sx	i.give		flag	arguments	*elem1 *elem2	my.vars		*truth	algorithm	( is.it? 'covalent.bond *elem1 *elem2 )	c:	IS.METALLIC?	instance.of	flow.pred	i.take		sx sx	i.give		flag	arguments	*elem1 *elem2	my.vars		*truth	algorithm	( is.it? 'metallic.bond *elem1 *elem2 )	c:	BOND.TYPE	instance.of	flow.func	i.take		sx sx	i.give		symbol	arguments	*elem1 *elem2	my.vars		*val	Algorithm	( do	( cond	( ( is.ionic? *elem1 *elem2 )								  ( bindq *val 'ionic.bond ) )								( ( is.metallic? *elem1 *elem2 )								  ( bindq *val 'metallic.bond ) )								( ( is.covalent? *elem1 *elem2 )								  ( bindq *val 'covalent.bond ) )								\ more can be inserted here								( T ( bindq *val 'unknown ) ) )						( return *val ) )						This test will fail with unknown if the inputs are not elements.We need a way to ask the same type of question given compounds, crystals, etc.}